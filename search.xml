<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用技巧-numpy包</title>
      <link href="/mid-lake-pavilion.github.io/2024/03/04/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7-numpy%E5%8C%85/"/>
      <url>/mid-lake-pavilion.github.io/2024/03/04/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7-numpy%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>NumPy（Numerical Python）是Python中用于科学计算的一个重要库，它提供了一个强大的多维数组对象（称为ndarray），以及针对这些数组对象进行操作的各种函数。NumPy 是许多其他科学计算库的基础，如 SciPy、Pandas 和 Matplotlib。</p><p>通常导入numpy包简写为np：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本文仅记录一些本人在实践中常用的包方法。</p><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><h3 id="创建随机数组：np-random-rand"><a href="#创建随机数组：np-random-rand" class="headerlink" title="创建随机数组：np.random.rand()"></a>创建随机数组：np.random.rand()</h3><ul><li><code>np.random.rand(d0: int, d1: int, d2: int, ...)</code></li></ul><p>这是一个非常常用的创建随机数组的方法；它将创建一个形状为$(d_0, d_1, d_2, \dots)$的随机数组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[[0.12344769 0.62765118 0.01542036]  [0.64811143 0.34687265 0.97168938]  [0.5908757  0.57925054 0.1721152 ]  [0.89463742 0.74941611 0.66578358]] [[0.73119619 0.67648234 0.6159516 ]  [0.71659169 0.73652607 0.5434614 ]  [0.64428965 0.46184996 0.33439822]  [0.01748738 0.23332551 0.57695121]]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也可以创建整数随机数组，方法为</p><ul><li><code>np.random.randint(low: int, high: int, size: Tuple)</code></li></ul><p>它创建一个形状为<code>size</code>的整数数组，其中的整数范围均为$[low, high]$。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">int_data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>low<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> high<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>int_data<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[4 7 4] [1 1 9]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建全零-全一数组：np-zeros-np-ones"><a href="#创建全零-全一数组：np-zeros-np-ones" class="headerlink" title="创建全零/全一数组：np.zeros()/np.ones()"></a>创建全零/全一数组：np.zeros()/np.ones()</h3><ul><li><code>np.zeros(shape: Tuple, dtype)</code></li><li><code>np.ones(shape: Tuple, dtype)</code></li></ul><p>创建指定形状、指定数据类型的全零/全一数组。</p><ul><li><code>np.zeros_like(a: np.ndarray, dtype)</code></li><li><code>np.ones_like(a: np.ndarray, dtype)</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>data_zero <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data_zero<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[0. 0. 0. 0.] [0. 0. 0. 0.]][[1. 1. 1. 1.] [1. 1. 1. 1.]][[0. 0. 0. 0.] [0. 0. 0. 0.]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建有序数组：np-arange"><a href="#创建有序数组：np-arange" class="headerlink" title="创建有序数组：np.arange()"></a>创建有序数组：np.arange()</h3><ul><li><code>np.arange(start: int, stop: int, step: int)</code></li></ul><p>创建一个数组，首位元素为start，然后以step为步长取数组成数组。</p><h3 id="创建单位矩阵（数组）：np-eye"><a href="#创建单位矩阵（数组）：np-eye" class="headerlink" title="创建单位矩阵（数组）：np.eye()"></a>创建单位矩阵（数组）：np.eye()</h3><ul><li><code>np.eye(N: int, M: int, k: int)</code></li></ul><p>创建一个形状为（N, M）的矩阵，当参数<code>k</code>缺省时，其主对角线上元素均为1；否则全1的对角线会发生偏移。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]][[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.]][[0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p>即将其他数据类型转换为numpy的内置数据类型ndarray。</p><h3 id="list转数组：np-array"><a href="#list转数组：np-array" class="headerlink" title="list转数组：np.array()"></a>list转数组：np.array()</h3><ul><li><code>np.array(obj: Sequence)</code></li></ul><p>非常常用的方法，其中Sequence常为List，即将该对象转换为数组。</p><h3 id="读取文件为数组：np-loadtxt"><a href="#读取文件为数组：np-loadtxt" class="headerlink" title="读取文件为数组：np.loadtxt()"></a>读取文件为数组：np.loadtxt()</h3><ul><li><code>np.loadtxt(fname, dtype, delimiter)</code></li></ul><p>将文件内容读入数组类型，并可指定数据类型和文件分隔符。</p><h2 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h2><h3 id="最通用拼接方法：np-concatenate"><a href="#最通用拼接方法：np-concatenate" class="headerlink" title="最通用拼接方法：np.concatenate()"></a>最通用拼接方法：np.concatenate()</h3><ul><li><code>np.concatenate(arrays: List[np.ndarray], axis: int)</code></li></ul><p>将arrays中的数组，沿着axis维度进行拼接，得到新的数组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">array_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    array_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 每一个元素都是形状为(2, 1, 3)的三维数组</span><span class="token comment"># array_list是一个包含5个(2, 1, 3)形状的数组的列表</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>array_list<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：(2, 5, 3)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="按行、按列拼接：np-hstack-np-vstack"><a href="#按行、按列拼接：np-hstack-np-vstack" class="headerlink" title="按行、按列拼接：np.hstack()/np.vstack()"></a>按行、按列拼接：np.hstack()/np.vstack()</h3><ul><li><code>np.hstack(tup: List)</code>等价于<code>np.concatenate(arrays, axis=1)</code></li><li><code>np.vstack(tup: List)</code>等价于<code>np.concatenate(arrays, axis=0)</code></li></ul><p>上述两个方法的使用均是数组拼接的特殊情况：<code>np.hstack()</code>将数组水平拼接，也即沿着第二个维度拼接；<code>np.vstack()</code>将数组垂直拼接，也即沿着第一个维度拼接。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">array_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    array_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 每一个元素都是形状为(2, 1, 3)的三维数组</span><span class="token comment"># array_list是一个包含5个(2, 1, 3)形状的数组的列表</span>data_h <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span>array_list<span class="token punctuation">)</span>data_v <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span>array_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data_h<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data_v<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：(2, 5, 3)(10, 1, 3)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组变形"><a href="#数组变形" class="headerlink" title="数组变形"></a>数组变形</h2><h3 id="最朴素的变形方法：reshape"><a href="#最朴素的变形方法：reshape" class="headerlink" title="最朴素的变形方法：reshape()"></a>最朴素的变形方法：reshape()</h3><ul><li><code>np.reshape(a: np.ndarray, shape: int | Tuple[int])</code></li><li><code>np.ndarray.reshape(shape: Tuple[int])</code>或<code>np.ndarray.reshape(d_0, d_1, d_2, ...)</code></li></ul><p>这个方法非常简单实用，它可以将数组形状调整为指定形状$(d_0, d_1, d_2, \dots)$。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">B<span class="token punctuation">,</span> N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>B<span class="token operator">*</span>N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D<span class="token punctuation">)</span>a_new <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span>B<span class="token punctuation">,</span> N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a_new<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>b_new <span class="token operator">=</span> a<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>B<span class="token punctuation">,</span> N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b_new<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：(2, 5, 10, 8)(2, 5, 10, 8)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="展平：np-ndarray-flatten"><a href="#展平：np-ndarray-flatten" class="headerlink" title="展平：np.ndarray.flatten()"></a>展平：np.ndarray.flatten()</h3><ul><li><code>np.ndarray.flatten(order)</code></li></ul><p>这个方法可以将（高维）数组展平为一维数组，order参数可以指定展平顺序，默认不改变顺序。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">B<span class="token punctuation">,</span> N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>B<span class="token operator">*</span>N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D<span class="token punctuation">)</span>b <span class="token operator">=</span> a<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：(800,)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除维度：squeeze"><a href="#删除维度：squeeze" class="headerlink" title="删除维度：squeeze()"></a>删除维度：squeeze()</h3><ul><li><code>np.ndarray.squeeze(axis: int)</code></li><li><code>np.squeeze(a: np.ndarray, axis: int)</code></li></ul><p>这个方法可以删除指定维度，但是注意必须是单维度才可以删除。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>b <span class="token operator">=</span> a<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 删除第二维，该维度上的长度是1才可以删除</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：(2, 3)(2, 3)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加维度：np-expand-dims"><a href="#增加维度：np-expand-dims" class="headerlink" title="增加维度：np.expand_dims()"></a>增加维度：np.expand_dims()</h3><ul><li><code>np.expand_dims(a: np.ndarray, axis: int)</code></li></ul><p>在指定维上新增一个维度，且新增的维度长度为1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>d <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> c<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> d<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：(1, 2, 3) (2, 1, 3) (2, 3, 1)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组重复"><a href="#数组重复" class="headerlink" title="数组重复"></a>数组重复</h2><h3 id="同维度重复：repeat"><a href="#同维度重复：repeat" class="headerlink" title="同维度重复：repeat()"></a>同维度重复：repeat()</h3><p>由于某些特定的需求，可能需要对数组中的某些元素进行重复，以得到新的数组。</p><ul><li><code>np.repeat(a: np.ndarray, repeats: int | List, axis: int)</code></li><li><code>np.ndarray.repeat(repeats: int | List, axis: int)</code></li></ul><p>这个方法将在数组的指定维度上，将数组元素重复若干次（repeats参数既可以是单个整数，也可以是整数列表），具体效果见例子。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>a<span class="token punctuation">,</span> repeats<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> b<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>c <span class="token operator">=</span> a<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>d <span class="token operator">=</span> a<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> d<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[2 5 2] [5 7 5]] (2, 3)[[2 5 2] [2 5 2] [5 7 5] [5 7 5]] (4, 3)[[2 2 5 5 2 2] [5 5 7 7 5 5]] (2, 6)[[2 5 2] [5 7 5] [5 7 5]] (3, 3)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="支持维度扩展：tile"><a href="#支持维度扩展：tile" class="headerlink" title="支持维度扩展：tile()"></a>支持维度扩展：tile()</h3><ul><li><code>np.tile(A: np.ndarray, reps: int | Sequence[int])</code></li></ul><p>这个方法和上面的<code>np.repeat()</code>方法很像，差别主要有两点。首先，这个方法重复排列数组元素的方式不同；其次，这个方法支持维度扩展，即<strong>允许np.ndarray.ndim和len(reps)不一致</strong>，最后的新数组形状将取两者最大值。具体地，假设数组A形状为$(d_1, d_2,\dots,d_n)$，参数reps为$(r_1,r_2,\dots,r_m)$，则</p><ol><li>如果$n = m$即<code>A.ndim == len(reps)</code>，那么无需进行任何维度扩展，新数组形状即为$(d_1\times r_1, d_2\times r_2, \dots,d_n\times r_m)$；</li><li>如果$n &lt; m$即<code>A.ndim &lt; len(reps)</code>，那么将默认先对数组A进行维度扩展（前置添单维度）至形状$(c_1,c_2,\dots,c_{m-n},d_1,d_2,\dots,d_n)$，其中$c_1=c_2=\dots=c_{m-n}=1$；</li><li>如果$n&gt;m$即<code>A.ndim &gt; len(reps)</code>，那么将默认先对reps进行维度扩展（前置添单维度）至$(c_1,c_2,\dots,c_{n-m},r_1,r_2,\dots,r_m)$，其中$c_1=c_2=\dots=c_{n-m}=1$。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># a.ndim == 2</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>a<span class="token punctuation">,</span> reps<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># a.ndim == len(reps)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> b<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>a<span class="token punctuation">,</span> reps<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># a.ndim &lt; len(reps), a默认被升维到(1, 2, 3)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>d <span class="token operator">=</span> np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>a<span class="token punctuation">,</span> reps<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># a.ndim > len(reps), reps虽然为2, 但是会被当作(1, 2)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> d<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[0 2 3] [8 2 0]] (2, 3)[[0 2 3 0 2 3 0 2 3] [8 2 0 8 2 0 8 2 0] [0 2 3 0 2 3 0 2 3] [8 2 0 8 2 0 8 2 0]] (4, 9)[[[0 2 3 0 2 3]  [8 2 0 8 2 0]  [0 2 3 0 2 3]  [8 2 0 8 2 0]  [0 2 3 0 2 3]  [8 2 0 8 2 0]] [[0 2 3 0 2 3]  [8 2 0 8 2 0]  [0 2 3 0 2 3]  [8 2 0 8 2 0]  [0 2 3 0 2 3]  [8 2 0 8 2 0]]] (2, 6, 6)[[0 2 3 0 2 3] [8 2 0 8 2 0]] (2, 6)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>有时候需要对数组中的元素进行随机采样，numpy包就可以派上用场了。</p><h3 id="随机采样：np-random-choice"><a href="#随机采样：np-random-choice" class="headerlink" title="随机采样：np.random.choice()"></a>随机采样：np.random.choice()</h3><ul><li><code>np.random.choice(a: int | 1-D array, size: int, replace: boolean=True)</code></li></ul><p>这个方法可以从序列a中随机采样，采样数量为size，而replace指定了是否重复采样：</p><ol><li>（默认）如果replace为True，则进行放回采样，得到的样本可能有重复；</li><li>如果replace为False，则进行不放回采样，得到的样本不会有重复。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>choice_data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>data<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>choice_data<span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">(</span>choice_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[5 1 4 9 8] &lt;class 'numpy.ndarray'>'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="乱序排列：np-random-permutation"><a href="#乱序排列：np-random-permutation" class="headerlink" title="乱序排列：np.random.permutation()"></a>乱序排列：np.random.permutation()</h3><ul><li><code>np.random.permutation(x: int | array)</code></li></ul><p>它将随机打乱数组x，如果x为整数，则随机打乱一维数组$[0,1,\dots,x-1]$；而如果x为高维数组，则只会随机打乱第一维。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">out_of_order_data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>out_of_order_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'----------------------'</span><span class="token punctuation">)</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'(before shuffle)'</span><span class="token punctuation">)</span>out_of_order_data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>out_of_order_data<span class="token punctuation">,</span> <span class="token string">'after shuffle'</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''[0 5 1 9 7 3 4 6 2 8]----------------------[[4 5 4] [0 8 6] [6 2 7] [2 9 6] [2 9 9]] (before shuffle)[[0 8 6] [2 9 6] [2 9 9] [4 5 4] [6 2 7]] after shuffle'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><h3 id="np-linalg-norm"><a href="#np-linalg-norm" class="headerlink" title="np.linalg.norm()"></a>np.linalg.norm()</h3><p>numpy.linalg是范数常用的库，包括计算二范数、无穷范数等等。</p><ul><li><code>np.linalg.norm(x: ArrayLike, ord: int)</code></li></ul><p>这个方法通过参数ord指定要计算的范数，而参数x必须为一维或者二维数组。</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用技巧-pandas包</title>
      <link href="/mid-lake-pavilion.github.io/2024/03/04/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7-pandas%E5%8C%85/"/>
      <url>/mid-lake-pavilion.github.io/2024/03/04/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7-pandas%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>Pandas是一个基于Python编程语言的开源数据分析和数据处理库。它提供了一系列的数据结构，主要是DataFrame和Series，用于处理和分析表格数据（.csv、.xlsx等等）。</p><p>通常导入<code>pandas</code>包简写为<code>pd</code>，且pandas包经常和科学计算包numpy连用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="处理-csv文件"><a href="#处理-csv文件" class="headerlink" title="处理.csv文件"></a>处理.csv文件</h2><p>.csv文件是非常常见的表格文件，它其实就是以’,’为分隔的文本文件。很多数据处理的任务中，要处理的数据对象就是.csv文件类型。</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ul><li><code>pd.read_csv(filename: str, header: int |list | None, encoding, index_col: int | str | list)</code></li></ul><p>一般来说，在读取数据时只需要简单调用<code>df = pd.read_csv(filename)</code>即可将文件中的数据读入了。这里的<code>d</code>类型是pandas内置的数据结构<code>DataFrame</code>。</p><p>这里再介绍另外两个常见参数<code>header、encoding</code>的用法。</p><ul><li>header：指定文件中哪几行作为列名。<strong>对于.csv文件而言，通常第一行就是列名（表头），此时header参数保留缺省值即可；而如果文件没有表头，只需设置<code>header=None</code>即可。</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：        ID   Name  English  Mathematics  Physics0  2020001   Bill       95           78       801  2020005  Ellis       90           92       812  2020008  Louis       94           85       89注意：最左边的索引列并不是文件的原内容，因为在调用读取api时，并没有指定索引列，因此这里pandas库自动加入了自0开始逐一递增的索引列。从0开始的行才是真正的数据开始行。'''</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">,</span> header<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：         0      1        2            3        40       ID   Name  English  Mathematics  Physics1  2020001   Bill       95           78       802  2020005  Ellis       90           92       813  2020008  Louis       94           85       89'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>encoding：指定文件按何种码进行读取。常见选项：utf-8、gbk等等。</li><li>index_col：指定文件读取时的索引列。可以是列名（<code>str</code>），也可以是列序（<code>int</code>）。如果是列表，则列表中的列共同组成索引。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_file<span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：          Name  English  Mathematics  PhysicsID                                           2020001   Bill       95           78       802020005  Ellis       90           92       812020008  Louis       94           85       89'''</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_file<span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：               English  Mathematics  PhysicsID      Name                                2020001 Bill        95           78       802020005 Ellis       90           92       812020008 Louis       94           85       89'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><ul><li><code>DataFrame.values</code></li></ul><p>通常和<code>pd.read_csv(filename)</code>连用：<code>pd.read_csv(filename).values</code>，用于将读入文件的<code>DataFrame</code>对象转换为<code>np.ndarray</code>类型，接下来就可以利用numpy包中的各种接口处理数据了，非常实用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">csv_file <span class="token operator">=</span> <span class="token string">'./data.csv'</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_file<span class="token punctuation">)</span><span class="token punctuation">.</span>values<span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输出：[[2020001 'Bill' 95 78 80] [2020005 'Ellis' 90 92 81] [2020008 'Louis' 94 85 89]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>这一部分介绍一下常用的<code>DataFrame</code>属性和方法。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">csv_file <span class="token operator">=</span> <span class="token string">'./data.csv'</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_file<span class="token punctuation">,</span> usecols<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span>df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 返回最前2行的数据  head(n)</span>df<span class="token punctuation">.</span>tail<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 返回最后2行的数据  tail(n)</span>df<span class="token punctuation">.</span>shape <span class="token comment"># 返回数据表形状</span>df<span class="token punctuation">.</span>dtypes <span class="token comment"># 返回每一列数据类型</span>df<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回每一列中的非空值的个数</span>df<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回所有列的均值</span>df<span class="token punctuation">.</span>corr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回列与列之间的相关系数</span>df<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回每一列的最大值</span>df<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回每一列的最小值</span>df<span class="token punctuation">.</span>median<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回每一列的中位数</span>df<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回每一列的标准差</span>df<span class="token punctuation">.</span>var<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回每一列的方差</span><span class="token triple-quoted-string string">'''输出：   English  Mathematics  Physics0       95           78       801       90           92       812       94           85       89'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul><li><code>DataFrame.to_csv(filename: str, decimal: str, index: boolean)</code></li></ul><p>通常用上述方法将<code>DataFrame</code>对象保存为文件；所以在此之前我们需要先创建一个<code>DataFrame</code>对象：</p><ul><li><code>pd.DataFrame(data: np.ndarray, columns: list)</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>low<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> high<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 创建一个随机整数组成的二维矩阵</span>heads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'English'</span><span class="token punctuation">,</span> <span class="token string">'Mathematics'</span><span class="token punctuation">,</span> <span class="token string">'Physics'</span><span class="token punctuation">]</span> <span class="token comment"># 表头，列名组成的列表</span>df_new <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token operator">=</span>X<span class="token punctuation">,</span> columns<span class="token operator">=</span>heads<span class="token punctuation">)</span>df_new<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">'./new_data.csv'</span><span class="token punctuation">,</span> decimal<span class="token operator">=</span><span class="token string">','</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用技巧-python</title>
      <link href="/mid-lake-pavilion.github.io/2024/02/29/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7-python/"/>
      <url>/mid-lake-pavilion.github.io/2024/02/29/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7-python/</url>
      
        <content type="html"><![CDATA[<h1 id="python常用"><a href="#python常用" class="headerlink" title="python常用"></a>python常用</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="逆置数组"><a href="#逆置数组" class="headerlink" title="逆置数组"></a>逆置数组</h3><p>灵活运用某些API，将其步长参数设置为-1，可以非常便捷实现对象（列表、字符串等）逆置，比如使用<code>range(i, j, -1)</code>实现从i到j-1的逆向取数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''54321'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>龙格库塔算法</title>
      <link href="/mid-lake-pavilion.github.io/2024/02/02/%E9%BE%99%E6%A0%BC%E5%BA%93%E5%A1%94%E7%AE%97%E6%B3%95/"/>
      <url>/mid-lake-pavilion.github.io/2024/02/02/%E9%BE%99%E6%A0%BC%E5%BA%93%E5%A1%94%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="从微分方程初值问题说起"><a href="#从微分方程初值问题说起" class="headerlink" title="从微分方程初值问题说起"></a>从微分方程初值问题说起</h2><p>考虑微分方程初值问题：</p><script type="math/tex; mode=display">\begin{aligned}y'=\frac{dy}{dx} &= f(x,y), \quad a\leqslant x \leqslant b \\y(a) &= y_0\end{aligned}</script><p>要求解$y(x)$，即原函数。</p><p>在计算机领域，我们将会面临很多离散形式数据，而上述微分方程初值问题是在连续区间$[a,b]$上考虑的，于是接下来，我们仅考虑离散形式的初值问题。通俗地说，在上述初值问题前提下，对$a\leqslant x_0 \leqslant x_1 \leqslant x_2 \leqslant \dots \leqslant x_N = b$，步长$\Delta x$取常量$h$，求解每个点对应的函数值$y(x_i)$的近似值$y_i$是为目标（其中，$i=1,2\dots,N$）。</p><h2 id="（前向）欧拉方法"><a href="#（前向）欧拉方法" class="headerlink" title="（前向）欧拉方法"></a>（前向）欧拉方法</h2><p>先介绍一种比较简单的方法——欧拉方法。它的本质是使用差分来求出近似解。考虑$x_i$处，用前向差分近似微分：</p><script type="math/tex; mode=display">\frac{y(x_{i+1})-y(x_i)}{h} \approx f(x_i, y(x_i)), \quad i=0,1,\dots,N-1</script><p>于是</p><script type="math/tex; mode=display">y(x_{i+1}) = y(x_i) + hf(x_i,y(x_i))</script><p>接下来，用$y(x_i)$的近似值$y_i$代替之得到</p><script type="math/tex; mode=display">\begin{aligned}y_{i+1} &= y_i + hf(x_i,y_i) \\y_0 &= y(a)\end{aligned}</script><p>这便是差分方程初值问题，可以通过$y_0$逐步计算得到$y_1,y_2,\dots,y_N$。</p><h2 id="后向欧拉方法"><a href="#后向欧拉方法" class="headerlink" title="后向欧拉方法"></a>后向欧拉方法</h2><p>将上面的差分方程描述为</p><script type="math/tex; mode=display">y_{i+1} = y_i + h\bar{K}</script><p>其中，$\bar{K}$称为区间$[x_i,x_{i+1}]$上的平均斜率；上面的欧拉方法，实际上就是用区间左端点处的斜率$f(x_i,y_i)$作为了区间平均斜率，显然精度上有所欠缺。此外，也可以用区间右端点处的斜率$f(x_{i+1}，y_{i+1})$作为区间的平均斜率，即</p><script type="math/tex; mode=display">y_{i+1} = y_i + hf(x_{i+1},y_{i+1})</script><p>但是相比于前向欧拉方法，后向欧拉方法的计算复杂得多，因为$y_{i+1}$是隐式的。通常通过迭代公式进行计算：</p><script type="math/tex; mode=display">\begin{cases} y_{i+1}^{(0)} &= y_i + hf(x_i,y_i) \\y_{i+1}^{(k+1)} &= y_i + hf(x_{i+1},y_{i+1}^{(k)})\end{cases}</script><h2 id="改进欧拉方法"><a href="#改进欧拉方法" class="headerlink" title="改进欧拉方法"></a>改进欧拉方法</h2><p>在介绍改进欧拉方法之前，先回到原始的微分方程初值问题。我们将其的解表示为积分形式为</p><script type="math/tex; mode=display">y(x_{i+1}) - y(x_i) = \int_{x_i}^{x_{i+1}}f(x,y(x))dx,\quad i=0,1,\dots</script><p>于是问题的关键，就转化为了求解上述等式的右部，通常可以用<strong>矩形公式</strong>或者<strong>梯形公式</strong>计算。这里用梯形公式，得</p><script type="math/tex; mode=display">\int_{x_i}^{x_{i+1}}f(x,y(x))dx \approx \frac{h}{2}[f(x_i,y(x_i)) + f(x_{i+1},y(x_{i+1}))]</script><p>同样，用$y_i$代替$y(x_i)$，得</p><script type="math/tex; mode=display">y_{i+1} = y_i + \frac{h}{2}[f(x_i,y_i)+f(x_{i+1},y_{i+1})]</script><p>虽然用梯形公式计算得到的精度较高，但是其计算量较大。于是我们得到一种综合了矩形公式和梯形公式的<strong>改进欧拉方法</strong>：先用前向欧拉方法计算出一个初步近似值$\bar{y}_{i+1}$，然后利用梯形公式对其进行修正得到近似值$y_{i+1}$。</p><script type="math/tex; mode=display">\begin{cases}\displaystyle \bar{y}_{i+1} = y_i + hf(x_i,y_i) \\\displaystyle y_{i+1} = y_i + \frac{h}{2}[f(x_i,y_i) + f(x_{i+1},\bar{y}_{i+1})]\end{cases}</script><p>也就是说，改进欧拉方法中，平均斜率$\bar{K}$取$f(x_i,y_i),f(x_{i+1},\bar{y}_{i+1})$的平均值。</p><h2 id="龙格库塔算法"><a href="#龙格库塔算法" class="headerlink" title="龙格库塔算法"></a>龙格库塔算法</h2><p>那么，我们能否通过精度更大的$\bar{K}$来计算出更精确的$y_{i+1}$呢？答案是肯定的。<strong>通常在区间$[x_i,x_{i+1}]$上取若干点，将它们的斜率的加权平均作为整个区间的平均斜率$\bar{K}$</strong>。接下来，为了推导稍显简单，仍然取两个点，取加权平均作为平均斜率</p><script type="math/tex; mode=display">\begin{aligned}\bar{K} &= \lambda_1k_1 + \lambda_2k_2 \\y_{i+1} &= y_i + h\bar{K}\end{aligned}</script><p>其中，</p><script type="math/tex; mode=display">\begin{cases}k_1 = f(x_i, y_i) \\k_2 = f(x_i + \alpha h, y_i + \beta hk_1)\end{cases}</script><h3 id="确定系数"><a href="#确定系数" class="headerlink" title="确定系数"></a>确定系数</h3><p>至此，由于上式中的参数$\lambda_1,\lambda_2,\alpha,\beta$均为未知，于是接下来，尝试确定参数使得精度尽可能高。不过，在正式求解之前，先计算一下二阶微分，便于后续分析。</p><p>由于已知</p><script type="math/tex; mode=display">y'(x) = f(x,y)</script><p>故二阶微分</p><script type="math/tex; mode=display">y''(x) = f_x(x,y) + f_y(x,y)·y'(x) = f_x(x,y) + f(x,y)f_y(x,y)</script><p>分析局部截断误差$y(x_{i+1})-y_{i+1}$，注意到$y(x_i)=y_i$，对$k_1$，有</p><script type="math/tex; mode=display">k_1 = f(x_i, y_i) = f(x_i, y(x_i)) = y'(x_i)</script><p>对$k_2$，在$(x_i,y_i)$处进行泰勒展开，有</p><script type="math/tex; mode=display">\begin{aligned}k_2 &= f(x_i+\alpha h,y_i+\beta hk_1) \\&= f(x_i, y_i) + \alpha hf_x(x_i,y_i) + \beta hk_1f_y(x_i,y_i) + \mathcal{O}(h^2) \\ &= y'(x_i) + \alpha hf_x + \beta hk_1f_y + \mathcal{O}(h^2)\end{aligned}</script><p>于是，</p><script type="math/tex; mode=display">\begin{aligned}y_{i+1} &= y_i + h(\lambda_1 k_1+\lambda_2k_2) \\&= y(x_i) + h\lambda_1y'(x_i) + h\lambda_2(y'(x_i)+\alpha hf_x+\beta hk_1f_y+\mathcal{O}(h^2)) \\&= y(x_i) + (\lambda_1+\lambda_2)hy'(x_i) + \lambda_2\alpha h^2(f_x+\frac{\beta}{\alpha}y'(x_i)f_y) + \mathcal{O}(h^3)\end{aligned}</script><p>而</p><script type="math/tex; mode=display">\begin{aligned}y(x_{i+1}) &= y(x_i) + hy'(x_i) + \frac{h^2}{2}y''(x_i) + \mathcal{O}(h^3) \\&= y(x_i) + hy'(x_i) + \frac{h^2}{2}(f_x+y'(x_i)f_y) + \mathcal{O}(h^3) \\\end{aligned}</script><p>要使得$y_{i+1} - y(x_{i+1}) = \mathcal{O}(h^3)$，对比上面的两个式子，有如下结果</p><script type="math/tex; mode=display">\begin{cases}\lambda_1+\lambda_2 = 1 \\\displaystyle\lambda_2\alpha = \frac{1}{2} \\\displaystyle\frac{\beta}{\alpha} = 1\end{cases}</script><p>对于上述有四个未知数、三个方程的不定方程，其解不唯一。选取最简单的解即可。</p><h3 id="四阶龙格库塔算法"><a href="#四阶龙格库塔算法" class="headerlink" title="四阶龙格库塔算法"></a>四阶龙格库塔算法</h3><p>为了提高计算精度，在区间$[x_i,x_{i+1}]$上选取更多的点：尝试选取四个点，会得到四阶龙格库塔算法：</p><script type="math/tex; mode=display">\begin{cases}y_{i+1} &= y_i + h(\lambda_1k_1 + \lambda_2k_2 + \lambda_3k_3 + \lambda_4k_4) \\k_1 &= f(x_i,y_i) \\k_2 &= f(x_i + \alpha_1h, y_i + \beta_1hk_1) \\k_3 &= f(x_i + \alpha_2h,y_i + \beta_2hk_1 + \beta_3hk_2) \\k_4 &= f(x_i + \alpha_3h, y_i + \beta_4hk_1 + \beta_5hk_2 + \beta_6hk_3)\end{cases}</script><p>待定参数$\lambda_m,\alpha_m,\beta_m$的推导过程与上述二阶龙格库塔算法推导过程类似，计算更复杂。取一组较简单的解，得</p><script type="math/tex; mode=display">\begin{aligned}y_{i+1} &= \frac{h}{6}(k_1+2k_2+2k_3+k_4) \\k_1 &= f(x_i, y_i) \\k_2 &= f(x_i+\frac{h}{2},y_i+\frac{hk_1}{2}) \\k_3 &= f(x_i+\frac{h}{2},y_i+\frac{hk_2}{2}) \\k_4 &= f(x_i+h, y_i+hk_3)\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 基础数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表-张量-数组互相转化</title>
      <link href="/mid-lake-pavilion.github.io/2023/10/04/%E5%88%97%E8%A1%A8-%E5%BC%A0%E9%87%8F-%E6%95%B0%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/"/>
      <url>/mid-lake-pavilion.github.io/2023/10/04/%E5%88%97%E8%A1%A8-%E5%BC%A0%E9%87%8F-%E6%95%B0%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在手写深度学习神经网络模型过程中，经常面临三种数据类型的互相转化，分别是</p><ul><li>list，列表类型</li><li>numpy.ndarray，numpy数组类型</li><li>torch.tensor，pytorch张量类型</li></ul><h2 id="list转numpy-ndarray"><a href="#list转numpy-ndarray" class="headerlink" title="list转numpy.ndarray"></a>list转numpy.ndarray</h2><p>直接调用<code>numpy.array(li: list)</code>即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;list&#39;&gt; [1, 2, 3, 4, 5]&lt;class &#39;numpy.ndarray&#39;&gt; [1 2 3 4 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="numpy-ndarray转list"><a href="#numpy-ndarray转list" class="headerlink" title="numpy.ndarray转list"></a>numpy.ndarray转list</h2><p>直接调用<code>numpy.ndarray.tolist()</code>即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>b <span class="token operator">=</span> a<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;numpy.ndarray&#39;&gt; [[0.69879659 0.60573637] [0.68410898 0.67192278]]&lt;class &#39;list&#39;&gt; [[0.6987965864743525, 0.6057363669169245], [0.6841089820778812, 0.6719227772659302]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="numpy-ndarray转tensor"><a href="#numpy-ndarray转tensor" class="headerlink" title="numpy.ndarray转tensor"></a>numpy.ndarray转tensor</h2><p>直接调用<code>torch.tensor(array: numpy.ndarray)</code>即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>b <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;numpy.ndarray&#39;&gt; [[0.03954173 0.76079466] [0.85906081 0.23727305]]&lt;class &#39;torch.Tensor&#39;&gt; tensor([[0.0395, 0.7608],        [0.8591, 0.2373]], dtype&#x3D;torch.float64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="tensor转numpy-ndarray"><a href="#tensor转numpy-ndarray" class="headerlink" title="tensor转numpy.ndarray"></a>tensor转numpy.ndarray</h2><p>直接调用<code>tensor.numpy()</code>即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> a<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;torch.Tensor&#39;&gt; tensor([[0.1232, 0.1971], [0.1195, 0.9030]])&lt;class &#39;numpy.ndarray&#39;&gt; [[0.12315023 0.19711488] [0.11953574 0.90298206]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="list转torch-tensor"><a href="#list转torch-tensor" class="headerlink" title="list转torch.tensor"></a>list转torch.tensor</h2><p>直接调用<code>torch.tensor(li: list)</code>即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>b <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;list&#39;&gt; [1, 2, 3, 4, 5]&lt;class &#39;torch.Tensor&#39;&gt; tensor([1, 2, 3, 4, 5])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="torch-tensor转list"><a href="#torch-tensor转list" class="headerlink" title="torch.tensor转list"></a>torch.tensor转list</h2><p>这里需要先将tensor转化为numpy.ndarray，然后再转化为list。即调用<code>tensor.numpy().tolist()</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> a<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;torch.Tensor&#39;&gt; tensor([[0.3756, 0.4187], [0.1329, 0.6424]])&lt;class &#39;list&#39;&gt; [[0.3756064176559448, 0.418671190738678], [0.13289010524749756, 0.6423724889755249]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Attention Networks论文笔记</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/24/Graph-Attention-Networks%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/24/Graph-Attention-Networks%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>我们来看看论文中的<strong>图注意力机制</strong>。对于图$\mathcal{G}(V,E)$，图中结点数量为$N=|V|$。我们把所有结点的特征向量存入集合，记作</p><script type="math/tex; mode=display">\mathbf{h}=\{ \vec{h}_1, \vec{h}_2, \dots, \vec{h}_N \}</script><p>而每一个结点特征维度为$F$，因此$\forall i \in \{1,2,\dots, N\}, \vec{h}_i \in \mathbb{R}^F$。</p><ol><li><p>将特征映射到高层特征，因此需要在最开始加入一个线性变换。对第$i$个结点的特征向量$\vec{h}_i$，施加一个矩阵$\mathbf{W}\in \mathbb{R}^{F’\times F}$（<strong>所有结点共享</strong>），做矩阵乘法</p><script type="math/tex; mode=display">\mathbf{W}\vec{h}_i \in \mathbb{R}^{F'}</script></li><li><p>计算自注意力，引入映射$a:\mathbb{R}^{F’} \times \mathbb{R}^{F’} \to \mathbb{R}$（<strong>权值共享</strong>）。比如，第$j$个结点对于第$i$个结点的重要度（关注度）就是</p><script type="math/tex; mode=display">e_{ij} = a(\mathbf{W}\vec{h}_i, \mathbf{W}\vec{h}_j)</script><p><strong>在图注意力机制中，对于第$i$个结点，我们仅仅计算那些与之邻接的结点对于其的重要度</strong>。</p></li><li><p>归一化注意力值。记与结点$i$邻接的结点集合为$\mathcal{N}_i$，则注意力系数</p><script type="math/tex; mode=display">\alpha_{ij} = \mathrm{softmax}_j(e_{ij}) = \frac{\exp(e_{ij})}{\displaystyle \sum_{k \in \mathcal{N}_i}\exp(e_{ik})}</script></li><li><p>计算最终输出的新特征向量</p><script type="math/tex; mode=display">\vec{h}_i' = \sigma\left( \sum_{j\in\mathcal{N}_i}\alpha_{ij}\mathbf{W}\vec{h}_j \right)</script></li></ol><p>论文中接下来指出了$a$具体是什么：<strong>实验中$a$其实就是一个简单的前馈神经网络层，并接上激活函数LeakyReLU</strong>。具体描述如下</p><script type="math/tex; mode=display">\begin{aligned} e_{ij} &= a(\mathbf{W}\vec{h}_i, \mathbf{W}\vec{h}_j) \\ &= \mathrm{LeakyReLU}\left( \mathbf{a}^T\left[ \begin{matrix} \mathbf{W}\vec{h}_i \\ \mathbf{W}\vec{h}_j \end{matrix} \right] \right) \end{aligned}</script><p>其中$\mathbf{a}\in \mathbb{R}^{2F’}$；由上文可知，$\mathbf{W}\vec{h}_i, \mathbf{W}\vec{h}_j \in \mathbb{R}^{F’}$，而我们将它们竖向拼接起来（以下用||简记）。</p><p>至此，将注意力系数的完整计算过程表示为</p><script type="math/tex; mode=display">\alpha_{ij} = \frac{\exp(\mathrm{LeakyReLU}\left( \mathbf{a}^T[\mathbf{W}\vec{h}_i || \mathbf{W}\vec{h}_j] \right))}{\displaystyle \sum_{k \in \mathcal{N}_i}\exp(\mathrm{LeakyReLU}\left( \mathbf{a}^T[\mathbf{W}\vec{h}_i || \mathbf{W}\vec{h}_k] \right))}</script><p>同样地，图注意力中也有<strong>多头注意力机制</strong>。设置有$K$个头，在上述第4步计算输出时，变为</p><script type="math/tex; mode=display">\vec{h}_i' = \Arrowvert_{k=1}^K \sigma\left( \sum_{j\in\mathcal{N}_i}\alpha_{ij}^k\mathbf{W}^k\vec{h}_j \right)</script><p>同样地，|| 表示拼接操作。显然，$\vec{h}_i’ \in \mathbb{R}^{KF’}$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>具体到代码实现图注意力时，我们将所有结点的特征向量存入矩阵$\mathbf{h}$，它便是注意力层的输入</p><script type="math/tex; mode=display">\mathbf{h} = \left[\begin{matrix} \vec{h}_1 \\ \vec{h}_2 \\ \dots \\ \vec{h}_N \end{matrix}\right] \in \mathbb{R}^{N\times F}</script><p>而经过矩阵乘法，$\mathbf{W}\in \mathbb{R}^{F\times F’}$，得</p><script type="math/tex; mode=display">\mathbf{hW} \in \mathbb{R}^{N\times F'}</script><p>而计算注意力值的映射中用到的线性变换矩阵为$\mathbf{a} \in \mathbb{R}^{2F’\times 1}$，分别计算</p><script type="math/tex; mode=display">\begin{aligned} (\mathbf{hW})\mathbf{a}_{:F',:} \in \mathbb{R}^{N\times 1} \\ (\mathbf{hW})\mathbf{a}_{F':,:} \in \mathbb{R}^{N\times 1} \end{aligned}</script><p>于是将计算注意力系数的过程转化为</p><script type="math/tex; mode=display">\mathbf{e} = \left[ \begin{matrix} e_{11} & e_{12} & \dots & e_{1N} \\ e_{21} & e_{22} & \dots & e_{2N} \\ \vdots & \vdots & \cdots & \vdots \\ e_{N1} & e_{N2} & \dots & e_{NN} \end{matrix} \right] = (\mathbf{hW})\mathbf{a}_{:F',:} + \left( (\mathbf{hW})\mathbf{a}_{F':,:} \right)^T</script><p>其中存在矩阵广播加法，正是巧妙用到了这个特性实现了这个计算注意力系数过程。</p><p>下面简单证明上述过程的正确性。</p><blockquote><p>为了方便表示，我们把上面出现过的一些矩阵式展开写明：</p><script type="math/tex; mode=display">\mathbf{hW} = \left[ \begin{matrix} \vec{h}_1 \\ \vec{h}_2 \\ \vdots \\ \vec{h}_N \end{matrix} \right]_{N\times F} \mathbf{W}_{F\times F'} = \left[ \begin{matrix} \vec{h}_1\mathbf{W} \\ \vec{h}_2\mathbf{W} \\ \vdots \\ \vec{h}_N\mathbf{W} \end{matrix} \right]_{N\times F'}</script><p>其中$\vec{h}_i, i\in \{1,2,\dots,N\}$是第$i$个结点的特征向量。</p><p>我们进而将矩阵$\mathbf{a}_{2F’\times1}$写为</p><script type="math/tex; mode=display">\mathbf{a}_{2F'\times 1} = [\mathbf{a}_{:F',:} \ \mathbf{a}_{F':,:}]</script><p>因此，</p><script type="math/tex; mode=display">(\mathbf{hW})\mathbf{a}_{:F',:} = \left[ \begin{matrix} \vec{h}_1\mathbf{W} \\ \vec{h}_2\mathbf{W} \\ \vdots \\ \vec{h}_N\mathbf{W} \end{matrix} \right]_{N\times F'} [\mathbf{a}_{:F',:}]_{F'\times1} = \left[ \begin{matrix} \vec{h}_1\mathbf{W}\mathbf{a}_{:F',:} \\ \vec{h}_2\mathbf{W}\mathbf{a}_{:F',:} \\ \vdots \\ \vec{h}_N\mathbf{W}\mathbf{a}_{:F',:} \end{matrix} \right]</script><p>而</p><script type="math/tex; mode=display">((\mathbf{hW})\mathbf{a}_{F':,:})^T = \left[ \begin{matrix} \vec{h}_1\mathbf{W}\mathbf{a}_{F':,:} & \vec{h}_2\mathbf{W}\mathbf{a}_{F':,:} & \dots & \vec{h}_N\mathbf{W}\mathbf{a}_{F':,:} \end{matrix} \right]</script><p>故有</p><script type="math/tex; mode=display">\begin{aligned} \mathbf{e} &= (\mathbf{hW})\mathbf{a}_{:F',:} + \left( (\mathbf{hW})\mathbf{a}_{F':,:} \right)^T \\ &= \left[ \begin{matrix} \vec{h}_1\mathbf{W}\mathbf{a}_{:F',:} \\ \vec{h}_2\mathbf{W}\mathbf{a}_{:F',:} \\ \vdots \\ \vec{h}_N\mathbf{W}\mathbf{a}_{:F',:} \end{matrix} \right] + \left[ \begin{matrix} \vec{h}_1\mathbf{W}\mathbf{a}_{F':,:} & \vec{h}_2\mathbf{W}\mathbf{a}_{F':,:} & \dots & \vec{h}_N\mathbf{W}\mathbf{a}_{F':,:} \end{matrix} \right] \\ &= \left[ \begin{matrix} \vec{h}_1\mathbf{Wa}_{:F',:} + \vec{h}_1\mathbf{Wa}_{F':,:} & \vec{h}_1\mathbf{Wa}_{:F',:} + \vec{h}_2\mathbf{Wa}_{F':,:} & \dots & \vec{h}_1\mathbf{Wa}_{:F',:} + \vec{h}_N\mathbf{Wa}_{F':,:} \\ \vec{h}_2\mathbf{Wa}_{:F',:} + \vec{h}_1\mathbf{Wa}_{F':,:} & \vec{h}_2\mathbf{Wa}_{:F',:} + \vec{h}_2\mathbf{Wa}_{F':,:} & \dots & \vec{h}_2\mathbf{Wa}_{:F',:} + \vec{h}_N\mathbf{Wa}_{F':,:} \\ \vdots & \vdots & \vdots & \vdots \\ \vec{h}_N\mathbf{Wa}_{:F',:} + \vec{h}_1\mathbf{Wa}_{F':,:} & \vec{h}_N\mathbf{Wa}_{:F',:} + \vec{h}_2\mathbf{Wa}_{F':,:} & \dots & \vec{h}_N\mathbf{Wa}_{:F',:} + \vec{h}_N\mathbf{Wa}_{F':,:} \end{matrix} \right] \end{aligned}</script><p>故第$j$个结点对于第$i$个结点的关键度为</p><script type="math/tex; mode=display">e_{ij} = \vec{h}_i\mathbf{Wa}_{:F',:}+\vec{h}_j\mathbf{Wa}_{F':,:} = \left[\begin{matrix} \vec{h}_i\mathbf{W} & \vec{h}_j\mathbf{W} \end{matrix}\right] \left[ \begin{matrix} \mathbf{a}_{:F',:} \\ \mathbf{a}_{F':,:} \end{matrix} \right] = \left[\begin{matrix} \vec{h}_i\mathbf{W} & \vec{h}_j\mathbf{W} \end{matrix}\right] \mathbf{a}</script></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">GraphAttentionLayer</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Simple GAT layer, similar to https://arxiv.org/abs/1710.10903    in_features: 结点原始特征向量维度    out_features: 经过映射后的特征向量维度    concat: 默认为True，表示将特征向量进行拼接    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> in_features<span class="token punctuation">,</span> out_features<span class="token punctuation">,</span> dropout<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> concat<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>GraphAttentionLayer<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> dropout        self<span class="token punctuation">.</span>in_features <span class="token operator">=</span> in_features        self<span class="token punctuation">.</span>out_features <span class="token operator">=</span> out_features        self<span class="token punctuation">.</span>alpha <span class="token operator">=</span> alpha        self<span class="token punctuation">.</span>concat <span class="token operator">=</span> concat        self<span class="token punctuation">.</span>W <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>in_features<span class="token punctuation">,</span> out_features<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W<span class="token punctuation">.</span>data<span class="token punctuation">,</span> gain<span class="token operator">=</span><span class="token number">1.414</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>a <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>out_features<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">.</span>data<span class="token punctuation">,</span> gain<span class="token operator">=</span><span class="token number">1.414</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>leakyrelu <span class="token operator">=</span> nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span>self<span class="token punctuation">.</span>alpha<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> h<span class="token punctuation">,</span> adj<span class="token punctuation">)</span><span class="token punctuation">:</span>        Wh <span class="token operator">=</span> torch<span class="token punctuation">.</span>mm<span class="token punctuation">(</span>h<span class="token punctuation">,</span> self<span class="token punctuation">.</span>W<span class="token punctuation">)</span> <span class="token comment"># h.shape: (N, in_features), Wh.shape: (N, out_features)</span>        e <span class="token operator">=</span> self<span class="token punctuation">.</span>_prepare_attentional_mechanism_input<span class="token punctuation">(</span>Wh<span class="token punctuation">)</span>        zero_vec <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9e15</span><span class="token operator">*</span>torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>e<span class="token punctuation">)</span>        attention <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>adj <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> zero_vec<span class="token punctuation">)</span>        attention <span class="token operator">=</span> F<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>attention<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        attention <span class="token operator">=</span> F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>attention<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span>        h_prime <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>attention<span class="token punctuation">,</span> Wh<span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>concat<span class="token punctuation">:</span>            <span class="token keyword">return</span> F<span class="token punctuation">.</span>elu<span class="token punctuation">(</span>h_prime<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> h_prime    <span class="token keyword">def</span> <span class="token function">_prepare_attentional_mechanism_input</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> Wh<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># Wh.shape (N, out_feature)</span>        <span class="token comment"># self.a.shape (2 * out_feature, 1)</span>        <span class="token comment"># Wh1&amp;2.shape (N, 1)</span>        <span class="token comment"># e.shape (N, N)</span>        Wh1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>Wh<span class="token punctuation">,</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>out_features<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        Wh2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>Wh<span class="token punctuation">,</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>self<span class="token punctuation">.</span>out_features<span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># broadcast add</span>        e <span class="token operator">=</span> Wh1 <span class="token operator">+</span> Wh2<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>leakyrelu<span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">' ('</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>in_features<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' -> '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>out_features<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图神经网络 </tag>
            
            <tag> 图注意力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程访问校内内网服务器</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/21/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%A0%A1%E5%86%85%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/21/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%A0%A1%E5%86%85%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>因学习、开发需要，需要通过访问学校实验室的服务器（校园网内网服务器）。但是我目前不在学校，自然无法直接通过校园网访问服务器了。因此查阅互联网，找到一种基于内网穿透的远程访问解决方案。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>总的来说，我们<strong>还需要一台服务器做中转服务器</strong>，通过这台服务器跳转访问校内内网服务器。</p><ul><li>中转服务器视作服务端（server）</li><li>内网服务器视作客户端（client）</li></ul><h3 id="租赁中转服务器"><a href="#租赁中转服务器" class="headerlink" title="租赁中转服务器"></a>租赁中转服务器</h3><p>第一步，我们需要租一台中转服务器。这台服务器只需要运行一个后台程序即可，配置无所谓。这里推荐阿里云飞天计划免费租赁服务器三个月的活动（只有新账户才能试用一次）。</p><h3 id="下载反向代理应用frp"><a href="#下载反向代理应用frp" class="headerlink" title="下载反向代理应用frp"></a>下载反向代理应用frp</h3><p>frp是用于内网穿透的反向代理应用，非常有效、方便。下载地址为<a href="https://github.com/fatedier/frp/releases。">https://github.com/fatedier/frp/releases。</a></p><p>我这里下载的是frp_0.49.0_linux_amd64版本。下载到本地后解压缩，得到一系列配置文件。</p><h3 id="配置中转服务器"><a href="#配置中转服务器" class="headerlink" title="配置中转服务器"></a>配置中转服务器</h3><p><strong>将frps以及frps.ini放到该中转服务器上，运行<code>nohup ./frps -c ./frps.ini &amp;</code></strong>。frps.ini文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 7000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>nohup表示将该进程一直在后台运行。注意文件目录关系，frps和frps.ini在同级目录下，且在该目录下运行该命令。</p></blockquote><p><strong>运行完毕命令后，这个进程就在7000端口运行了。还需要到服务器的配置界面，开放7000端口（放行），不然后续操作会失败</strong>。</p><h3 id="配置内网服务器"><a href="#配置内网服务器" class="headerlink" title="配置内网服务器"></a>配置内网服务器</h3><p><strong>将frpc以及frpc.ini放到内网服务器上，运行<code>nohup ./frpc -c ./frpc.ini &amp;</code></strong>。注意，frpc.ini文件内容修改如下：</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr &#x3D; &#123;你的中转服务器公网IP地址&#125;server_port &#x3D; 7000 # 就是上面frps.ini中的bind_port[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000 # 这里设置为6000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>按照上面的步骤操作完成后，便可以远程访问校内内网服务器。介绍两种方法，个人常使用第二种，非常方便。</p><p>第一种，直接使用ssh命令远程登录：<code>ssh -oPort=6000 [&#123;你的中转服务器的用户名&#125;@&#123;你的中转服务器的公网IP地址&#125;]</code></p><p>第二种，下载远程登录工具MobaXterm（<a href="https://mobaxterm.mobatek.net/download.html），打开软件：">https://mobaxterm.mobatek.net/download.html），打开软件：</a></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230921085111238.png" alt="MobaXterm远程登录界面"></p><p>一定要注意，这里<strong>要输入你的中转服务器的公网IP地址，而不是校内服务器内网地址</strong>。点击“OK”之后，输入你的中转服务器用户名以及登录密码，便可以进入内网服务器了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>内网穿透-在家访问校园服务器：<a href="https://zhuanlan.zhihu.com/p/54850634">https://zhuanlan.zhihu.com/p/54850634</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Convolutional Networks for Text Classification论文笔记</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/20/Graph-Convolutional-Networks-for-Text-Classification%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/20/Graph-Convolutional-Networks-for-Text-Classification%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇论文介绍了一种新的针对文本分类的解决方案：图卷积神经网络。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>构建图的过程是重点，这也正是本论文和其他图卷积与众不同之处。首先需要明确论文构建了一个<strong>文本图（text graph）</strong>，它是异质图，有两种结点：词结点和文档结点。和图论中的类似，我们把这个异质图记作$\mathcal{G}=(V,E)$。</p><h3 id="图的构建"><a href="#图的构建" class="headerlink" title="图的构建"></a>图的构建</h3><p>根据论文中的描述，文本图的构建过程如下。</p><ul><li>对于图中的结点，有两种：词结点和文档结点<ul><li>词结点，每一个在语料库中出现过的词组成一个词结点（不重复）</li><li>文档结点：每一篇文档组成一个文档结点</li></ul></li><li>对于图中的边，也有两种：词-词边和词-文档边<ul><li>词-词边：连接两个词结点的边，权重由<strong>逐点乘（PMI）</strong>计算得到</li><li>词-文档边：连接词结点和文档结点的边，权重由该词在该文档中的<strong>词频-逆文档频率（TF-IDF）</strong>计算得到</li></ul></li></ul><p>接下来的计算公式来自原论文。论文将边的权重矩阵记作$A \in \mathbb{R}^{|V|\times |V|}$，则结点$i$和结点$j$之间的边权重为</p><script type="math/tex; mode=display">A_{ij} = \begin{cases} \mathrm{PMI}(i,j) \ & i,j \ \mathrm{are \ words}, \mathrm{PMI}(i,j)>0 \\ \mathrm{TF-IDF}_{ij} & i \ \mathrm{is \ document}, j \ \mathrm{is \ word} \\ 1 & i=j \\ 0 & \mathrm{otherwise} \end{cases}</script><p>而$\mathrm{PMI}$的计算公式为</p><script type="math/tex; mode=display">\begin{aligned} \mathrm{PMI}(i,j) &= \log \frac{p(i,j)}{p(i)p(j)} \\ p(i,j) &= \frac{\#W(i,j)}{\#W} \\ p(i) &= \frac{\#W(i)}{\#W} \end{aligned}</script><ul><li>$#W(i)$为语料库上所有滑动窗口中包含词条$t_i$的滑动窗口数量</li><li>$#W(i,j)$为语料库上所有滑动窗口中同时包含词条$t_i,t_j$的滑动窗口数量</li><li>$#W$为语料库上全部滑动窗口的数量</li></ul><blockquote><p>$\mathrm{PMI}$值为正时，表示两个词条具有较强的相关性；反之则几乎没有相关性。因此只考虑正的$\mathrm{PMI}$的边，否则将其权值置零。</p></blockquote><p>而$\mathrm{TF-IDF}$的计算方法是，对于文档$d_i$、词$t_j$，有如下两个重要计算公式：</p><ul><li><p>词频（Term Frequency，TF）</p><script type="math/tex; mode=display">\mathrm{TF}_{ij} = \frac{n_{ij}}{\displaystyle \sum_{k}n_{ik}}</script><p>其中$n_{ij}$表示词$t_j$在文档$d_i$中出现的次数（频数）。</p></li><li><p>逆文档频率（Inverse Document Frequency，IDF）</p><script type="math/tex; mode=display">\mathrm{IDF}_i = \log\frac{|D|}{1+|\{ i | t_j \in d_i \}|}</script><p>其中$D=\{ d_1, d_2, \dots \}$表示文档的集合，$|\{ i | t_j \in d_i \}|$则表示包含了词条$t_j$的文档数量</p></li></ul><p>综上，$\mathrm{TF-IDF}$计算公式为</p><script type="math/tex; mode=display">\mathrm{TF-IDF}_{ij} = \mathrm{TF}_{ij} \times \mathrm{IDF}_i</script><h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><p>我们将$\mathcal{G}=(V,E)$送入图卷积网络。设词嵌入的维度为$m$，结点数量$n=|V|$，则结点嵌入矩阵为$X \in \mathbb{R}^{n\times m}$，而对角矩阵$D \in \mathbb{R}^{n\times n}$，其中$\displaystyle D_{ii} = \sum_jA_{ij}$，进而将邻接矩阵$A \in \mathbb{R}^{n\times n}$标准化得到标准化对称邻接矩阵</p><script type="math/tex; mode=display">\hat{A} = D^{-\frac{1}{2}}AD^{\frac{1}{2}}</script><p>另外记权重矩阵为$W\in \mathbb{R}^{m\times k}$，则第$j$层图卷积表示为</p><script type="math/tex; mode=display">L^{(j+1)} = \rho(\hat{A}L^{(j)}W_j)</script><p>其中，$\rho$是激活函数。特殊地，$L^{(0)} = X$。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>具体到论文中，论文构建了两层图卷积网络；在图卷积之后，softmax层被接入，整个模型的输出为</p><script type="math/tex; mode=display">Z = \mathrm{softmax}(\hat{A}·\mathrm{ReLU}(\hat{A}XW_0)W_1)</script><p>损失函数选取的是交叉熵，即</p><script type="math/tex; mode=display">\mathcal{L} = -\sum_{d\in \mathcal{Y}_D}\sum_{f=1}^FY_{df}\ln Z_{df}</script><p>其中$\mathcal{Y}_D$为文档索引的集合，$F$为类别总数。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>TF-IDF：<a href="https://zhuanlan.zhihu.com/p/97273457">https://zhuanlan.zhihu.com/p/97273457</a></p><p>对称邻接矩阵：<a href="https://www.zhihu.com/question/426784258">https://www.zhihu.com/question/426784258</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图神经网络 </tag>
            
            <tag> 图卷积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213.打家劫舍Ⅱ</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/17/213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/17/213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,2,3]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>我们之前在解决“打家劫舍”问题时，是没有考虑到第一间房屋和最后一间房屋连通的情况的。根据动态规划思想，我们得到如下的状态转移方程</p><script type="math/tex; mode=display">dp[i] = \begin{cases} nums[0], \ & i=0 \\ \max\{ nums[0],nums[1] \}, &i=1 \\ \max\{ dp[i-2]+nums[i], dp[i-1] \}, & i\geqslant 2 \end{cases}</script><p>其中$dp[i]$表示在$nums[0:i]$中可以偷取到的最大金额。</p><p>而如今，需要特别考虑首尾相连的问题。我们仍然记房屋存放金额数组为$nums[]$，其长度为$n$，那么也就是说</p><ul><li>如果选择偷取最后一间房屋，那么就不可以偷取第一间房屋，则考虑的偷取范围为$[1,n-1]$</li><li>如果选择不偷取最后一间房屋，那么便可以偷取第一间房屋，则考虑的偷取范围为$[0,n-2]$</li></ul><p><strong>因此，针对上面的两种情况，我们其实可以分别按照“打家劫舍”中的解题思路算法运行一遍，然后取最大值即为最后的答案了</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int DP(vector&lt;int&gt;&amp; nums, int start, int end) &#123;        &#x2F;&#x2F; [start, end]        if(start &#x3D;&#x3D; end)    return nums[start];        int dp[105];        memset(dp, 0, sizeof(dp));        int i;        dp[start] &#x3D; nums[start], dp[start+1] &#x3D; max(nums[start], nums[start+1]);        int ans &#x3D; max(dp[start], dp[start+1]);        for(i&#x3D;start+2; i&lt;&#x3D;end; i++) &#123;            dp[i] &#x3D; max(dp[i-2]+nums[i], dp[i-1]);            ans &#x3D; max(ans, dp[i]);        &#125;        return ans;    &#125;    int rob(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if(n &#x3D;&#x3D; 1)  return nums[0];        int ans1 &#x3D; DP(nums, 1, n-1);        int ans2 &#x3D; DP(nums, 0, n-2);        return max(ans1, ans2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198.打家劫舍</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/16/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/16/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/house-robber/?envType=daily-question&amp;envId=2023-09-16">https://leetcode.cn/problems/house-robber/?envType=daily-question&amp;envId=2023-09-16</a></p></blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>不妨尝试按照经典的动态规划解题方法思考一下：设置一个$dp$数组，$dp[i]$表示在偷取$nums[i]$前提下，能够偷取到的最大金额。那么如何进行状态转移呢？也就是说，在已知$dp[0],dp[1],\cdots,dp[i-1]$时，如何求出$dp[i]$？我们知道的是，任何两间相邻的屋子不能够同时失窃，因此上一个被偷取的屋子编号只可能是$0,1,\dots,i-2$，而究竟是哪一个，则取决于该范围内数组$dp$中的最大者。</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>初始情况需要额外考虑，即考虑$dp[0],dp[1]$，这两种情况也很简单，仅偷取对应的屋子即可，即</p><script type="math/tex; mode=display">dp[0] = nums[0], dp[1] = nums[1]</script><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>综上，状态转移方程为</p><script type="math/tex; mode=display">dp[i] = \begin{cases} nums[0], \ & i=0 \\ nums[1], &i = 1 \\ \displaystyle nums[i] + \max_k dp[k],0\leqslant k \leqslant i-2, &i \geqslant 2 \end{cases}</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if(n &#x3D;&#x3D; 1)  return nums[n-1];        int dp[1005];        memset(dp, 0, sizeof(dp));        int i, j;        dp[0] &#x3D; nums[0];        dp[1] &#x3D; nums[1];        int ans &#x3D; max(dp[0], dp[1]);        for(i&#x3D;2; i&lt;n; i++) &#123;            for(j&#x3D;0; j&lt;i-1; j++) &#123;                dp[i] &#x3D; max(dp[i], dp[j] + nums[i]);            &#125;            ans &#x3D; max(ans, dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="另解"><a href="#另解" class="headerlink" title="另解"></a>另解</h2><p>上面的动态规划思路可以求出偷取的房间编号，只需额外设置一个存储上一个偷取的房间编号的数组即可。接下来介绍另一种时间复杂度更低的动态规划思路，但是它不能求出具体的偷取的房间。</p><p>我们用$dp[i]$表示在$nums[0:i]$中可以偷取到的最大金额。那么，在考虑第$i$间房屋时，有两个选项：</p><ul><li>偷取$nums[i]$，这样的话$nums[i-1]$不能偷取，于是$dp[i]=dp[i-2]+nums[i]$；</li><li>不偷取$nums[i]$，这样的话，可以考虑偷取$nums[i-1]$，于是$dp[i]=dp[i-1]$；</li></ul><p>于是状态转移方程即为</p><script type="math/tex; mode=display">dp[i] = \begin{cases} nums[0], \ & i=0 \\ \max\{ nums[0],nums[1] \}, &i=1 \\ \max\{ dp[i-2]+nums[i], dp[i-1] \}, & i\geqslant 2 \end{cases}</script><p>显然，这个算法的时间复杂度为$\mathcal{O}(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32.最长有效括号</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/14/32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/14/32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/longest-valid-parentheses/">https://leetcode.cn/problems/longest-valid-parentheses/</a></p></blockquote><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;)()())&quot;输出：4解释：最长有效括号子串是 &quot;()()&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;&quot;输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>由于同样是字符串处理问题，我们先考虑动态规划：设置$dp$数组，其中$dp[i]$表示以$s[i]$结尾的最长有效子串长度。显然，当$s[i]=’(‘$时，$dp[i]=0$。接下来考虑$s[i]=’)’$的情况。为了方便后续讨论，记$dp[i-1]=l_{i-1}$。</p><ul><li>若$s[i-1]=’(‘$，则$s[i-1:i]=()$，它们已经有效，因此只需考虑以$s[i-2]$结尾的最长有效子串，拼接起来即可，即$dp[i]=dp[i-2]+2$；</li><li>若$s[i-1]=’)’$，则子串$s[i-l_{i-1}:i-1]$一定就是以$s[i-1]$结尾的最长有效子串，那么加上$s[i]=’)’$会怎么样呢？此时需要考虑$s[i-l_{i-1}-1]$了。<ul><li><strong>若$s[i-l_{i-1}-1]=’(‘$，那么子串$s[i-l_{i-1}-1:i]$仍然有效</strong>，则只需考虑以$s[i-l_{i-1}-2]$结尾的最长有效子串，即$dp[i]=dp[i-l_{i-1}-2]+l_{i-1}+2$；</li><li>若$s[i-l_{i-1}-1]=’)’$，那么必然不存在以$s[i]$结尾的非空子串，否则与“子串$s[i-l_{i-1}:i-1]$一定就是以$s[i-1]$结尾的最长有效子串”矛盾，故$dp[i]=0$。</li></ul></li></ul><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>综上所述，状态转移方程表述为</p><script type="math/tex; mode=display">dp[i] = \begin{cases} dp[i-2]+2, \ & \mathrm{if} \ s[i]=')' \ \mathrm{and}\ s[i-1]='(' \\ dp[i-dp[i-1]-2]+dp[i-1]+2, & \mathrm{if} \ s[i]=')'\ \mathrm{and} \ s[i-1]=')' \ \mathrm{and} \ s[i-dp[i-1]-1]='(' \\ 0, & \mathrm{otherwise} \end{cases}</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int dp[30005];    string S;    int DP(int i) &#123;        if(i &lt; 0)   return 0;        if(dp[i] !&#x3D; -1) return dp[i];        if(S[i] &#x3D;&#x3D; &#39;(&#39;) return dp[i] &#x3D; 0;        &#x2F;&#x2F; S[i] &#x3D;&#x3D; &#39;)&#39;        if(S[i-1] &#x3D;&#x3D; &#39;(&#39;) &#123;            return dp[i] &#x3D; DP(i-2) + 2;        &#125; else &#123;            &#x2F;&#x2F; ((()()))            int k &#x3D; DP(i-1);            if(dp[i] &#x3D; i-k-1 &gt;&#x3D; 0 &amp;&amp; S[i-k-1] &#x3D;&#x3D; &#39;(&#39;) &#123;                return dp[i] &#x3D; k + 2 + DP(i-k-2);            &#125; else  return dp[i] &#x3D; 0;        &#125;    &#125;    int longestValidParentheses(string s) &#123;        if(s.size() &#x3D;&#x3D; 0 || s.size() &#x3D;&#x3D; 1) return 0;        memset(dp, -1 ,sizeof(dp));        S &#x3D; s;        int i;        dp[0] &#x3D; 0;        if(s[0] &#x3D;&#x3D; &#39;(&#39; &amp;&amp; s[1] &#x3D;&#x3D; &#39;)&#39;)  dp[1] &#x3D; 2;        else    dp[1] &#x3D; 0;        int ans &#x3D; max(dp[0], dp[1]);        for(i&#x3D;2; i&lt;s.size(); i++) &#123;            dp[i] &#x3D; DP(i);            ans &#x3D; max(ans, dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22.括号生成</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/13/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/13/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h2 id="思路Ⅰ-：动态规划"><a href="#思路Ⅰ-：动态规划" class="headerlink" title="思路Ⅰ ：动态规划"></a>思路Ⅰ ：动态规划</h2><p>动态规划本质上就需要找到递推的规律。如果已经知道$i-1$对括号的有效括号式集，如何再添加一对括号得到$i$对括号的有效括号式集呢？</p><p>我们来看一个具体的例子。假设$i=2$，故有效括号式集为</p><script type="math/tex; mode=display">(()),()()</script><p>现在考虑在何处添加新的括号对，可以使得得到的括号式仍然有效。为了方便思考，字符串最左侧的字符一定是”(“，于是<strong>我们将该字符和与之对应的右括号”)”视为新增的括号对</strong>。那么<strong>两个括号之间的部分，以及右括号右部的部分必然也是有效的，且它们加起来的括号对数即为$i-1$</strong>。为了方便后续的讨论，我们把前者包含的括号对数记作$p$，后者包含的括号对数记作$q$，而由$x$个括号对组成的有效括号式集合记作$S(x)$，个数记作$|S(x)|$。</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>给定$i$个括号对，根据上面的分析，</p><script type="math/tex; mode=display">S(i)=\{ '('+\mathrm{x}+')'+\mathrm{y}|\mathrm{x}\in S(p),\mathrm{y}\in S(q),p+q=i-1,\forall p \in [0,i-1] \}</script><p>由$p+q=i$，则有效括号式数量满足</p><script type="math/tex; mode=display">|S(i)|=\sum_{p=0}^{i-1}\left(|S(p)|\times|S(i-1-p)|\right)</script><p>下面举一个具体的例子，仍然以上面的2对括号对为例，求解$S(3)$。注意，此时$S(0),S(1),S(2)$均已知。</p><script type="math/tex; mode=display">\begin{aligned} S(0)&=\{\} \\ S(1)&=\{ () \} \\ S(2)&=\{ (()),()() \} \end{aligned}</script><p>下面求解$S(3)$。我们用$[]$来表示、强调新增的括号对。</p><script type="math/tex; mode=display">\begin{aligned} & p=0,q=2,S(3)_{02} = \{ '('+\mathrm{x}+')'+\mathrm{y}|\mathrm{x}\in S(0),\mathrm{y}\in S(2) \} = \{ [](()),[]()() \} \\ &p=1,q=1,S(3)_{11} = \{ '('+\mathrm{x}+')'+\mathrm{y}|\mathrm{x}\in S(1),\mathrm{y}\in S(1) \} = \{ [()]() \} \\ & p=2,q=0,S(3)_{20} = \{ '('+\mathrm{x}+')'+\mathrm{y}|\mathrm{x}\in S(2),\mathrm{y}\in S(0) \} = \{ [(())], [()()] \} \end{aligned}</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; dp[10];        dp[0] &#x3D; &#123;&quot;&quot;&#125;, dp[1] &#x3D; &#123;&quot;()&quot;&#125;;        int i, j;        for(i&#x3D;2; i&lt;&#x3D;n; i++) &#123;            for(j&#x3D;0; j&lt;i; j++) &#123;                &#x2F;&#x2F; dp[j], dp[i-1-j]                for(string x:dp[j]) &#123;                    for(string y:dp[i-1-j]) &#123;                        dp[i].push_back(&quot;(&quot;+x+&quot;)&quot;+y);                    &#125;                &#125;            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路Ⅱ：回溯"><a href="#思路Ⅱ：回溯" class="headerlink" title="思路Ⅱ：回溯"></a>思路Ⅱ：回溯</h2><p>回溯算法和深度优先遍历很类似，都需要沿着某一个方向一直搜索。<strong>和深度优先遍历不同的是，回溯算法在搜索到某个不可能出现的状态时，就会立即终止当前搜索，即剪枝操作</strong>。</p><p>此题中，我们用<strong>已经拼接出的字符串done、还剩下的左括号数量left和右括号数量right来表示一个状态</strong>；凡是不合法的括号式均为不可能出现的状态（即当left&gt;right），一旦搜索到该状态，便可以立即返回（剪枝）。但是我们可以调整一下搜索方式，便可以避免出现不合法状态：</p><ul><li>当left=right且不为零时，此时只能选择左括号”(“，于是还剩余的左括号left数量减一、右括号数量right不变，<code>DFS(done+&quot;(&quot;, left-1, right)</code>；</li><li>当left=0时，此时只能选择右括号”)”，于是还剩余的右括号right数量减一，左括号数量left不变，<code>DFS(done+&quot;)&quot;, left, right-1)</code>；</li><li>其余情况下，既可以选择左括号，也可以选择右括号<ul><li><code>DFS(done+&quot;(&quot;, left-1, right)</code></li><li><code>DFS(done+&quot;)&quot;, left, right-1)</code></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-%E6%90%9C%E7%B4%A2%E6%A0%91.svg" alt="括号生成-搜索树"></p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>很显然，当left=right=0时，此时搜索到终止状态，将字符串done添加到集合之中即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    set&lt;string&gt; S;    void DFS(string done, int left, int right) &#123;        if(left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0) &#123;            S.insert(done);            return;        &#125;        if(left &#x3D;&#x3D; 0)   DFS(done+&quot;)&quot;, left, right-1);        else if(left &#x3D;&#x3D; right) &#123;            DFS(done+&quot;(&quot;, left-1, right);        &#125; else &#123;            DFS(done+&quot;(&quot;, left-1, right);            DFS(done+&quot;)&quot;, left, right-1);        &#125;    &#125;    vector&lt;string&gt; generateParenthesis(int n) &#123;        DFS(&quot;&quot;, n, n);        vector&lt;string&gt; vs;        for(set&lt;string&gt;::iterator iter &#x3D; S.begin(); iter !&#x3D; S.end(); iter++) &#123;            vs.push_back(*iter);        &#125;        return vs;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.电话号码的字母组合</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/13/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/13/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></p></blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/200px-telephone-keypad2svg.png" alt="电话按键示意图"></p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; &quot;&quot;输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如何找到全部的字母组合呢？其实很明显此题可以使用深度优先遍历（DFS）。我们可以将字母组合看做不同的状态，<strong>用当前选取到的数字在字符串digits中的索引todo和已经组合出来的字符串done来表示一个状态</strong>；接下来考虑如何进行状态的搜索<code>DFS(string done, int todo, string digits)</code>。</p><p>为了方便编程，建立数字字符到字母字符的哈希映射表mps，对于当前需要考虑的数字$digits[todo]$，它对应的字符集为$mps[digits[todo]]$；遍历其中的每一个字符ch，将其加入已经组合出来的字符串done中，且将todo加一，即可得到新的状态：<code>DFS(done+ch, todo+1, digits)</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2%E6%A0%91.svg" alt="深度优先遍历搜索树"></p><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>进行深度优先搜索时，必须给出明确的边界条件，它正是搜索到的终止状态。搜索到这个状态时，便可以结束当前的搜索路径，而在程序运行中表现为递归结束，返回上一层函数。</p><p>显然，</p><ul><li>当索引todo=n（n为digits长度）时，搜索到终止状态，搜索结束，将当前组合出来的字符串done加入向量保存下来。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    map&lt;char, string&gt; mps &#x3D; &#123;        &#123;&#39;2&#39;, &quot;abc&quot;&#125;, &#123;&#39;3&#39;, &quot;def&quot;&#125;, &#123;&#39;4&#39;, &quot;ghi&quot;&#125;, &#123;&#39;5&#39;, &quot;jkl&quot;&#125;, &#123;&#39;6&#39;, &quot;mno&quot;&#125;, &#123;&#39;7&#39;, &quot;pqrs&quot;&#125;, &#123;&#39;8&#39;, &quot;tuv&quot;&#125;, &#123;&#39;9&#39;, &quot;wxyz&quot;&#125;    &#125;;    vector&lt;string&gt; res;    void DFS(string done, int todo, string digits) &#123;        if(todo &#x3D;&#x3D; digits.size()) &#123;            res.push_back(done);            return;        &#125;        string str &#x3D; mps[digits[todo]];        for(char ch:str) &#123;            DFS(done+ch, todo+1, digits);        &#125;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if(digits &#x3D;&#x3D; &quot;&quot;)    return res;        string temp &#x3D; &quot;&quot;;        DFS(temp, 0, digits);        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>设对应三个字母的数字字符个数为$m$，对应四个字母的数字字符个数为$n$，因为要穷举并存储搜索全部的状态（即字母组合），所以根据排列组合知识，时间复杂度和空间复杂度均为为$\mathcal{O}(3^m\times 4^n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.盛最多水的容器</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/13/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/13/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></p></blockquote><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code>。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/question_11.jpg" alt="盛水最多的容器示意图"></p><pre class="line-numbers language-none"><code class="language-none">输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：height &#x3D; [1,1]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要取到最大量的水，显然需要考虑两个因素：高度和垂线间隔。而高度就是两条垂线的较小值。因此我们设置双指针：头指针指向首部，尾指针指向尾部。那么如何移动指针呢？或者说，该移动哪一个指针？<strong>我们当然希望指针指向的垂线高度尽可能地高</strong>，因此我们将两个指针中所指向垂线高度较底者往右移动一位即可，这样才可能增大垂线高度。</p><p>比如上面的例子<code>[1,8,6,2,5,4,8,3,7]</code>中，头指针l=0，尾指针r=8，计算水量$V=\min\{ height[l],height[r] \}\times (r-l)=8$</p><ul><li>此时$height[l]&lt;height[r]$，因此右移头指针l=1，r=8，水量$V=\min\{ height[l],height[r] \}\times (r-l)=49$</li><li>此时$height[l]&gt;height[r]$，因此左移尾指针r=7，l=1，水量$V=\min\{ height[l],height[r] \}\times (r-l)=18$</li><li>此时$height[l]&gt;height[r]$，因此左移尾指针r=6，l=1，水量$V=\min\{ height[l],height[r] \}\times (r-l)=40$</li><li>此时$height[l]=height[r]$，不妨右移头指针l=2，r=6，水量$V=\min\{ height[l],height[r] \}\times (r-l)=24$</li><li>此时$height[l]&lt;height[r]$，因此右移头指针l=3，r=6，水量$V=\min\{ height[l],height[r] \}\times (r-l)=6$</li><li>此时$height[l]&lt;height[r]$，因此右移头指针l=4，r=6，水量$V=\min\{ height[l],height[r] \}\times (r-l)=10$</li><li>此时$height[l]&lt;height[r]$，因此右移头指针l=5，r=6，水量$V=\min\{ height[l],height[r] \}\times (r-l)=4$</li><li>此时$height[l]&lt;height[r]$，因此右移头指针l=6，r=6，两指针相遇，算法运行结束。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        int i &#x3D; 0, j &#x3D; height.size()-1;        int ans &#x3D; 0;        while(i !&#x3D; j) &#123;            ans &#x3D; max(ans, min(height[i], height[j]) * (j - i));            if(height[i] &lt; height[j])   i++;            else    j--;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>由于只使用了单层循环，且每一次都会选取数组中的一个数，因此时间复杂度为$\mathcal{O}(n)$，空间复杂度为$\mathcal{O}(1)$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.三数之和</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/13/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/13/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p></blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不妨以<code>[-1,0,1,2,-1,-4]</code>为例思考如何找到三元组。</p><ul><li>i=0，<code>nums[i]=-1</code>，则<code>nums[j]+nums[k]=1</code>，转化为在剩余的数组元素中的两数之和为1的问题。</li><li>i=1，<code>nums[i]=0</code>，则<code>nums[j]+nums[k]=0</code>，转化为在剩余的数组元素中的两数之和为0的问题。</li><li>……</li></ul><p>而两数之和问题可以使用双指针解决，将数组按照非递减排序后，设置头指针和尾指针分别指向数组头部和尾部：</p><ul><li>两指针所指的数之和大于target，则左移右指针；</li><li>两指针所指的数之和小于target，则右移左指针；</li><li>两指针所指的数之和大于target，找到答案。</li></ul><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>此题的关键在于，去除重复解。其实设置了三个指针，每次移动指针时，如果当前指针所指和上一次所指的元素相同时，继续将指针往右移，即可保证选中的解均不重复。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; cnt;        int i &#x3D; 0;        int n &#x3D; nums.size();        sort(nums.begin(), nums.end());        while(i &lt; n) &#123;            while(i &amp;&amp; i &lt; n &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])   i++;            int l &#x3D; i+1, r &#x3D; n-1;            while(l &lt; r) &#123;                int tgt &#x3D; -nums[i];                if(nums[l] + nums[r] &gt; tgt) r--;                else if(nums[l] + nums[r] &lt; tgt)    l++;                else &#123;                    &#x2F;&#x2F; 选中[nums[i], nums[l], nums[r]]                    vector&lt;int&gt; temp &#x3D; &#123;nums[i], nums[l], nums[r]&#125;;                    cnt.push_back(temp);                    l++, r--;                    &#x2F;&#x2F; 去重：此时i不变，考虑左指针l、右指针r指向元素的重复性                    &#x2F;&#x2F; e.g. [-3, 0, 1, 1, 1, 2, 2, 2, 2]                    while(l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l-1])    l++; &#x2F;&#x2F; 注意nums[l-1]已经选过                    while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r+1])    r--; &#x2F;&#x2F; 注意nums[r+1]已经选过                &#125;            &#125;            i++;        &#125;        return cnt;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.最长回文子串</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/12/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/12/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p></blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;cbbd&quot;输出：&quot;bb&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>我们思考一下如何判定字符串s是否为回文串。显然，判定$s[0]=s[n-1]$是否成立，如果不成立，直接判定不是回文串；否则，转化为“判定字符串$s[1:n-2]$是否为回文串”的子问题。因此，我们构建数组dp，其中$dp[i][j]$表示字符串$s[i:j]$是否为回文子串。</p><p>如何进行状态转移呢？根据上面的分析，求解$dp[i][j]$时，判定$s[i]=s[j]$是否成立，如果成立进一步求解$dp[i+1][j-1]$即可。</p><p>到这里可以发现，dp数组的更新方向比较复杂，因此不妨采取自顶向下的备忘录式动态规划写法。</p><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>需要考虑两种边界条件。对于$dp[i][j]$，</p><ul><li>若$i=j$，单个字符必然是回文子串，因此$dp[i][j]=1$；</li><li>若$i+1=j$，则$dp[i][j]=\begin{cases} 0,\ &amp; \mathrm{if} \ s[i] \ne s[j] \\ 1, &amp; \mathrm{otherwise} \end{cases}$</li></ul><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>状态转移方程为</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases} 0, \ & \mathrm{if} \ i>j \ \mathrm{or} \ s[i] \ne s[j] \\ dp[i+1][j-1], & \mathrm{otherwise} \end{cases}</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int dp[1005][1005];    string str;    int DP(int i, int j) &#123;        if(dp[i][j] !&#x3D; -1)  return dp[i][j];        if(i &gt; j)   return dp[i][j] &#x3D; 0;        if(i &#x3D;&#x3D; j)  return dp[i][j] &#x3D; 1;        if(i + 1 &#x3D;&#x3D; j)  return dp[i][j] &#x3D; str[i] &#x3D;&#x3D; str[j] ? 1 : 0;        if(str[i] &#x3D;&#x3D; str[j])    return dp[i][j] &#x3D; DP(i+1, j-1);        return dp[i][j] &#x3D; 0;    &#125;    string longestPalindrome(string s) &#123;        memset(dp, -1, sizeof(dp));        str &#x3D; s;        int i, j;        for(i&#x3D;0; i&lt;s.size(); i++) &#123;            for(j&#x3D;0; j&lt;s.size(); j++) &#123;                dp[i][j] &#x3D; DP(i, j);            &#125;        &#125;        string ans &#x3D; &quot;&quot;;        int len &#x3D; 0;        for(i&#x3D;0; i&lt;s.size(); i++) &#123;            for(j&#x3D;i; j&lt;s.size(); j++) &#123;                &#x2F;&#x2F; cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;                if(dp[i][j] &amp;&amp; j-i+1 &gt; len) &#123;                    ans &#x3D; s.substr(i, j-i+1);                    len &#x3D; j - i + 1;                &#125;            &#125;            &#x2F;&#x2F; cout&lt;&lt;endl;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.无重复字符的最长子串</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/12/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/12/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p></blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 3:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路Ⅰ-：动态规划"><a href="#思路Ⅰ-：动态规划" class="headerlink" title="思路Ⅰ ：动态规划"></a>思路Ⅰ ：动态规划</h2><p>由于之前处理过很经典的最长递增子序列问题、最长公共子序列问题等字符串问题，都是用到了动态规划思想，因此在这里不妨也使用动态规划解题。</p><p>设置数组<code>dp</code>，原字符串为<code>s</code>，则<code>dp[i]</code>表示以<code>s[i]</code>结尾的、无重复字符的最长子串长度。那么状态转移方程如何得到呢？如果已知<code>dp[i-1]</code>，如何计算出<code>dp[i]</code>？</p><p>事实上，我们知道<code>dp[i-1]</code>的值后，便知道<strong>子串<code>s[i-dp[i-1]:i-1]</code>就是以<code>s[i-1]</code>为结尾、无重复字符的最长子串</strong>。那么现在将<code>s[i]</code>考虑进来且必须以之为结尾呢？<strong>那么必然有$dp[i] \leqslant dp[i-1]+1$</strong>，因为<code>s[i]</code>可能与子串<code>s[i-dp[i-1]:i-1]</code>中的某个字符重复，具体地：</p><ul><li>若<code>s[i]</code>与<code>s[k]</code>重复，其中$i-dp[i-1]\leqslant k \leqslant i-1$，那么只能选取子串<code>s[k+1:i]</code>作为无重复字符的最长子串，则$dp[i]=i-k$；</li><li>若<code>s[i]</code>不与子串<code>s[i-dp[i-1]:i-1]</code>中的任何字符重复，那么直接加上<code>s[i]</code>即可，即选取子串<code>s[i-dp[i-1]:i]</code>作为无重复字符的最长子串，$dp[i]=dp[i-1]+1$。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.svg" alt="无重复字符的最长子串"></p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>边界条件很简单，考虑<code>dp[0]</code>即可。令<code>dp[0]=1</code>，因为此时仅有一个字符，必定无重复。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>我们将上述分析过程中的状态转移合并起来，归结为如下状态转移方程</p><script type="math/tex; mode=display">dp[i] = \begin{cases} i - k, \ & \mathrm{if} \ \exist k \in[i-dp[i-1],i-1]\ s.t. s[k]=s[i] \\ dp[i-1]+1, & \mathrm{else} \end{cases}</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        int dp[50005];        dp[0] &#x3D; 1;        int i, j;        for(i&#x3D;1; i&lt;s.size(); i++) &#123;            for(j&#x3D;i-1; j&gt;&#x3D;i-dp[i-1]; j--) &#123;                if(s[j] &#x3D;&#x3D; s[i])    break;            &#125;            dp[i] &#x3D; i - j;        &#125;        int ans &#x3D; 0;        for(i&#x3D;0; i&lt;s.size(); i++) &#123;            ans &#x3D; max(ans, dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>事实上，动态规划的时间复杂度比较大。由于设置了双层循环，时间复杂度基本上达到$\mathcal{O}(n^2)$。接下来的滑动窗口算法将时间复杂度大幅降低。</p><h2 id="思路Ⅱ：滑动窗口"><a href="#思路Ⅱ：滑动窗口" class="headerlink" title="思路Ⅱ：滑动窗口"></a>思路Ⅱ：滑动窗口</h2><p>我们考虑字符串abcabcbb。如果我们能够计算出以每一个字符开头的无重复字符的最长子串长度，也可以得到答案。于是可以得到</p><ul><li>(abc)abcbb</li><li>a(bca)bcbb</li><li>ab(cab)cbb</li><li>abc(abc)bb</li><li>abca(bc)bb</li><li>abcab(cb)b</li><li>abcabc(b)b</li><li>abcabcb(b)</li></ul><p>当考虑到$s[i]$开头的无重复字符最长子串时，假设该子串为$s[i:r_k]$，那么其中必然有字符与$s[r_k+1]$重复，此时进而考虑$s[i+1:r_k+1]$是否有重复字符即可。因此<strong>可以用到滑动窗口</strong>来解决此题。</p><p>滑动窗口的通常做法，<strong>通常需要设置两个指针：左指针和右指针</strong>。两个指针都只能往右移动，且每次仅能移动其中一个指针。</p><ul><li>固定左指针、右移右指针时，此时是扩张操作；</li><li>固定右指针、右移左指针时，此时是收缩操作。</li></ul><p>因此，我们将左右指针初始化为0，然后先进行扩张操作，直到达到无重复字符的最大子串，再将左指针右移一位，进行扩展操作，如此反复直至右指针到达字符串末尾。</p><p>那么如何判断左指针、右指针夹住的滑动窗口子串满足无重复字符的最大子串呢？其实可以<strong>维护一个哈希表，只需检查哈希表中是否存在字符即可判定是否存在重复字符了</strong>。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    map&lt;char, int&gt; cnt;    int lengthOfLongestSubstring(string s) &#123;        int l, r;        l &#x3D; r &#x3D; 0;        int ans &#x3D; 0;        while(l &lt; (int)s.size() &amp;&amp; r &lt; (int)s.size()) &#123;            &#x2F;&#x2F; 计算以s[l]开头的无重复字符的最长子串长度，此时尝试右移右指针（扩张）            while(r &lt; (int)s.size() &amp;&amp; cnt[s[r]] &#x3D;&#x3D; 0) &#123;                cnt[s[r++]] &#x3D; 1;            &#125;            &#x2F;&#x2F; s[l:r-1]无重复            ans &#x3D; max(ans, r - l);            &#x2F;&#x2F; 右移左指针，收缩            cnt[s[l++]] &#x3D; 0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238.除自身以外数组的乘积</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/12/238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/12/238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></p></blockquote><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请<strong>不要使用除法，</strong>且在$\mathcal{O}(n)$时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [1,2,3,4]输出: [24,12,8,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [-1,1,0,-3,3]输出: [0,0,9,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不妨以一个具体的例子来看看结果是如何得出的。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF.svg" alt="除自身以外数组乘积可以看作由左右两部分组成"></p><p>事实上，可以发现<strong>每一个元素除开自身以外数组的乘积可以由两部分组成：该元素左侧元素和右侧元素</strong>。那么我们可以维护两个前缀积数组，存储到最左侧的元素之积以及最右侧的元素之积即可。具体地，记原数组为$nums[]$，其长度为$n$，则</p><ul><li>维护$left[]$数组，其中$left[i]=nums[0]\times nums[1] \times \cdots\times nums[i-1]$</li><li>维护$right[]$数组，其中$right[i] = nums[i+1]\times nums[i+2]\times \cdots\times nums[n-1]$</li></ul><p>两轮遍历，分别为left数组和right数组赋值即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        int left[100005];        int right[100005];        int n &#x3D; nums.size();        left[0] &#x3D; right[n-1] &#x3D; 1;        int i;        for(i&#x3D;1; i&lt;n-1; i++) &#123;            left[i] &#x3D; left[i-1] * nums[i-1];            right[n-1-i] &#x3D; right[n-i] * nums[n-i];         &#125;        left[n-1] &#x3D; left[n-2] * nums[n-2], right[0] &#x3D; right[1] * nums[1];        vector&lt;int&gt; ans;        for(i&#x3D;0; i&lt;n; i++) &#123;            ans.push_back(left[i] * right[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>309.买卖股票的最佳时机含冷冻期</title>
      <link href="/mid-lake-pavilion.github.io/2023/09/12/309-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
      <url>/mid-lake-pavilion.github.io/2023/09/12/309-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>传送门：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p></blockquote><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票），且卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: prices &#x3D; [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: prices &#x3D; [1]输出: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划解决此题。稍微复杂的是，每一个阶段有多种状态（买入、冷冻期、卖出等等）。<strong>我们划分出三种互不相交的状态：持有股票、无股票且处于冷冻期、无股票且不处于冷冻期</strong>，因此设：</p><ul><li><code>dp[i][0]</code>表示第$i$天持有股票的最大利润</li><li><code>dp[i][1]</code>表示第$i$天无股票且不处于冷冻期的最大利润</li><li><code>dp[i][2]</code>表示第$i$天无股票且处于冷冻期的最大利润</li></ul><p>接下来考虑状态转移，分别考虑每一个阶段的三种状态：</p><ul><li>若第i天持有股票，则<strong>第i-1天可能持有股票，也可能无股票且不处于冷冻期（但是第i天买入股票）</strong>，取最大值即$dp[i][0] = \max \{ dp[i-1][0], dp[i-1][1] - prices[i] \}$</li><li>若第i天无股票且不处于冷冻期，则<strong>第i-1天可能无股票且不处于冷冻期，也可能无股票出于冷冻期（过了一天不再处于冷冻期）</strong>，取最大值$dp[i][1] = \max \{ dp[i-1][1], dp[i-1][2] \}$</li><li>若第i天无股票且处于冷冻期，则<strong>第i-1天必然卖出了一张股票，即处于持有股票状态</strong>，即$dp[i][2] = dp[i-1][0] + prices[i]$</li></ul><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>综上有</p><script type="math/tex; mode=display">\begin{cases} dp[i][0] &= \ \max \{ dp[i-1][0], dp[i-1][1] - prices[i] \} \\ \\ dp[i][1] &= \ \max \{ dp[i-1][1], dp[i-1][2] \} \\\\ dp[i][2] &= \ dp[i-1][0] + prices[i] \end{cases}</script><p>最后，对<code>dp</code>数组进行遍历取最大值即可。</p><h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><p>事实上，对于初始情况（即<code>dp[0][i], i=0,1,2</code>），显然不可能处于“无股票且处于冷冻期”状态，因此仅考虑i=0、1。</p><ul><li>若持有股票，那么必然是第1天就买入股票，因此$dp[0][0] = -prices[0]$</li><li>若无股票，那么必然第1天无任何操作，即$dp[0][1] = 0$</li></ul><p>而$dp[0][2]$似乎没有初始化。但是仔细思考就会发现，直接受其影响的实际上就是$dp[1][1]$的计算，因为根据上面的状态转移方程，$dp[1][1]=\max\{ dp[0][1],dp[0][2] \}$，我们只需保证$dp[1][1]$的正确性，便可保证整个状态转移的正确进行。而$dp[0][1]=0$，因此，赋值$dp[0][2]=0$即可，不影响程序正确性。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        &#x2F;&#x2F; dp[i][0]持有股票 dp[i][1]无股票，不处于冷冻期 dp[i][2]无股票，处于冷冻期        int dp[5005][3];        int i, n &#x3D; prices.size();        memset(dp, 0, sizeof(dp));        dp[0][0] &#x3D; -prices[0], dp[0][1] &#x3D; dp[0][2] &#x3D; 0;        for(i&#x3D;1; i&lt;n; i++) &#123;            dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] - prices[i]);            dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][2]);            dp[i][2] &#x3D; dp[i-1][0] + prices[i];        &#125;        int ans &#x3D; 0;        for(i&#x3D;1; i&lt;n; i++) &#123;            ans &#x3D; max(ans, max(dp[i][0], max(dp[i][1], dp[i][2])));        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leecode hot 100 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/27/Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/27/Dijkstra%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>迪杰斯特拉算法，是一种<strong>基于贪心思想的、用于求解单源最短路径</strong>的算法。也就是说，给定一张（不含负权的）图以及一个源点，迪杰斯特拉算法可以很方便地求出各个结点到源点的最短路径。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>我们从一个具体的例子来看看迪杰斯特拉算法的运行过程。注意，我们</p><ul><li>用数组dis来记录每一个结点到源点的最短距离；</li><li>用数组visit来标记结点是否访问过；</li><li>用数组pre来记录每一个结点的前驱结点，以便求出最短路径。</li></ul><p>我们假设源点为①号结点。初始情况下，给dis[1]赋值0，其余均为∞；全部结点均为未访问，visit[]全零。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-初始情况.svg" alt="迪杰斯特拉-初始情况"></p><p>接下来，我们选取源点①（它正好也是当前与源点距离最小的结点），<strong>将其标记为已访问</strong>，进行<strong>松弛</strong>操作。经过松弛操作后，结果变为</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第一次选择.svg" alt="迪杰斯特拉-第一次选择"></p><p>具体来说，以松弛结点①到结点②的边为例，我们可以发现原来的<code>dis[2]=∞</code>，新的距离<code>dis[1]+G[1][2]&lt;dis[2]</code>，于是将<code>dis[2]</code>更新为<code>dis[1]+G[1][2]</code>的值1，<strong>同时更新前驱结点<code>pre[1]</code>为①号结点</strong>。以此类推，可以更新③、④和⑤号结点的情况。</p><p>接下来进行第二次贪心选择：<strong>在未访问过的结点中，选取与源点距离最近的结点，固定其dis值并标记为已访问</strong>。这里②、④均可，不妨选择②号结点：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第二次选择（未松弛）.svg" alt="迪杰斯特拉-第二次选择（未松弛）"></p><p>同样地，以②号结点对与它邻接的边进行松弛。事实上，只有⑤与之邻接（只考虑未访问过的结点，下同），得到</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第二次选择（已松弛）.svg" alt="迪杰斯特拉-第二次选择（已松弛）"></p><p>接下来进行第三次贪心选择——选取④：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第三次选择（未松弛）.svg" alt="迪杰斯特拉-第三次选择（未松弛）"></p><p>以④号结点对与它邻接的边进行松弛。事实上，也只有⑥与之邻接，得到</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第三次选择（已松弛）.svg" alt="迪杰斯特拉-第三次选择（已松弛）"></p><p>接下来进行第四次贪心选择——选取③：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第四次选择（未松弛）.svg" alt="迪杰斯特拉-第四次选择（未松弛）"></p><p>以③号结点对与它邻接的边进行松弛。事实上，只有⑤号结点与之邻接，但是此处新值<code>dis[3]+G[3][5]&gt;dis[5]</code>，于是无需进行优化松弛。</p><p>接下来进行第五次贪心选择——选取⑤：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第五次选择（未松弛）.svg" alt="迪杰斯特拉-第五次选择（未松弛）"></p><p>同样地，以⑤号结点对与它邻接的边进行松弛，也即⑤⑥：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-第五次选择（已松弛）.svg" alt="迪杰斯特拉-第五次选择（已松弛）"></p><p>进行最后一次贪心选择——此时只剩下一个结点未访问了，选取它之后，算法运行结束。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\Dijkstra算法.assets\迪杰斯特拉-算法输出结果.svg" alt="迪杰斯特拉-算法输出结果"></p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>下面我们来看看如何编写迪杰斯特拉算法。我们先从最基本的算法考虑起。首先，根据上面的实例分析，我们知道需要维护一个邻接矩阵（邻接表当然也可）以及dis、visit和pre数组：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1000; &#x2F;&#x2F; 以1000个结点为例int G[N][N];int dis[N];int visit[N];int pre[N];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来进行初始化：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; G, visit, pre均为全局变量时，默认值就是0无需额外的初始化const int INF &#x3D; 1000000000;fill(dis, dis+N, INF);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于贪心思想，迪杰斯特拉算法的伪代码如下。</p><pre class="line-numbers language-none"><code class="language-none">初始化；for i from 1 to N:1.选取未标记过的所有结点中，与源点距离最近的点idx，同时记下该距离minimumdis[idx] &#x3D; minimum, visit[idx] &#x3D; 1;2.松弛全部与idx结点邻接的、未访问过的边<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来实现上面的1、2两部分代码，就完成了迪杰斯特拉算法的基本实现了。</p><h3 id="选取最小dis值"><a href="#选取最小dis值" class="headerlink" title="选取最小dis值"></a>选取最小dis值</h3><p>这部分很简单，遍历选取最小值即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int minimum &#x3D; INF, idx &#x3D; -1;int j;for(j&#x3D;1; j&lt;&#x3D;N; j++) &#123;    if(visit[j] &#x3D;&#x3D; 0 &amp;&amp; dis[j] &lt; minimum) &#123;        minimum &#x3D; dis[j];        idx &#x3D; j;    &#125;&#125;if(idx &#x3D;&#x3D; -1)return; &#x2F;&#x2F; 如果idx仍等于-1，表示图不连通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h3><p>松弛操作也即遍历每一条与idx邻接的边，更新最小值即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(j&#x3D;1; j&lt;&#x3D;N; j++) &#123;    if(visit[j] &#x3D;&#x3D; 0 &amp;&amp; G[idx][j]) &#123;        &#x2F;&#x2F; visit[j] &#x3D;&#x3D; 0表示未访问；G[idx][j]表示不为零即idx和j之间存在边        if(dis[idx] + G[idx][j] &lt; dis[j]) &#123;            &#x2F;&#x2F; 可以进行松弛操作            dis[j] &#x3D; dis[idx] + G[idx][j];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1000; &#x2F;&#x2F; 以1000个结点为例const int INF &#x3D; 1000000000;int G[N][N]; &#x2F;&#x2F; 邻接矩阵int dis[N]; &#x2F;&#x2F; 记录最短距离int visit[N]; &#x2F;&#x2F; 记录是否访问过int pre[N]; &#x2F;&#x2F; 记录前驱结点索引void Dijstra() &#123;    &#x2F;&#x2F; 初始化fill(dis, dis+N, INF);    &#x2F;&#x2F; 贪心，选取最小dis值    int minimum &#x3D; INF, idx &#x3D; -1;    int j;    for(j&#x3D;1; j&lt;&#x3D;N; j++) &#123;        if(visit[j] &#x3D;&#x3D; 0 &amp;&amp; dis[j] &lt; minimum) &#123;            minimum &#x3D; dis[j];            idx &#x3D; j;        &#125;    &#125;    if(idx &#x3D;&#x3D; -1)return; &#x2F;&#x2F; 如果idx仍等于-1，表示图不连通    dis[idx] &#x3D; minimum, visit[idx] &#x3D; 1;    for(j&#x3D;1; j&lt;&#x3D;N; j++) &#123;        if(visit[j] &#x3D;&#x3D; 0 &amp;&amp; G[idx][j]) &#123;            &#x2F;&#x2F; visit[j] &#x3D;&#x3D; 0表示未访问；G[idx][j]表示不为零即idx和j之间存在边            if(dis[idx] + G[idx][j] &lt; dis[j]) &#123;                &#x2F;&#x2F; 可以进行松弛操作                dis[j] &#x3D; dis[idx] + G[idx][j];            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="PAT1087"><a href="#PAT1087" class="headerlink" title="PAT1087"></a>PAT1087</h3><blockquote><p>传送门：<a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805379664297984?type=7&amp;page=0">https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805379664297984?type=7&amp;page=0</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT1107</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/24/PAT1107/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/24/PAT1107/</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805361586847744?type=7&amp;page=1">https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805361586847744?type=7&amp;page=1</a></p></blockquote><p>问题大意：给定n个人，每一个人都有$K_i$个兴趣，拥有相同兴趣的两个人可以算在同一个圈子里。问最后一共有多少个圈子。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很显然的并查集考点。<strong>不同的两个人可以通过具有的某个相同的兴趣连接起来。</strong>具体地，下面的两个人（按照输入格式）属于同一个圈子：</p><pre class="line-numbers language-none"><code class="language-none">2: 5 34: 6 8 1 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为他们都有一个共同的兴趣——5号。随后，下面的人也属于该圈子，因为其中均含有兴趣1号。</p><pre class="line-numbers language-none"><code class="language-none">3: 1 2 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，我们可以从兴趣的角度，设计并查集。对于给定的某个人的兴趣：</p><script type="math/tex; mode=display">K_i:h_i[1]\ h_i[2]\ \dots h_i[K_i]</script><p>我们将它们进行合并，即$\forall j \in \{2,\dots,K_i\}, \mathrm{Union}(h_i[1], h_i[j])$，然后直接$\mathrm{father[Find(h_i[1])]++}$即可。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int father[1005];int symbols[1005];int res[1005];vector&lt;int&gt; tmp;int n;void init() &#123;    int i;    for(i&#x3D;1; i&lt;&#x3D;1005; i++)    father[i] &#x3D; i;&#125;int Find(int x) &#123;    if(x &#x3D;&#x3D; father[x])    return x;    return father[x] &#x3D; Find(father[x]);&#125;void Union(int x, int y) &#123;    int px &#x3D; Find(x);    int py &#x3D; Find(y);    if(px !&#x3D; py) &#123;        father[py] &#x3D; px;    &#125;&#125;bool comp(int a, int b) &#123;    return a &gt; b;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;n);    init();    int i;    for(i&#x3D;0; i&lt;n; i++) &#123;        int k, j, a;        scanf(&quot;%d: %d&quot;, &amp;k, &amp;a);        for(j&#x3D;1; j&lt;k; j++) &#123;            int t;            scanf(&quot;%d&quot;, &amp;t);            Union(a, t);        &#125;        symbols[i] &#x3D; a;    &#125;    for(i&#x3D;0; i&lt;n; i++) &#123;        res[Find(symbols[i])]++;    &#125;    for(i&#x3D;1; i&lt;1005; i++) &#123;        if(res[i] &amp;&amp; Find(i)&#x3D;&#x3D;i)    tmp.push_back(res[i]);    &#125;    printf(&quot;%d\n&quot;, tmp.size());    sort(tmp.begin(), tmp.end(), comp);    for(i&#x3D;0; i&lt;tmp.size(); i++) &#123;        if(i)    printf(&quot; %d&quot;, tmp[i]);        else    printf(&quot;%d&quot;, tmp[i]);    &#125;    printf(&quot;\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib绘图包</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/22/matplotlib%E7%BB%98%E5%9B%BE%E5%8C%85/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/22/matplotlib%E7%BB%98%E5%9B%BE%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib是一个易用的python绘图工具包。</p><h2 id="图层元素"><a href="#图层元素" class="headerlink" title="图层元素"></a>图层元素</h2><p>Matplotlib绘图涉及了多个元素。在了解其用法之前，有必要介绍一下绘图要素的构成。</p><ul><li>画布（figure）。可以设置画布大小、分辨率、颜色等等。</li><li>坐标图形（axes）。即子图，是图形的展示区域。</li><li>轴（axis）。即坐标轴对象。</li><li>刻度（tick）。坐标轴上的刻度，包括主刻度、次刻度。</li></ul><p><img src="D:\我的大学\newBlogs\source\_posts\assets\matplotlib绘图包.assets\image-20230822103155646.png" alt="Matplotlib绘图的主要元素" style="zoom:80%;" /></p><h2 id="多子图绘制"><a href="#多子图绘制" class="headerlink" title="多子图绘制"></a>多子图绘制</h2><p>在一个图形中绘制多个子图，是很关键的绘图技术，也必须掌握。</p><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot()"></a>subplot()</h3><p><code>subplot(nrow, ncol, index)</code></p><p>划分出nrow×ncol个子图区域，在index位置处绘图。另外，参数列表中的逗号在其数值不超过9时可以省略。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>fig<span class="token punctuation">.</span>suptitle<span class="token punctuation">(</span><span class="token string">'Figure1'</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">#plt.subplot(3, 4, 1)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span>    <span class="token comment">#plt.subplot(3, 4, 12)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:\我的大学\newBlogs\source\_posts\assets\matplotlib绘图包.assets\image-20230822110953520.png" alt="subplot()绘图"></p>]]></content>
      
      
      <categories>
          
          <category> 工具包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生的基本素养之概率论与数理统计</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/16/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%E4%B9%8B%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/16/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%E4%B9%8B%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>对于包括计算机专业在内的理工科而言，概率论与数理统计是一门非常重要的数学基础课。本文立足于申请研究生笔试、面试等等考核，从本科生角度，将《概率论与数理统计》这门课中常见的重要知识点做以简单的记录。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="概率论基本知识点"><a href="#概率论基本知识点" class="headerlink" title="概率论基本知识点"></a>概率论基本知识点</h3><ol><li><p>条件概率公式</p><script type="math/tex; mode=display">\begin{aligned} P(A|B) &= \frac{P(AB)}{P(B)} \\ P(AB) &= P(A|B)P(B) = P(B|A)P(A) \\ P(A_1A_2\dots A_n) &= P(A_1)P(A_1|A_2)P(A_3|A_1A_2)\dots P(A_n|A_1A_2\dots A_{n-1}) \end{aligned}</script><blockquote><p>关于上述第三个公式，有递推公式$P(A_1A_2\dots A_i)=P(A_i|A_1A_2\dots A_{i-1})P(A_1A_2\dots A_{i-1})$，依次递推可得结果。</p></blockquote></li><li><p>全概率公式</p><p>试验$E$的样本空间有一个划分为$B_1, B_2, \dots, B_n$，则$E$的某一事件$A$的全概率公式为</p><script type="math/tex; mode=display">P(A) = \sum_{i=1}^n P(A|B_i)P(B_i)</script><blockquote><p>简单理解，导致事件$A$发生有很多条件因素，用条件概率算加和就是全概率公式。</p></blockquote></li><li><p>贝叶斯公式</p><script type="math/tex; mode=display">P(A|B) = \frac{P(B|A)P(A)}{P(B)}</script><p>有时候利用贝叶斯公式计算概率时，分母的$P(B)$需要用全概率公式计算得到。</p></li></ol><h3 id="随机变量及其概率分布"><a href="#随机变量及其概率分布" class="headerlink" title="随机变量及其概率分布"></a>随机变量及其概率分布</h3><ol><li><p>随机变量</p><p>随机变量分为两种：</p><ul><li>离散型随机变量</li><li>连续型随机变量</li></ul></li><li><p>分布律与概率密度</p><ul><li>分布律：针对<strong>离散型随机变量</strong>的概率分布。即高中学过的分布列。高中主要学习的就是离散型随机变量。</li><li>概率密度：针对<strong>连续型随机变量</strong>的概率分布。对连续型随机变量$X$，有概率密度函数$f(x)$，则$P(X=a)=f(a)$。</li></ul><blockquote><p>概率密度函数是重点。它有如下的特点：</p><ul><li>非负：$\forall x \in (-\infty, +\infty), 0 \leqslant f(x) \leqslant 1$；</li><li>积分为1：$\displaystyle \int_{-\infty}^{+\infty}f(x)dx=1$</li></ul></blockquote></li><li><p>分布函数</p><p>对于随机变量$X$，定义它的分布函数</p><script type="math/tex; mode=display">F(x) = P(X\leqslant x) = \begin{cases} \displaystyle \sum_{t\leqslant x} p(t), X为离散型随机变量 \\ \displaystyle \int_{-\infty}^xf(t)dt \end{cases}</script><blockquote><p>分布函数$F(x)$的性质如下：</p><ul><li>$F(x)$单调不减</li><li>$\displaystyle F(-\infty) = \lim_{x\to -\infty}F(x) = 0; \displaystyle F(+\infty) = \lim_{x\to +\infty}F(x) = 1$</li><li>$F(x)$右连续</li></ul></blockquote></li><li><p>几种常见的离散型分布</p></li></ol><div class="table-container"><table><thead><tr><th></th><th>0-1分布</th><th>二项分布</th><th>泊松分布</th><th>超几何分布</th></tr></thead><tbody><tr><td>分布$X$</td><td>$X\sim 0-1(p)$</td><td>$X\sim B(n,p)$</td><td>$X\sim P(\lambda)$</td><td>$X\sim H(N,M,n)$</td></tr><tr><td>分布律$P(X=k)$</td><td>$p^k(1-p)^{n-k}$</td><td>$C_n^kp^k(1-p)^{n-k}$</td><td>$\displaystyle \frac{\lambda^ke^{-\lambda}}{k!}$</td><td>$\displaystyle \frac{C_M^kC_{N-M}^{n-l}}{C_N^n}$</td></tr><tr><td>数学期望$E(X)$</td><td>$p$</td><td>$np$</td><td>$\lambda$</td><td>$\displaystyle n\frac{M}{N}$</td></tr><tr><td>方差$D(X)$</td><td>$p(1-p)$</td><td>$np(1-p)$</td><td>$\lambda$</td><td>$\displaystyle n\frac{M(N-M)(N-n)}{N^2(N-1)}$</td></tr></tbody></table></div><ol><li>几种常见的连续型分布</li></ol><div class="table-container"><table><thead><tr><th></th><th>正态分布</th><th>指数分布</th><th style="text-align:center">均匀分布</th></tr></thead><tbody><tr><td>分布$X$</td><td>$X\sim N(\mu,\sigma^2)$</td><td>$X\sim E(\lambda)$</td><td style="text-align:center">$X\sim U(a,b)$</td></tr><tr><td>密度函数$f(x)$</td><td>$\displaystyle \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</td><td>$\lambda e^{-\lambda x}$</td><td style="text-align:center">$\displaystyle \frac{1}{b-a}$</td></tr><tr><td>分布函数$F(x)$</td><td></td><td>$1-e^{-\lambda x}$</td><td style="text-align:center">$\begin{cases} 0,x\leqslant a \\ \displaystyle \frac{x-a}{b-a}, a&lt;x&lt;b \\ 1, x\geqslant b \end{cases}$</td></tr><tr><td>数学期望$E(X)$</td><td>$\mu$</td><td>$\displaystyle \frac{1}{\lambda}$</td><td style="text-align:center">$\displaystyle \frac{a+b}{2}$</td></tr><tr><td>方差$D(X)$</td><td>$\sigma^2$</td><td>$\displaystyle \frac{1}{\lambda^2}$</td><td style="text-align:center">$\displaystyle \frac{(b-a)^2}{12}$</td></tr></tbody></table></div><h3 id="多元随机变量及其概率分布"><a href="#多元随机变量及其概率分布" class="headerlink" title="多元随机变量及其概率分布"></a>多元随机变量及其概率分布</h3><p>多元随机变量相比于单一随机变量，提高了随机变量维度，情况更加复杂。同样地，也有概率密度、分布函数等定义。这里以常见的二元随机变量为例进行说明。</p><ol><li><p>联合分布律与联合概率密度</p><ul><li>联合分布律：多元随机变量为离散型随机变量</li><li>联合概率密度：多元随机变量为连续型随机变量。对于连续型随机变量$X,Y$，有概率密度函数$f(x,y)$，则$P(X=a \cap Y=b)=f(a,b)$</li></ul></li><li><p>分布函数</p><p>不妨以连续型随机变量为例，定义$X,Y$的概率分布函数为</p><script type="math/tex; mode=display">F(x,y)=P(X\leqslant x \cap Y\leqslant y) = \int_{-\infty}^x\int_{-\infty}^yf(u,v)dvdu</script></li><li><p>边缘分布</p><p>即仅保留一个随机变量、消去其他全部变量而得到的概率分布称为<strong>边缘分布</strong>：</p><script type="math/tex; mode=display">F_X(x) = P(X\leqslant x, Y\leqslant +\infty) = F(x,+\infty)</script><script type="math/tex; mode=display">F_Y(y) = P(X\leqslant +\infty, Y\leqslant y) = F(+\infty, y)</script><p>求<strong>边缘概率密度</strong>时，对于离散型随机变量，边缘概率需要进行求和；对于连续型随机变量，边缘概率密度需要进行积分：</p><script type="math/tex; mode=display">f_X(x) = \int_{-\infty}^{+\infty}f(x,y)dy</script><script type="math/tex; mode=display">f_Y(y) = \int_{-\infty}^{+\infty}f(x,y)dx</script></li><li><p>条件概率分布</p><p>二维随机变量$X,Y$概率密度为$f(x,y)$，而$(X,Y)$关于$Y$的边缘概率密度为$f_Y(y)$，对于固定的$y$，称$\displaystyle \frac{f(x,y)}{f_Y(y)}$，记作</p><script type="math/tex; mode=display">f_{X|Y}(x|y) = \frac{f(x,y)}{f_Y(y)}</script><p>而称</p><script type="math/tex; mode=display">F_{X|Y}(x|y) = P(X\leqslant x | Y=y) = \int_{-\infty}^x f_{X|Y}(x|y)dx=\int_{-\infty}^x\frac{f(x,y)}{f_Y(y)}dx</script><p>为$Y=y$条件下$X$的分布函数。</p></li></ol><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="联合概率密度求边缘概率密度"><a href="#联合概率密度求边缘概率密度" class="headerlink" title="联合概率密度求边缘概率密度"></a>联合概率密度求边缘概率密度</h5><p>设随机变量$(X,Y)$的联合概率密度函数为</p><script type="math/tex; mode=display">f(x,y) = \begin{cases} ke^{-(2x+y)} & x>0,y>0 \\ 0 &其他 \end{cases}</script><ol><li>求常数$k$；</li><li>求随机变量$X$的边缘概率密度$f_X(x)$；</li><li>求$P(Y&gt;X)$。</li></ol><p>解析：</p><ol><li><p>求解常数$k$，需要用到性质$\displaystyle \int_0^{+\infty}\int_0^{+\infty}ke^{-(2x+y)}dxdy = 0$，计算得出$k=2$.</p></li><li><p>根据上面的计算公式</p><script type="math/tex; mode=display">\begin{aligned} f_X(x) &= \int_{-\infty}^{+\infty}f(x,y)dy \\ &= \int_{-\infty}^{+\infty}2e^{-(2x+y)}dy \\ &= \begin{cases} 2e^{-2x}, \ & x\geqslant 0 \\0, &x<0 \end{cases} \end{aligned}</script></li><li><p>对概率密度进行积分</p><script type="math/tex; mode=display">\begin{aligned} P(Y>X) &= \int_0^{+\infty}\int_x^{+\infty}f(x,y)dydx \\ &= \int_0^{+\infty}\int_x^{+\infty}2e^{-(2x+y)}dydx \\ &=\frac{2}{3} \end{aligned}</script></li></ol><h5 id="求条件概率分布"><a href="#求条件概率分布" class="headerlink" title="求条件概率分布"></a>求条件概率分布</h5><p>设随机变量$X,Y$的概率分布为</p><script type="math/tex; mode=display">f(x,y) = \begin{cases} e^{-x}\ &0<y<x \\ 0 & 其他 \end{cases}</script><ol><li>求条件概率$P(X&lt;1|Y&lt;1)$；</li><li>求边缘概率密度$f_X(x)$。</li></ol><p>解析：</p><ol><li><p>将概率积分区域表示在平面直角坐标系：</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E7%A7%AF%E5%88%86%E5%8C%BA%E5%9F%9F.png" alt="0&lt;y&lt;x对应的积分区域，同时考虑x&lt;1和y&lt;1"></p><p>对$x&lt;1,y&lt;1,0&lt;y&lt;x$围成的区域进行积分，不妨将其看作$x$型域：</p><script type="math/tex; mode=display">\begin{cases} 0\leqslant x \leqslant 1 \\ 0 \leqslant y \leqslant x \end{cases}</script><p>对$0&lt;y&lt;x,y&lt;1$围成的区域进行积分，不妨将其看作$y$型域：</p><script type="math/tex; mode=display">\begin{cases} 0\leqslant y \leqslant 1 \\ y \leqslant x \leqslant +\infty \end{cases}</script><script type="math/tex; mode=display">\begin{aligned} P(X<1|Y<1) &= \frac{P(X<1,Y<1)}{P(Y<1)} \\ &= \frac{\displaystyle \int_0^1\int_{0}^{x}e^{-y}dydx}{\displaystyle \int_0^1\int_y^{+\infty}e^{-y}dxdy} \\ &= \frac{e^{-2}}{e^{-1}} \end{aligned}</script></li><li><p>对$0&lt;y&lt;x$围成的区域进行积分，由于要求$X$的边缘概率，因此将其视为$x$型域：</p><script type="math/tex; mode=display">\begin{cases} x>0\\0<y<x \end{cases}</script><p>进行积分：</p><script type="math/tex; mode=display">\begin{aligned} f_X(x) &= \int_{-\infty}^{+\infty}f(x,y)dy \\ &= \begin{cases} \displaystyle \int_0^xe^{-x}dy \ &x>0 \\ 0 & x\leqslant 0 \end{cases} \\ &= \begin{cases} \displaystyle xe^{-x} \ &x>0 \\ 0 & x\leqslant 0 \end{cases} \end{aligned}</script></li></ol><h5 id="求两个随机变量的函数的分布"><a href="#求两个随机变量的函数的分布" class="headerlink" title="求两个随机变量的函数的分布"></a>求两个随机变量的函数的分布</h5><p>设二维随机变量$(X,Y)$的概率密度为</p><script type="math/tex; mode=display">f(x,y)=\begin{cases} 3x\ &0<x<1,0<y<x\\ 0 & 其他 \end{cases}</script><p>求$Z=X-Y$的概率密度$f_Z(z)$。</p><p>解析：</p><p>这种题目通常有两种做法。通常<strong>将$Y$（当然$X$也可以）用$Z$和$X$（或者$Y$）的式子表示出来并代入原限制条件，然后将积分区域用$z$型域表出，求积分即可。</strong>具体如下。</p><p>由$z=x-y$得到$y=x-z$，则</p><script type="math/tex; mode=display">\begin{cases} 0<x<1 \\ 0<x-z<x \end{cases} \Rightarrow \begin{cases} 0<z<1 \\ z<x<1 \end{cases}</script><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230818163218024.png" alt="z型域" style="zoom:50%;" /></p><p>因此，</p><script type="math/tex; mode=display">f_Z(z)=\begin{cases} \displaystyle \int_z^1f(x,z-x)dx \ & 0<z<1 \\ 0 & 其他 \end{cases}</script><p>得到</p><script type="math/tex; mode=display">f_Z(z)=\begin{cases} \displaystyle \frac{3}{2}(1-z^2) \ & 0<z<1 \\ 0 & 其他 \end{cases}</script><h3 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h3><p>期望、方差、矩、协方差和相关系数的计算是笔试中的重点，而<strong>大数定律、中心极限定理</strong>相关概念知识点经常出现在面试中，请务必掌握。</p><ol><li><p>期望</p><script type="math/tex; mode=display">E(X) = \begin{cases} \displaystyle \sum_{i=1}^{+\infty}x_i·p_i, X为离散型随机变量 \\ \displaystyle \int_{-\infty}^{+\infty}xf(x)dx, X为连续型随机变量 \end{cases}</script></li><li><p>方差</p><script type="math/tex; mode=display">D(X) = \begin{cases} \displaystyle \sum_{i=1}^{+\infty}\left[ x_i-E(X) \right]^2p_i,X为离散型随机变量 \\ \displaystyle \int_{-\infty}^{+\infty}\left[ x-E(X) \right]^2f(x)dx,X为连续型随机变量 \end{cases}</script><p><strong>重要性质</strong>：$D(X) = E(X^2) - E^2(X)$</p></li><li><p>矩</p><p><strong>矩</strong>：设$X$为随机变量，$c$为常数，$r$为正整数，则$E[(X-c)^2]$称为$X$关于$c$点的$r$阶矩。</p><p><strong>原点矩</strong>：$c=0$时，$E(X^r)$称为$X$的$r$阶原点矩。</p><p><strong>中心距</strong>：$c=E(X)$时，$E[(X-E(X))^r]$称为$X$的$r$阶中心距。</p></li><li><p>协方差</p><p>随机变量$X,Y$的协方差定义为</p><script type="math/tex; mode=display">Cov(X,Y) = E[[X-E(X)]·[Y-E(Y)]]</script><p>性质：</p><script type="math/tex; mode=display">\begin{aligned} &Cov(X, Y) = Cov(Y, X) \\ &Cov(X, Y) = E(XY) - E(X)E(Y) \\ &Cov(aX, bY) = ab·Cov(X,Y) \end{aligned}</script></li><li><p>相关系数</p><p>随机变量$X,Y$的相关系数定义为</p><script type="math/tex; mode=display">\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}</script><p>备注：</p><ul><li>$\rho_{XY}=0$时，说明$X,Y$不（线性）相关，<strong>但是它们未必独立，因为这只能说明它们之间不存在线性关系，但是不排除可能存在其他关系</strong></li><li>$|\rho_{XY}|$越靠近1，则说明$X,Y$的线性关系越强烈，取等号时，两者存在严格的线性关系</li></ul></li><li><p>大数定律</p><p>大数定律本质上揭示了“当重复试验次数很大时，<strong>随机变量的均值依概率收敛与其期望</strong>”，它将<strong>数理统计中的均值</strong>和<strong>概率论中的期望</strong>联系在了一起。</p><p>三种表述：</p><ul><li><p><strong>辛钦大数定律</strong>：随机变量$X_1,X_2,\dots,X_n$相互独立，服从同一分布且具有数学期望$E(X_i)=\mu$，则序列$\displaystyle \bar{X} = \frac{1}{n}\sum_{i=1}^nX_i$依概率收敛于$\mu$；</p></li><li><p><strong>伯努利大数定律</strong>：大量独立重复实验之后，<strong>随机事件的频率收敛于概率</strong>，即</p><script type="math/tex; mode=display">\forall \varepsilon > 0, \lim_{n\to+\infty}P\left\{ \left|\frac{f_A}{n} - p\right| < \varepsilon \right\} = 1</script><p>其中$f_A$指的是$n$次独立重复试验中事件A发生的频数，$p$是事件A发生的概率。</p></li></ul></li><li><p>中心极限定理</p><ul><li><p><strong>独立同分布的中心极限定理</strong></p><p>设随机变量$X_1,X_2,\dots,X_n$相互独立且服从同一分布、具有期望$E(X_i)=\mu$和方差$D(X_i)=\sigma^2$，当$n$充分大时，近似地有</p><script type="math/tex; mode=display">\bar{X} \sim N(\mu, \frac{\sigma^2}{n})</script><p>即均值$\bar{X}$近似服从以$\mu$为均值、$\displaystyle \frac{\sigma^2}{n}$为方差的正态分布。</p></li><li><p><strong>棣莫弗-拉普拉斯中心极限定理</strong></p><p>设随机变量$\eta_n$服从参数为$n,p$的二项分布$B(n,p)$，当$n$充分大时，$\eta_n$近似服从正态分布$N(np,np(1-p))$：</p><script type="math/tex; mode=display">\lim_{n\to+\infty}P\left( \frac{\eta_n-np}{\sqrt{np(1-p)}}<x \right)=\Phi(x)</script></li></ul></li></ol><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="计算期望、方差、协方差"><a href="#计算期望、方差、协方差" class="headerlink" title="计算期望、方差、协方差"></a>计算期望、方差、协方差</h5><p>设随机变量$X,Y$的联合概率密度为</p><script type="math/tex; mode=display">f(x,y) = \begin{cases} 3x \ &0\leqslant y < x \leqslant 1 \\ 0 & 其他 \end{cases}</script><p>求数学期望$E(X),E(Y)$和协方差$Cov(X,Y)$、相关系数$\rho_{XY}$。</p><p>解析：</p><p>$0\leqslant y &lt; x \leqslant 1$围成的区域即为积分区域，即下图的蓝色区域。将该区域分别表示为$x$型域和$y$型域：</p><script type="math/tex; mode=display">\begin{cases} 0<x<1\\0<y<x \end{cases} \Leftrightarrow \begin{cases} 0<y<1\\y<x<1 \end{cases}</script><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230818164837315.png" alt="积分区域" style="zoom: 50%;" /></p><script type="math/tex; mode=display">f_X(x) = \begin{cases} \displaystyle \int_0^x3xdy \ &0<x<1\\ 0 & 其他 \end{cases} = \begin{cases} 3x^2\ & 0<x<1 \\ 0 & 其他 \end{cases}</script><script type="math/tex; mode=display">f_Y(y) = \begin{cases} \displaystyle \int_y^1 3xdx \ & 0<y<1\\0 & 其他 \end{cases} = \begin{cases} \displaystyle \frac{3}{2}(1-y^2) \ & 0<y<1 \\ 0 & 其他 \end{cases}</script><p>故而有</p><script type="math/tex; mode=display">E(X) = \int_{-\infty}^{+\infty}xf_X(x)dx=\int_0^13x^3dx=\frac{3}{4}</script><script type="math/tex; mode=display">E(Y) = \int_{-\infty}^{+\infty}yf_Y(y)dy = \int_0^1\frac{3}{2}(1-y^2)ydy = \frac{3}{8}</script><p>计算$Cov(X,Y)$还需要计算$E(XY)$，则</p><script type="math/tex; mode=display">\begin{aligned} E(XY) &= \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xy·f(x,y)dxdy \\ &= \int_0^1dx\int_0^xxy·3xdy \\ &=\frac{3}{10} \end{aligned}</script><p>故</p><script type="math/tex; mode=display">Cov(X,Y) = E(XY) - E(X)E(Y) = \frac{3}{160}</script><p>而计算$\rho_{XY}$还需要计算$D(X),D(Y)$，因此需要用到公式$D(X) = E(X^2) - E^2(X)$.</p><script type="math/tex; mode=display">E(X^2) = \int_0^1x^2f_X(x)dx=\frac{3}{5}</script><script type="math/tex; mode=display">E(Y^2) = \int_0^1y^2f_Y(y)dy = \frac{1}{5}</script><p>故</p><script type="math/tex; mode=display">D(X) = E(X^2) - E^2(X) = \frac{3}{80}\\D(Y) = E(Y^2) - E^2(Y) = \frac{19}{320}</script><p>因此得</p><script type="math/tex; mode=display">\begin{aligned} \rho_{XY} &= \frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}\\ &= \frac{\displaystyle\frac{3}{160}}{\displaystyle \sqrt{\frac{3}{80}}\sqrt{\frac{19}{320}}} \\ &= \frac{3}{\sqrt{57}} \end{aligned}</script><h3 id="三大统计分布"><a href="#三大统计分布" class="headerlink" title="三大统计分布"></a>三大统计分布</h3><ol><li><p>卡方分布</p><p>设$X_1,X_2,\dots,X_n$是来自标准正态分布$\mathcal{N}(0,1)$的样本，令</p><script type="math/tex; mode=display">X = \sum_{i=1}^nX_i^2</script><p>则称$X$是自由度为$n$的$\mathcal{X}^2$变量，其分布称为自由度为$n$的$\mathcal{X}^2$分布，记作$X\sim \mathcal{X}^2_n$</p><p><strong>上侧$\alpha$分位数</strong>：若$X\sim \mathcal{X}^2_n$，记$P(X&gt;\mathcal{X}_\alpha^2(n))=\alpha$，则$c=\mathcal{X}_n^2(\alpha)$称为$\mathcal{X}_n^2$分布的上侧$\alpha$分位数。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230818213924268.png" alt="卡方分布，上侧α分位数"></p><blockquote><p>关于上侧$\alpha$分位数的，一定要结合其实际含义进行理解。尤其是$\alpha$的含义，结合概率关系进行理解。注意三大统计分布的图线和x轴围成的区域面积始终为1。</p></blockquote></li><li><p>t-分布</p><p>设随机变量$X\sim \mathcal{N}(0,1)$，$Y\sim \mathcal{X}_n^2$，且$X,Y$独立，则称</p><script type="math/tex; mode=display">T=\frac{X}{\sqrt{Y/n}}</script><p>为自由度为$n$的$t$变量，其分布称为自由度为$n$的t-分布，记作$T\sim t(n)$。</p><p><strong>上侧$\alpha$分位数</strong>：若$T\sim t(n)$，记$P(T&gt;t_{\frac{\alpha}{2}}(n))=\frac{\alpha}{2}$。根据t-分布图像对称性，有重要性质</p><script type="math/tex; mode=display">t_{1-\frac{\alpha}{2}}(n) = -t_{\frac{\alpha}{2}}(n)</script><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230819165854092.png" alt="t分布上侧α分位数" style="zoom:50%;" /></p></li><li><p>F-分布</p><p>设随机变量$U\sim \mathcal{X}^2(n_1), V\sim \mathcal{X}^2(n_2)$，且它们互相独立，则称随机变量</p><script type="math/tex; mode=display">F=\frac{U/n_1}{V/n_2}</script><p>为服从自由度为$(n_1,n_2)$的F分布，记作$F\sim F(n_1,n_2)$。</p><p>上侧$\alpha$分位数：若$F\sim F(n_1,n_2)$，记$\displaystyle P(F&gt;F_{\frac{\alpha}{2}}(n_1,n_2))=\frac{\alpha}{2}$。有重要性质：</p><script type="math/tex; mode=display">F_{1-\alpha}(n_1,n_2) = \frac{1}{F_\alpha(n_2,n_1)}</script><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230819171441008.png" alt="F-分布上侧α分位数" style="zoom:80%;" /></p></li><li><p>正态分布总体的样本均值与样本方差的分布</p><p>设$X_1,X_2,\dots,X_n$是来自正态分布$\mathcal{N}(\mu,\sigma^2)$的样本，样本均值为$\bar{X}$，样本方差为$S^2$，则有几条重要定理，需要掌握：</p><ul><li><p>样本均值$\bar{X}$满足</p><script type="math/tex; mode=display">\bar{X}\sim\mathcal{N}(\mu,\sigma^2/n)</script><p>也即</p><script type="math/tex; mode=display">\frac{\bar{X}-\mu}{\sigma/\sqrt{n}} \sim \mathcal{N}(0,1)</script></li><li><p>样本均值$\bar{X}$与样本方差$S^2$相互独立，且</p><script type="math/tex; mode=display">\frac{(n-1)S^2}{\sigma^2} \sim \mathcal{X}^2(n-1)</script></li><li><p>有统计量满足t分布</p><script type="math/tex; mode=display">\frac{\bar{X}-\mu}{S/\sqrt{n}} \sim t(n-1)</script></li></ul><p><strong>上面的三个统计量以及其满足的分布非常重要，在后续的假设检验部分有着非常关键的应用。</strong></p></li></ol><h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><p>矩估计、极大似然估计都是必须掌握的重要知识点。</p><h4 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h4><p>我们回到矩的定义：</p><ul><li>$k$阶原点矩：设$X$为随机变量，$E(X^k)$称为$X$的$k$阶原点矩，简称$k$阶矩。</li><li>样本$k$阶矩：称$\displaystyle A_k=\frac{1}{n}\sum_{i=1}^nX_i^k$为样本$k$阶矩。</li></ul><p>矩估计的基本原理：<strong>样本$k$阶矩$A_k$是$k$阶总体矩$\mu_k=E(X^k)$的无偏估计。</strong>也就是在解题过程中，利用恒等式</p><script type="math/tex; mode=display">A_k=E(X^k), k=1,2,\dots</script><p>进行求解参数。通常我们最多使用到两个等式$A_1=E(X),A_2=E(X^2)$：</p><ul><li>求$E(X)$，$\displaystyle E(X) = \int_{-\infty}^{+\infty}f(x)dx$</li><li>求$E^2(X)$，$E(X^2) = D(X) + E^2(X)$</li></ul><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><p>不妨就以连续型随机变量为例。设$X_1,X_2,\dots,X_n$是来自总体$X$的$n$个随机样本，而$x_1,x_2,\dots,x_n$是对应于$X_1,X_2,\dots,X_n$的样本值，则事件$\{X_1=x_1,X_2=x_2,\dots,X_n=x_n\}$发生的概率为</p><script type="math/tex; mode=display">L(\theta) = L(x_1,x_2,\dots,x_n;\theta) = \prod_{i=1}^nf(x_i;\theta)</script><p>我们需要求出使得$L(\theta)$最大的参数值$\hat{\theta}$。如果将$\theta$的取值范围记作$\Theta$，则</p><script type="math/tex; mode=display">\hat{\theta} = \arg\max_{\theta\in \Theta}L(x_1,x_2,\dots,x_n;\theta)</script><p>这实际上就是一个简单的优化问题。只需求导数，令其等于0，即可求出最优参数值（也称极大似然估计值）。</p><script type="math/tex; mode=display">\frac{\partial L(\theta)}{\partial \theta} = 0</script><p>为了简化运算，我们往往对$L(\theta)$取对数，得到<strong>对数似然函数</strong>$\ln L(\theta)$，再对其求导数，令其等于0，同样可以求出最优参数值。</p><script type="math/tex; mode=display">\frac{\partial \ln L(\theta)}{\partial \theta} = 0</script><h4 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h4><p>我们简单看看区间估计的原理。对于给定值$\alpha$和来自总体$X$的样本$X_1,X_2,\dots,X_n$，我们需要找到两个统计量$\underline{\theta}(X_1,X_2,\dots,X_n) &lt;\theta &lt; \overline{\theta}(X_1,X_2,\dots,X_n)$，满足</p><script type="math/tex; mode=display">P\{ \underline{\theta}(X_1,X_2,\dots,X_n) <\theta < \overline{\theta}(X_1,X_2,\dots,X_n) \} \geqslant 1-\alpha</script><p>则称<strong>区间$(\underline{\theta}, \overline{\theta})$是$\theta$的置信水平（置信度）为$1-\alpha$的置信区间</strong>。</p><p>对于给定的连续型随机变量，<strong>我们通常按照$P\{\underline{\theta} &lt; \theta &lt; \overline{\theta}\} = 1-\alpha$</strong>来求出置信区间；对于离散型随机变量，通常只能尽可能地选取置信区间使$P\{\underline{\theta} &lt; \theta &lt; \overline{\theta}\} = 1-\alpha$逼近$1-\alpha$。</p><blockquote><p>要想掌握好这一部分的内容，需要更好地回顾、掌握之前的两个部分的知识：</p><ul><li>三个统计发布中的三个重要定理</li><li>上$\alpha$分位数的概念</li></ul><p>另外我们只关注单个总体$\mathcal{N}(\mu,\sigma^2)的情况$。</p></blockquote><h5 id="sigma-2-已知，-mu-未知时-mu-的区间估计"><a href="#sigma-2-已知，-mu-未知时-mu-的区间估计" class="headerlink" title="$\sigma^2$已知，$\mu$未知时$\mu$的区间估计"></a>$\sigma^2$已知，$\mu$未知时$\mu$的区间估计</h5><p>设总体$X \sim \mathcal{N}(\mu,\sigma^2)$，$\sigma^2$已知、$\mu$未知，设$X_1,X_2,\dots,X_n$是来自$X$的样本，求$\mu$的置信水平为$1-\alpha$的置信区间。</p><p>我们需要找到一个除了未知参数$\mu$之外不依赖于任何未知参数的统计量。<strong>这时就需要用到三大统计分布的重要定理（正态分布总体的样本均值与样本方差的分布）</strong>。我们选取</p><script type="math/tex; mode=display">\frac{\bar{X}-\mu}{\sigma/\sqrt{n}} \sim \mathcal{N}(0,1)</script><blockquote><p>我们把统计量$\displaystyle \frac{\bar{X}-\mu}{\sigma/\sqrt{n}}$称为<strong>枢轴量</strong>。</p></blockquote><p>然后，<strong>根据标准正态分布的上$\alpha$分位数的定义</strong>，可以得到</p><script type="math/tex; mode=display">P\left\{ \left| \frac{\bar{X}-\mu}{\sigma/\sqrt{n}} \right| < z_{\frac{\alpha}{2}} \right \} = 1-\alpha</script><p>对左侧括号中的不等式做变形，可以得到</p><script type="math/tex; mode=display">P\left\{ \bar{X}-\frac{\sigma}{\sqrt{n}}z_{\frac{\alpha}{2}} < \mu < \bar{X}+\frac{\sigma}{\sqrt{n}}z_{\frac{\alpha}{2}} \right\}</script><p>因此求得$\mu$的置信区间为</p><script type="math/tex; mode=display">\left( \bar{X}-\frac{\sigma}{\sqrt{n}}z_{\frac{\alpha}{2}}, \bar{X}+\frac{\sigma}{\sqrt{n}}z_{\frac{\alpha}{2}} \right)</script><h5 id="sigma-2-未知，-mu-未知时-mu-的区间估计"><a href="#sigma-2-未知，-mu-未知时-mu-的区间估计" class="headerlink" title="$\sigma^2$未知，$\mu$未知时$\mu$的区间估计"></a>$\sigma^2$未知，$\mu$未知时$\mu$的区间估计</h5><p>这种情况下，就不可以使用枢轴量$\displaystyle \frac{\bar{X}-\mu}{\sigma/\sqrt{n}}$了，因为$\sigma$是未知的。但是，<strong>考虑到$S^2$是$\sigma^2$的无偏估计，因此选用枢轴量$\displaystyle \frac{\bar{X}-\mu}{S/\sqrt{n}}$</strong>：</p><script type="math/tex; mode=display">\frac{\bar{X}-\mu}{S/\sqrt{n}} \sim t(n-1)</script><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230819165854092.png" alt="t分布上侧α分位数" style="zoom:50%;" /></p><p>因此有</p><script type="math/tex; mode=display">P\left\{ \left| \frac{\bar{X}-\mu}{S/\sqrt{n}} \right| < t_{\frac{\alpha}{2}}(n-1) \right \} = 1-\alpha</script><blockquote><p>根据上图所示的上$\alpha$分位数，单个黑色区域面积为$\displaystyle \frac{\alpha}{2}$，全部的黑色区域面积加起来就是$\alpha$，白色区域面积为$1-\alpha$，刚好就是上式的通俗描述。其他的区间估计都可以以此类似理解。</p></blockquote><p>整理得到$\mu$的一个置信水平为$1-\alpha$的置信区间</p><script type="math/tex; mode=display">\left( \bar{X}-\frac{S}{\sqrt{n}}t_{\frac{\alpha}{2}}(n-1), \bar{X}+\frac{S}{\sqrt{n}}t_{\frac{\alpha}{2}}(n-1) \right)</script><h5 id="sigma-2-未知，-mu-未知时-sigma-2-的区间估计"><a href="#sigma-2-未知，-mu-未知时-sigma-2-的区间估计" class="headerlink" title="$\sigma^2$未知，$\mu$未知时$\sigma^2$的区间估计"></a>$\sigma^2$未知，$\mu$未知时$\sigma^2$的区间估计</h5><p>这时要选去的枢轴量为</p><script type="math/tex; mode=display">\frac{(n-1)S^2}{\sigma^2} \sim \mathcal{X}^2(n-1)</script><p>因此有</p><script type="math/tex; mode=display">P\left\{ \mathcal{X}^2_{1-\frac{\alpha}{2}}(n-1)<\frac{(n-1)S^2}{\sigma^2}<\mathcal{X}^2_{\frac{\alpha}{2}}(n-1) \right\} = 1-\alpha</script><p>整理得到$\sigma^2$的一个置信水平为$1-\alpha$的置信区间</p><script type="math/tex; mode=display">\left( \frac{(n-1)S^2}{\mathcal{X}^2_{\frac{\alpha}{2}}(n-1)}, \frac{(n-1)S^2}{\mathcal{X}^2_{1-\frac{\alpha}{2}}(n-1)} \right)</script><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><h5 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h5><p>设总体$X$的概率密度函数为</p><script type="math/tex; mode=display">f(x;\theta) = \begin{cases} (\theta+1)x^{\theta}, \ &0<x<1 \\ 0 & 其他 \end{cases}</script><p>其中$\theta&gt;-1$，若$X_1,X_2,\dots,X_n$为来自总体$X$的样本，求参数$\theta$的矩估计和极大似然估计。</p><p>解析：</p><p>对于矩估计，求出</p><script type="math/tex; mode=display">E(X) = \int_0^1x(\theta+1)x^{\theta}dx=\frac{\theta+1}{\theta+2}</script><p>由$A_1=E(X)$，得</p><script type="math/tex; mode=display">\theta = -\frac{1}{A_1-1} - 2 = \frac{\displaystyle 1}{\displaystyle \frac{1}{n}\sum_{i=1}^nX_i-1} - 2</script><p>对于极大似然估计，</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^nf(x_i;\theta) = \begin{cases} \displaystyle \prod_{i=1}^n(\theta+1)x_i^{\theta}, \ & 0<x_{(1)}<x_{(n)}<1 \\ 0, &其他 \end{cases}</script><p>因此，当$0&lt;x_{(1)}&lt;x_{(n)}&lt;1$时，对数似然函数为</p><script type="math/tex; mode=display">\ln L(\theta) = \displaystyle \theta\sum_{i=1}^n\ln x_i+n\ln(\theta+1)</script><p>令</p><script type="math/tex; mode=display">\frac{\partial \ln L(\theta)}{\partial \theta} = \sum_{i=1}^{\theta}\ln x_i + \frac{n}{\theta+1} = 0</script><p>得</p><script type="math/tex; mode=display">\hat{\theta} = -\frac{n}{\displaystyle \sum_{i=1}^n\ln x_i} - 1</script><h5 id="区间估计-1"><a href="#区间估计-1" class="headerlink" title="区间估计"></a>区间估计</h5><p>设一次考试的成绩服从正态分布$\mathcal{N}(\mu,\sigma^2)$，其中$\mu,\sigma^2$均未知，现从中随机抽取256个考生的成绩，测得样本均值$\bar{x}=60$，样本标准差$s=16$，求$\mu$的置信度为0.90的置信区间。</p><p>解析：</p><p>由于需要求出$\mu,\sigma^2$均未知时$\mu$的置信区间，因此选取枢轴量为</p><script type="math/tex; mode=display">\frac{\bar{X}-\mu}{S/\sqrt{n}} \sim t(n-1), n=256</script><p>由置信水平$1-\alpha=0.9$得$\alpha=0.1$，同时根据上侧$\alpha$分位数，得</p><script type="math/tex; mode=display">P\left\{ \left| \frac{\bar{x}-\mu}{s/\sqrt{n}} \right| < t_{\frac{\alpha}{2}}(n-1) \right \} = 1-\alpha</script><p>将左侧不等式进行整理，即可得到</p><script type="math/tex; mode=display">P\left\{ \bar{x}-\frac{s}{\sqrt{n}}t_{\frac{\alpha}{2}}(n-1) < \mu < \bar{x}+\frac{s}{\sqrt{n}}t_{\frac{\alpha}{2}}(n-1) \right\} = 0.9</script><p>置信区间为</p><script type="math/tex; mode=display">\left( \bar{x}-\frac{s}{\sqrt{n}}t_{\frac{\alpha}{2}}(n-1), \bar{x}+\frac{s}{\sqrt{n}}t_{\frac{\alpha}{2}}(n-1) \right)</script><p>代入$\bar{x}=60,s=16,n=256,\alpha=0.1$得到最终结果</p><script type="math/tex; mode=display">(60-t_{0.05}(255),60+t_{0.05}(255))</script><blockquote><p>区间估计是后面假设检验的重要前导知识，必须掌握。</p></blockquote><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><p>先来看一种假设检验问题的基本表述：</p><p>在显著性水平$\alpha$下，检验假设</p><script type="math/tex; mode=display">H_0:\mu=\mu_0, \ H_1:\mu\ne\mu_0.</script><p>也即“在显著性水平$\alpha$下，针对$H_1$检验$H_0$”。其中，<strong>$H_0$称为原假设，$H_1$称为备择假设</strong>。和区间估计中类似地，我们也需要选取一个统计量来帮助我们对假设进行检验，这样的统计量被称为<strong>检验统计量</strong>。而检验统计量的一旦落入某个区域$C$时，就可以拒绝原假设$H_0$，这样的区域$C$称为<strong>拒绝域</strong>。</p><p>另外，注意到，备择假设中的$\mu&gt;0,\mu&lt;0$均可能成立，因此上面这种形式的假设检验被称为<strong>双边假设检验</strong>。我们选取的检验统计量为</p><script type="math/tex; mode=display">Z=\frac{\bar{X}-\mu}{\sigma/\sqrt{n}} \sim \mathcal{N}(0,1)</script><p>显著性水平为$\alpha$时，拒绝域为</p><script type="math/tex; mode=display">|z| = \left| \frac{\bar{x}-\mu_0}{\sigma/\sqrt{n}} \right| \geqslant z_{\frac{\alpha}{2}}</script><p>当然，与之相对地，还有<strong>左边检验</strong>和<strong>右边检验</strong>，分别为</p><script type="math/tex; mode=display">H_0:\mu\geqslant \mu_0, \ H_1:\mu<\mu_0</script><p>和</p><script type="math/tex; mode=display">H_0:\mu \leqslant \mu_0,\ H_1:\mu>\mu_0</script><p>与区间估计类似</p><ul><li>检验$\mu$，若$\sigma^2$已知，进行Z检验，选取检验统计量$\displaystyle Z=\frac{\bar{X}-\mu_0}{\sigma/\sqrt{n}} \stackrel{H_0为真}\sim \mathcal{N}(0,1)$</li><li>检验$\mu$，若$\sigma^2$未知，进行t检验，选取检验统计量$\displaystyle t=\frac{\bar{X}-\mu_0}{S/\sqrt{n}} \stackrel{H_0为真} \sim t(n-1)$</li><li>检验$\sigma^2$，若$\mu$未知，进行$\mathcal{X}$检验，选取检验统计量$\displaystyle \mathcal{X}^2=\frac{(n-1)S^2}{\sigma_0^2} \stackrel{H_0为真}\sim \mathcal{X}^2(n-1)$</li></ul><p>常见的假设检验置信区间以及单侧置信上下限如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230821174524244.png" alt="假设检验，置信区间"></p>]]></content>
      
      
      <categories>
          
          <category> 基础数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生的基本素养之线性代数</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/15/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%E4%B9%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/15/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB%E4%B9%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p> 对于包括计算机专业在内的理工科而言，线性代数是一门非常重要的数学基础课。本文立足于申请研究生笔试、面试等等考核，从本科生角度，将《线性代数》这门课中常见的重要知识点做以简单的记录。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="行列式与矩阵基础知识"><a href="#行列式与矩阵基础知识" class="headerlink" title="行列式与矩阵基础知识"></a>行列式与矩阵基础知识</h3><ol><li><p>计算3行3列行列式</p><script type="math/tex; mode=display">\left | \begin{array}{c} a_{11} & a_{12} & a_{13} \\ b_{11} & b_{12} & b_{13} \\ c_{11} & c_{12} & c_{13} \end{array} \right | = a_{11}b_{12}c_{13} + a_{12}b_{13}c_{11} + a_{13}b_{11}c_{12} - a_{13}b_{12}c_{11} - a_{11}b_{13}c_{12} - a_{12}b_{11}c_{13}</script></li><li><p>计算矩阵的逆</p><p>请注意，一般来说，只有方阵才可能有逆。对于方阵$A$，我们通常将它和同阶单位阵$I$横向拼接排列写在一起：$A|I$，然后对整体做初等行变换，直至左边的方阵变为单位阵，此时结果为：$I|B$，那么有$A^{-1}=B$。</p></li><li><p>矩阵可逆的充要条件</p><p>线性代数中，对于方阵$A$，$A$可逆的充要条件包括：</p><ol><li>方阵$A$可逆</li><li>方阵$A$的行列式不为零（非奇异矩阵）</li><li>$A$所有的特征值非零</li><li>$A$所有的列向量线性无关</li><li>$A$满秩</li><li>$A$可以表示为若干初等矩阵的乘积</li></ol></li></ol><h3 id="n维向量"><a href="#n维向量" class="headerlink" title="n维向量"></a>n维向量</h3><p><strong>线性相关和线性无关的概念一定要明确！</strong></p><ol><li><p><strong>线性相关</strong>：对于给定的一组n个向量$\mathbf{v}_1, \mathbf{v}_2, \cdots, \mathbf{v}_n$，若存在n个不全为零的实数$\lambda_1,\lambda_2,\cdots,\lambda_n$，使得它们与n个向量的线性组合$\displaystyle \sum_{i=1}^N\lambda_i\mathbf{v}_i$等于零，则称这n个向量线性相关；否则称它们<strong>线性无关</strong>。</p></li><li><p>向量范数问题：对于给定的n维向量$\mathbf{v}=[v_1,v_2,\cdots, v_n]$</p><ul><li>一范数：$\displaystyle ||\mathbf{v}||_1 = \sum_{i=1}^n |v_i|$</li><li>二范数：$\displaystyle ||\mathbf{v}||_2 = \sqrt{\sum_{i=1}^nv_i^2} $</li><li>$\infty$范数：$||\mathbf{v}||_\infty = \max |v_i|$</li><li>p范数：$\displaystyle ||\mathbf{v}||_p = \left( \sum_{i=1}^nv_i^2 \right)^{\frac{1}{p}}$</li></ul></li><li><p>标准正交基的概念。</p><p>基指的是满足如下条件的最少向量集合：在向量空间中任取一个其他的向量，它连同该向量集合中的向量都是线性相关的。</p><p>而标准正交基指的就是模长为1，且两两正交的一组基。</p></li></ol><h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><ol><li>对于线性方程组$AX=b$，称n阶方阵$A$为系数矩阵，$[A|b]$为增广矩阵：<ol><li>若$r(A)=r(A|b)=n$，则方程组有唯一解；</li><li>若$r(A)=r(A|b)&lt;n$，则方程组有无穷解；</li><li>若$r(A) \ne r(A|b)$，则方程组无解</li></ol></li></ol><p>通过具体的实例体会本章知识点。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="解非齐次线性方程组"><a href="#解非齐次线性方程组" class="headerlink" title="解非齐次线性方程组"></a>解非齐次线性方程组</h5><p>解下面的非齐次线性方程组。</p><script type="math/tex; mode=display">\begin{cases} x_1+5x_2-x_3-x_4=-1 \\ x_1-2x_2+x_3+3x_4=3 \\ 3x_1+8x_2-x_3+x_4=1 \\ x_1-9x_2+3x_3+7x_4=7 \end{cases}</script><p>第一步，写出线性方程组的增广矩阵。</p><script type="math/tex; mode=display">[A|b]=\left [ \begin{array}{c} 1 & 5 & -1 & -1 & -1 \\ 1 & -2 & 1 & 3 & 3 \\ 3 & 8 & -1 & 1 & 1 \\ 1 & -9 & 3 & 7 & 7 \end{array} \right ]</script><p>第二步，将增广矩阵化简为行阶梯矩阵。</p><script type="math/tex; mode=display">\begin{aligned} (A|b) &= \left[ \begin{array}{c} 3 & 8 & -1 & 1 & 1 \\ 1 & 5 & -1 & -1 & -1 \\ 1 & -2 & 1 & 3 & 3 \\ 1 & -9 & 3 & 7 & 7 \end{array}\right] \\ &\to \left[\begin{array}{c} 3 & 8 & -1 & 1 & 1 \\ 1 & 5 & -1 & -1 & -1 \\ 1 & -2 & 1 & 3 & 3 \\ 0 & -7 & 2 & 4 & 4 \end{array}\right] \\ &\to \left[\begin{array}{c} 3 & 8 & -1 & 1 & 1 \\ 1 & 5 & -1 & -1 & -1 \\ 0 & -7 & 2 & 4 & 4 \\ 0 & -7 & 2 & 4 & 4 \end{array}\right] \\ &\to \left[\begin{array}{c} 1 & 5 & -1 & -1 & -1 \\ 0 & -7 & 2 & 4 & 4 \\ 0 & -7 & 2 & 4 & 4 \\ 0 & -7 & 2 & 4 & 4 \end{array}\right]  \\ &\to \left[\begin{array}{c} 1 & 5 & -1 & -1 & -1 \\ 0 & -7 & 2 & 4 & 4 \\ 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 \end{array}\right]\end{aligned}</script><p>第三步，判断增广矩阵的秩并求解。</p><script type="math/tex; mode=display">r(A|b) = r(A) < 4</script><p>因此方程组有无穷解。</p><p>根据行阶梯矩阵，我们得到</p><script type="math/tex; mode=display">\begin{cases} x_1+5x_2-x_3-x_4&=-1 \\ -7x_2+2x_3+4x_4&=4 \end{cases}</script><p>接下来展示两种求解方法。</p><p>第一种，先求齐次方程组通解，再求非齐次方程组特解，组合得到最终解。不妨将$x_3,x_4$看作两个自由元，分别令$x_3=0,x_4=1$以及$x_3=1,x_4=0$，可以得到</p><script type="math/tex; mode=display">\xi_1=\left(-\frac{13}{7}, \frac{4}{7}, 0, 1\right)^T, \xi_2=\left( -\frac{3}{7},\frac{2}{7},1,0 \right)^T</script><p>令自由元$x_3=x_4=0$，得到一个特解</p><script type="math/tex; mode=display">\xi_0=\left( \frac{13}{7}, -\frac{4}{7}, 0, 0 \right)^T</script><p>因此，最终的解形式为</p><script type="math/tex; mode=display">\mathbf{x}=\xi_0+k_1\xi_1+k_2\xi_2</script><p>第二种方法，思考起来、写起来更加简洁，那便是直接用自由元$x_3,x_4$表示出主元$x_1,x_2$：</p><script type="math/tex; mode=display">\begin{cases} \displaystyle x_1 = -\frac{3}{7}x_3-\frac{13}{7}x_4+\frac{13}{7} \\ \displaystyle x_2 = \frac{2}{7}x_3+\frac{4}{7}x_4-\frac{4}{7} \end{cases}</script><p>因此，解可以写成</p><script type="math/tex; mode=display">\begin{aligned} \mathbf{x} &= (x_1,x_2,x_3,x_4)^T \\  &=\left(-\frac{3}{7}x_3-\frac{13}{7}x_4+\frac{13}{7}, \frac{2}{7}x_3+\frac{4}{7}x_4-\frac{4}{7}, x_3, x_4\right)^T \\ &= \left( -\frac{3}{7}, \frac{2}{7}, 1, 0 \right)^Tx_3 + \left( -\frac{13}{7}, \frac{4}{7}, 0, 1 \right)^Tx_4 + \left( \frac{13}{7}, -\frac{4}{7}, 0, 0 \right)^T \end{aligned}</script><h3 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h3><ol><li><p>特征值分解。</p><p>见例题，求特征值与特征向量。</p></li><li><p>代数重数和几何重数。</p><p>对方阵$A$做特征值分解时，计算出它的全部特征值。</p><ul><li>代数重数指的是特征方程根（特征值）的重数；</li><li>几何重数指的是单个特征值所对应的线性无关的特征向量的数目。</li></ul><p><strong>几何重数一定不大于代数重数</strong>。</p></li><li><p>矩阵相似</p><p>对于方阵$A$，若存在可逆矩阵$P$，使得$P^{-1}AP=B$，则称$A$与$B$相似，记作$A \sim B$。</p></li><li><p>矩阵合同</p><p>对于方阵$A$，若存在可逆矩阵$P$，使得$P^TAP=B$，则称$A$与$B$合同，记作$A \simeq B$。</p></li><li><p>矩阵对角化</p><p>对于方阵$A$，若有$A\sim \Lambda$，其中$\Lambda$为对角矩阵，则称$P^{-1}AP=\Lambda$这个转换过程为矩阵对角化。至于矩阵对角化的过程，详见下面的例题。</p></li><li><p>施密特正交化</p><p>给定一组向量$\alpha_1, \alpha_2, \cdots, \alpha_n$，要对其进行正交化，就需要用到<strong>施密特正交化</strong>：</p><ul><li>$\displaystyle \beta_1=\alpha_1$</li><li>$\displaystyle \beta_2 = \alpha_2 - \frac{(\alpha_2, \beta_1)}{(\beta_1, \beta_1)}\beta_1$</li><li>$\displaystyle \beta_3=\alpha_3 - \frac{(\alpha_3, \beta_1)}{(\beta_1, \beta_1)}\beta_1 - \frac{(\alpha_3, \beta_2)}{(\beta_2, \beta_2)}\beta_2$</li><li>$\dots$</li><li>$\displaystyle \beta_n = \alpha_n - \frac{(\alpha_n, \beta_1)}{(\beta_1, \beta_1)}\beta_1 - \frac{(\alpha_n, \beta_2)}{(\beta_2, \beta_2)}\beta_2 - \cdots - \frac{(\alpha_n, \beta_{n-1})}{(\beta_{n-1}, \beta_{n-1})}\beta_{n-1}$</li></ul><blockquote><p>向量$\mathbf{x}$与$\mathbf{w}$的内积$(\mathbf{x}, \mathbf{w}) = ||\mathbf{x}||_2·||\mathbf{w}||_2·\cos\theta$，而$(\mathbf{x},\mathbf{x})=||\mathbf{x}||_2·||\mathbf{x}||_2$，因此向量$\mathbf{x}$在$\mathbf{w}$上的投影长度为$\displaystyle ||\mathbf{Prj}_{\mathbf{w}}\mathbf{x}||_2 = ||\mathbf{x}||_2·\cos\theta $，而投影则表示为</p><script type="math/tex; mode=display">\mathbf{Prj_{\mathbf{w}}x} = \frac{||\mathbf{x}||_2·\cos\theta}{||\mathbf{w}||_2}\mathbf{w} = \frac{(\mathbf{x}, \mathbf{w})}{(\mathbf{w}, \mathbf{w})}\mathbf{w}</script><p>注意，此处的$||\mathbf{x}||_2$表示$\mathbf{x}$的二范数（即模长）。</p><p>因此，$\displaystyle \frac{(\alpha_i, \beta_j)}{(\beta_j, \beta_j)}\beta_j$表示向量$\alpha_i$在$\beta_j$上的投影，进一步地，$\displaystyle \alpha_i - \frac{(\alpha_i, \beta_j)}{(\beta_j, \beta_j)}\beta_j$（比如下图中的虚线部分）则与$\beta_j$正交。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E6%8A%95%E5%BD%B1%E5%9B%BE%E7%A4%BA.png" alt="向量投影"></p></li><li><p>奇异值分解。</p><p>对于一般的m×n的矩阵A，无法进行特征值分解，但可以进行奇异值分解：</p><script type="math/tex; mode=display">A = U\Sigma V^T</script><ol><li>求$A^TA$的特征值和特征向量，拼接得到矩阵$V$</li><li>求$AA^T$的特征值和特征向量，拼接得到矩阵$U$</li><li>$\Sigma$主对角线上的元素称为奇异值$\sigma_i$，$\sigma_i = \sqrt{\lambda_i}$，其中$\lambda_i$为特征值</li></ol></li></ol><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="对角化过程"><a href="#对角化过程" class="headerlink" title="对角化过程"></a>对角化过程</h5><p>已知矩阵$A = \left[ \begin{array}{c} 0 &amp; 1 &amp; 1 &amp; -1 \\ 1 &amp; 0 &amp; -1 &amp; 1 \\ 1 &amp; -1 &amp; 0 &amp; 1 \\ -1 &amp; 1 &amp; 1 &amp; 0 \end{array} \right]$，求出正交矩阵$P$与对角矩阵$\Lambda$，使得$A=P^{-1}\Lambda P$。其中</p><p>解：</p><p>这种题目有一套完整的解题流程，按部就班即可。首先需要求出特征值；然后将特征值代入方程组，利用上一部分的知识点求出方程组的基础解系即为特征向量，然后对于几何重数大于1的特征值对应的特征向量，还需要对其进行施密特正交化；最后得到互相正交的特征向量后，再进行单位化，按列向量进行拼接即可得到正交矩阵$P$。</p><p>第一步，求特征值。即解方程组$A\mathbf{x}=\lambda \mathbf{x}$，稍作转化得到</p><script type="math/tex; mode=display">(A-\lambda I)\mathbf{x}=0</script><p>对于该齐次线性方程组，要想存在非零解，则系数矩阵$A-\lambda I$必然不满秩，进而有</p><script type="math/tex; mode=display">|A-\lambda I|=0</script><p>回到本题中，我们写出</p><script type="math/tex; mode=display">|A-\lambda I| = \left| \begin{array}{c} -\lambda & 1 & 1 & -1 \\ 1 & -\lambda & -1 & 1 \\ 1 & -1 & -\lambda & 1 \\ -1 & 1 & 1 & -\lambda \end{array} \right| = 0</script><p>化简得到</p><script type="math/tex; mode=display">(\lambda-1)^3(\lambda+3)=0</script><p>故特征值$\lambda_1=\lambda_2=\lambda_3=1,\lambda_4=-3$。</p><p>第二步，求出特征向量。</p><p>对于三重根$\lambda_1=\lambda_2=\lambda_3=1$，代入系数矩阵得</p><script type="math/tex; mode=display">A-\lambda I = \left[ \begin{array}{c} -1 & 1 & 1 & -1 \\ 1 & -1 & -1 & 1 \\ 1 & -1 & -1 & 1 \\ -1 & 1 & 1 & -1 \end{array} \right]</script><p>化为行阶梯矩阵为</p><script type="math/tex; mode=display">A-I = \left[ \begin{array}{c} 1 & -1 & -1 & 1 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{array} \right]</script><p>得到$x_1-x_2-x_3+x_4$，按照求方程组解的方法可以得到三个基础解系，它们就是$\lambda_1=\lambda_2=\lambda_3=1$对应的特征向量：</p><script type="math/tex; mode=display">\begin{cases} \xi_1=(1,1,0,0)^T \\ \xi_2=(1,0,1,0)^T \\ \xi_3=(-1,0,0,1)^T \end{cases}</script><p>对于一重根$\lambda_4=-3$，代入系数矩阵得到</p><script type="math/tex; mode=display">A-\lambda I = \left[ \begin{array}{c} 3 & 1 & 1 & -1 \\ 1 & 3 & -1 & 1 \\ 1 & -1 & 3 & 1 \\ -1 & 1 & 1 & 3 \end{array} \right]</script><p>化为行阶梯矩阵为</p><script type="math/tex; mode=display">A+3I = \left[ \begin{array}{c} 1 & 0 & 0 & -1 \\ 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 0 \end{array} \right]</script><p>自由元数量为1，不妨视$x_4$为自由元，得到通解</p><script type="math/tex; mode=display">\xi_4=(1, -1, -1, 1)^T</script><p>第三步，正交化。</p><p><strong>不同的特征值对应的特征向量必然正交</strong>。而特征值1对应的特征向量有三个，因此只需要对它们三个进行正交化即可。</p><p>待正交化的向量组为</p><script type="math/tex; mode=display">\begin{cases} \xi_1=(1,1,0,0)^T \\ \xi_2=(1,0,1,0)^T \\ \xi_3=(-1,0,0,1)^T \end{cases}</script><p>进行<strong>施密特正交化</strong>：</p><script type="math/tex; mode=display">\begin{cases} \displaystyle \beta_1 = \xi_1 = (1,1,0,0)^T \\ \displaystyle \beta_2 = \xi_2 - \frac{(\xi_2, \beta_1)}{(\beta_1,\beta_1)}\beta_1 = \left( \frac{1}{2}, -\frac{1}{2}, 1, 0 \right)^T \\ \displaystyle \beta_3 = \xi_3 - \frac{(\xi_3, \beta_1)}{(\beta_1, \beta_1)}\beta_1 - \frac{(\xi_3, \beta_2)}{\beta_2, \beta_2}\beta_2 = \left( -\frac{1}{3}, \frac{1}{3}, \frac{1}{3}, 1 \right)^T \end{cases}</script><p>第四步，单位化。</p><p>这一步很简单了，只需要对经过施密特正交化处理后的向量归一化为模长为1即可。</p><script type="math/tex; mode=display">\begin{cases}\displaystyle \eta_1 = \left(\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}, 0, 0\right)^T \\ \displaystyle \eta_2 = \left( \frac{1}{\sqrt{6}}, -\frac{1}{\sqrt{6}}, \frac{2}{\sqrt{6}}, 0 \right)^T \\ \displaystyle \eta_3 = \left( -\frac{1}{\sqrt{12}}, \frac{1}{\sqrt{12}}, \frac{1}{\sqrt{12}}, \frac{3}{\sqrt{12}} \right)^T \end{cases}</script><p>还需要对$\xi_4=(1, -1, -1, 1)^T$进行单位化：</p><script type="math/tex; mode=display">\eta_4 = \left( \frac{1}{2}, -\frac{1}{2}, -\frac{1}{2}, \frac{1}{2} \right)^T</script><p>第五步，写出最终答案。</p><p>求得正交矩阵</p><script type="math/tex; mode=display">\begin{aligned} P &= \left[ \begin{array}{c} \eta_1, \eta_2, \eta_3, \eta_4 \end{array} \right] \\ &= \left[ \begin{array}{c} \displaystyle \frac{1}{\sqrt{2}} & \displaystyle \frac{1}{\sqrt{6}} & \displaystyle -\frac{1}{\sqrt{12}} & \displaystyle \frac{1}{2} \\ \displaystyle \frac{1}{\sqrt{2}} & \displaystyle \frac{1}{\sqrt{6}} & \displaystyle \frac{1}{\sqrt{12}} & \displaystyle -\frac{1}{2} \\ \displaystyle 0 & \displaystyle \frac{2}{\sqrt{6}} & \displaystyle \frac{1}{\sqrt{12}} & \displaystyle -\frac{1}{2} \\ 0 & 0 & \displaystyle \frac{3}{\sqrt{12}} & \displaystyle \frac{1}{2} \end{array} \right] \end{aligned}</script><p>求得对角矩阵</p><script type="math/tex; mode=display">\begin{aligned} \Lambda &= \mathrm{diag}(\lambda_1, \lambda_2, \lambda_3, \lambda_4) \\ &= \left[ \begin{array}{c} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & -3 \end{array} \right] \end{aligned}</script><p>使得$A = P^{-1}\Lambda P = P^T\Lambda P$。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>解线性方程组：<a href="https://zhuanlan.zhihu.com/p/144538375">https://zhuanlan.zhihu.com/p/144538375</a></p><p>矩阵对角化：<a href="https://blog.csdn.net/compression/article/details/49180775">https://blog.csdn.net/compression/article/details/49180775</a></p><p>向量内积：<a href="https://zhuanlan.zhihu.com/p/157490048">https://zhuanlan.zhihu.com/p/157490048</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/14/%E5%A0%86/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/14/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>说白了，堆实际上就是一种数据结构，<strong>是一棵特殊的完全二叉树</strong>。相对于普通的完全二叉树而言，<strong>堆的特殊之处在于，其任意一个结点都比它的孩子结点大（此时称为大顶堆），或者都比孩子结点小（此时称为小顶堆）</strong>。</p><h2 id="初始建堆"><a href="#初始建堆" class="headerlink" title="初始建堆"></a>初始建堆</h2><p>如何构建一个堆？事实上，建立堆的过程，就是将一棵完全二叉树调整为堆的过程。不失一般性，接下来我们都以大顶堆为例进行说明。</p><p>要想得到这种“任意根结点比孩子结点大”的结构，我们需要<strong>按照根结点自底向上、自右向左的顺序，对该根结点所在的子树进行调整</strong>。比如下图展示的完全二叉树，我们现在将其调整为大顶堆。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%A0%86-%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.svg" alt="堆-调整之前"></p><ol><li><p>按照自底向上、自右向左的顺序，首先需要检查叶子结点，但是叶子结点没有孩子，因此它们必然满足要求；</p></li><li><p>比较“4-1”子树，根结点4确实大于孩子结点1，满足要求；</p></li><li><p>见上图紫色框部分，显然不满足要求，需要对其进行调整：选取两个孩子结点中较大者8，将其与根结点3进行交换，使其满足要求；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%A0%86-%E8%B0%83%E6%95%B4-1.svg" alt="堆-调整(6,8,4)"></p></li><li><p>接下来“25-20-12”满足要求，但是“6-8-4”不满足，同样对其进行调整为“8-6-4”；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%A0%86-%E8%B0%83%E6%95%B4-2.svg" alt="堆-调整(6,7,3)"></p></li><li><p>此时“6-7-3”不满足了，需要再次进行调整，一旦调整完成，以8为根结点的子树就是一个堆了；</p></li><li><p>接下来检查“18-8-25”，发现同样也需要进行调整，调整为“25-8-25”；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%A0%86-%E8%B0%83%E6%95%B4-2%20(1" alt="堆-调整(18,8,25)">.svg)</p></li><li><p>此时往下检查确保以25为根结点的子树构成堆，因此调整右子树“18-20-12”为“20-18-12”，调整完毕后，堆的建立就完成了。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%A0%86-%E8%B0%83%E6%95%B4-2%20(2" alt="堆-调整(18,20,12)">.svg)</p></li></ol><p>最终建立好的堆结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%A0%86-%E5%BB%BA%E7%AB%8B%E5%AE%8C%E6%AF%95.svg" alt="堆-建立完毕"></p><h3 id="调整子树为堆"><a href="#调整子树为堆" class="headerlink" title="调整子树为堆"></a>调整子树为堆</h3><p>通过上面的实例分析可以发现：</p><ol><li><strong>根结点的扫描是自底向上、自右向左的</strong>；</li><li><strong>获取到根结点之后，对其所在子树的调整是自上而下的</strong>；</li></ol><p>究其原因，是因为每一次对父子结点对进行检查时，<strong>至多交换一次，也就是说，至多会改变左子树、右子树中一棵子树的根，进而改变这棵子树的结构而导致它有可能不再满足堆的特性</strong>。因此需要进一步对这棵子树进行调整，不断地以此类推，就是一个自顶向下的迭代过程。我们把这个过程用代码实现出来，根结点不妨用结点索引from表示。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void downAdjust(int from, int to) &#123;    &#x2F;&#x2F; 对[from, to]范围内的结点进行调整，to通常是完全二叉树的最后一个结点索引    int i &#x3D; from, j &#x3D; 2 * from; &#x2F;&#x2F; 记录根结点以及其左孩子    while(j &lt;&#x3D; to) &#123;        &#x2F;&#x2F; 左孩子存在        if(j + 1 &lt;&#x3D; to &amp;&amp; heap[j+1] &gt; heap[j]) &#123;            &#x2F;&#x2F; 右孩子也存在且右孩子大于左孩子            j &#x3D; j + 1;        &#125;        if(heap[j] &gt; heap[i]) &#123;            &#x2F;&#x2F; j记录的是左右孩子中的较大者索引，将其与父亲结点交换            swap(heap[i], heap[j]);            &#x2F;&#x2F; 接下来需要对与父亲结点进行交换的孩子结点（即索引j）所在子树进行调整            i &#x3D; j;            j &#x3D; 2 * i;        &#125; elsebreak; &#x2F;&#x2F; 满足堆的性质，无需任何调整    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>接下来实现第一条“<strong>根结点的扫描是自底向上、自右向左的</strong>”，即可完成建堆。<strong>在结点数量为$n$的完全二叉树中，叶子结点数量为$\displaystyle \lceil \frac{n}{2} \rceil$</strong>，因此范围在$\displaystyle \left[1, \lfloor \frac{n}{2} \rfloor\right]$的结点均为非叶子结点。我们倒着遍历进行调整即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void createHeap(int n) &#123;    int i;    for(i&#x3D;n&#x2F;2; i; i--) &#123;        downAdjust(i, n);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>回到上面的建堆过程分析中来。显然，每次建立好堆之后，完全二叉树中的最大结点正是根结点，换言之，我们选出了最大结点。<strong>那么我们是不是就可以通过每次将完全二叉树调整为堆，得到最大结点，然后将其与完全二叉树中乱序部分的最后一个元素互换，这样不断地从剩余乱序元素中选出最大值放到后面，从而完成排序呢？</strong></p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>我们以一个具体的例子来说明堆排序的过程。首先初始的乱序序列为[25, 8, 20, 7, 4, 18, 12, 6, 3, 14]，我们需要将其按非递减顺序排序。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%BE%85%E6%8E%92%E5%BA%8F%E5%BA%8F%E5%88%97-%E6%9C%80%E6%96%B0.svg" alt="待排序序列"></p><ol><li><p>第一步需要将完全二叉树建成堆，事实上初始情况正是上一部分建堆的结果，已经是堆结构了，因此可以跳过；</p></li><li><p>此时根结点就是待排序部分的最大元素，于是将其与待排序部分的末位元素互换，最后一个元素位置固定了，待排序序列长度减一，见下图；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D1%E4%B8%AA%E5%85%83%E7%B4%A0.svg" alt="已就位1个元素"></p></li><li><p>接下来对$[1,n-1]$范围内的结点调整为大顶堆，以选出最大结点，调整后的结构见下图；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D1%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位1个元素，已调整"></p></li><li><p>同2，将根结点与待排序部分末位元素互换，见下图；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D2%E4%B8%AA%E5%85%83%E7%B4%A0.svg" alt="已就位2个元素"></p></li><li><p>同3，对$[1,n-2]$范围内的结点调整为大顶堆，以选出最大结点，调整后的结构见下图；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D2%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位2个元素，已调整"></p></li><li><p>以此类推，接下来每一步给出选出最大结点并重新调整为堆的结果图；</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D3%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位3个元素，已调整"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D4%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位4个元素-已调整"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D5%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位5个元素，已调整"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D6%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位6个元素-已调整"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D7%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位7个元素-已调整"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D8%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位8个元素，已调整"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%B2%E5%B0%B1%E4%BD%8D9%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%B7%B2%E8%B0%83%E6%95%B4.svg" alt="已就位9个元素，已调整"></p></li><li><p>此时只剩下一个元素，排序也就完成了。</p></li></ol><p>上述过程便是堆排序的完整可视化排序过程。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在理解并实现了自上而下调整为堆的过程和函数<code>downAdjust()</code>后，堆排序的实现也就迎刃而解了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void heapSort(int n) &#123;    createHeap(n); &#x2F;&#x2F; 初始建堆    int i;    for(i&#x3D;n; i&gt;1; i--) &#123;        &#x2F;&#x2F; 每次选出当前堆顶最大结点与未排序部分末位元素i互换（而导致有序），故未排序末位元素索引变为i-1        swap(heap[1], heap[i]);        downAdjust(1, i-1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分析到这里，我们可以发现，事实上，堆排序的本质是一个<strong>“选择排序”</strong>——只不过相比于朴素的选择排序，堆排序借助了树形结构的堆来选出当前元素的最大者/最小者，以提高效率。由于每次调整的时间复杂度为$\mathcal{O}(\log n)$，而需要进行$n-1$次调整，故堆排序的时间复杂度为$\mathcal{O}(n\log n)$。</p><p>再看看它的空间复杂度，堆排序基本上没有借助额外的存储空间，因此空间复杂度为$\mathcal{O}(1)$。</p><p>最后看看它的稳定性。<strong>堆排序是不稳定的</strong>，因为本质上堆排序属于“选择排序”，且调整堆结构时，父子结点之间会进行换位。正是这种换位，会破坏排序算法的稳定性。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void downAdjust(int from, int to) &#123;    &#x2F;&#x2F; 对[from, to]范围内的结点进行调整，to通常是完全二叉树的最后一个结点索引    int i &#x3D; from, j &#x3D; 2 * from; &#x2F;&#x2F; 记录根结点以及其左孩子    while(j &lt;&#x3D; to) &#123;        &#x2F;&#x2F; 左孩子存在        if(j + 1 &lt;&#x3D; to &amp;&amp; heap[j+1] &gt; heap[j]) &#123;            &#x2F;&#x2F; 右孩子也存在且右孩子大于左孩子            j &#x3D; j + 1;        &#125;        if(heap[j] &gt; heap[i]) &#123;            &#x2F;&#x2F; j记录的是左右孩子中的较大者索引，将其与父亲结点交换            swap(heap[i], heap[j]);            &#x2F;&#x2F; 接下来需要对与父亲结点进行交换的孩子结点（即索引j）所在子树进行调整            i &#x3D; j;            j &#x3D; 2 * i;        &#125; elsebreak; &#x2F;&#x2F; 满足堆的性质，无需任何调整    &#125;&#125;void createHeap(int n) &#123;    &#x2F;&#x2F; 建立堆    int i;    for(i&#x3D;n&#x2F;2; i; i--) &#123;        downAdjust(i, n);    &#125;&#125;void heapSort(int n) &#123;    &#x2F;&#x2F; 堆排序    createHeap(n); &#x2F;&#x2F; 初始建堆    int i;    for(i&#x3D;n; i&gt;1; i--) &#123;        &#x2F;&#x2F; 每次选出当前堆顶最大结点与未排序部分末位元素i互换（而导致有序），故未排序末位元素索引变为i-1        swap(heap[1], heap[i]);        downAdjust(1, i-1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并查集是一种特殊的数据结构，用于处理不相交集合的查询问题。实际上包含了三个操作：</p><ul><li>合并：将不相交的两个集合<strong>合并</strong>为同一个集合</li><li>查找：查找元素所在的集合</li></ul><h2 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h2><p>本文主要介绍并查集的算法模板。我们从并查集的常见操作入手，看看它的算法思想。</p><h3 id="mathrm-father-数组"><a href="#mathrm-father-数组" class="headerlink" title="$\mathrm{father[]}数组$"></a>$\mathrm{father[]}数组$</h3><p>在并查集中，我们通过维护一个保存当前元素父亲的数组<code>father</code>，来实现将属于不同集合的元素划分开。</p><p>比如，给定6个元素，它们的<code>father</code>数组为：<code>father[6] = &#123;0, 0, 0, 2, 4, 4&#125;</code>，对应的元素分布情况见下图。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/father%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB-16918177656861.png" alt="father数组表示的集合关系"></p><p>显然，这样表示下的集合总有一个“根结点”，且对于任意根结点$i$，它满足关系$\mathrm{father[i]=i}$。那么接下来我们来实现如何查找当前根结点。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找根结点，其实也就是不断地找父结点的父结点，直到满足了“父结点就是自己”这一终止条件。因此，我们可以使用递归很简单地实现。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x) &#123;    &#x2F;*功能：查找结点x所在集合的根*&#x2F;    if(x &#x3D;&#x3D; father[x])return x; &#x2F;&#x2F; 终止条件：x就是根结点，直接返回    return Find(father[x]); &#x2F;&#x2F; 递归：找父结点的父结点&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>我们在平衡二叉树的引入中曾经提过，由于普通的二叉查找树可能由于呈现链状而使得查询效率变得很低；事实上，此处的并查集也可能出现类似的问题：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\并查集.assets\链式并查集.png" alt="链式形状会降低查询效率"></p><p>比如上图中，我们要查询5号的根结点，就需要调用<code>Find(5)</code>，进而调用<code>Find(4)</code>、<code>Find(3)</code>、<code>Find(2)</code>、<code>Find(1)</code>、<code>Find(0)</code>，才终于找到根结点0并返回。</p><p>而与上图相比，下面的并查集结构要明显好得多！因为我们只需要$\mathcal{O}(1)$的时间就可以轻易查询到任意结点的根结点了。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84%E5%90%8E%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86.png" alt="压缩路径后的并查集"></p><p>我们把这种形态上的转变称作<strong>路径压缩</strong>。具体到代码实现方面，只需在查找函数<code>Find(x)</code>中，返回查找到的根结点<code>Find(father[x])</code>之前，将这个结果赋值给当前结点的父结点<code>father[x]</code>即可：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x) &#123;    if(x &#x3D;&#x3D; father[x])return x;    return father[x] &#x3D; Find(father[x]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此需要注意：<strong>我们是通过查找操作来顺便实现路径压缩的，也就意味着，如果进行了合并操作之后，并没有进行任何的查找操作，也就没有进行任何的路径压缩，此时不能直接通过<code>x == father[x]</code>是否成立来判断x是否属于<code>father[x]</code>为根结点的集合；换言之，<code>father[x]</code>有可能并不是x的真正的根结点！</strong>因此，只能通过<code>Find(x)</code>来获取x的根结点。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并操作也就是将两个不同的集合合并到一起。因此，我们只需将两个集合的“根结点”进行连接（令其中一个结点的父结点是另一个即可）。但是要注意，只能对不同的集合进行合并，如果是同一个集合，不能合并。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Union(int x, int y) &#123;    int px &#x3D; Find(x);    int py &#x3D; Find(y);    if(px !&#x3D; py)father[px] &#x3D; py;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寻找并查集中不同集合的个数"><a href="#寻找并查集中不同集合的个数" class="headerlink" title="寻找并查集中不同集合的个数"></a>寻找并查集中不同集合的个数</h3><p>注意，在实现并查集算法前，一定要对<code>father</code>数组进行初始化：初始状态每一个结点都是根结点（全部彼此不连通）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void init(int n) &#123;    int i;    for(i&#x3D;1; i&lt;&#x3D;n; i++)father[i] &#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完成所有的合并操作后，要求共有几个不同的集合，就直接寻找根结点的个数即可：有几个根，就有几个不同的集合。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i;int ans &#x3D; 0;for(i&#x3D;1; i&lt;&#x3D;n; i++) &#123;    if(father[i] &#x3D;&#x3D; i)ans++;&#125;&#x2F;&#x2F; ans 即为根结点数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/11/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/11/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道，一般来说，二叉查找树可以加快查找效率；但是如果一棵二叉查找树退化为了一根链（比如，除了叶子，每一个结点都只含有一个左孩子的树），查找起来也是相当的费劲，因为此时基本上就是遍历树中的每一个结点。这与我们使用树结构加快查找的初衷不符。<strong>事实上，我们正需要调整树的结构，使其成为平衡二叉树，这样查找起来效率较高。</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先介绍一个概念：<strong>平衡因子</strong>。它是<strong>针对某一个结点而言的，指的是该结点左子树高度与右子树高度的差</strong>。值得注意的是，这个差并不是数学中严格意义上的两数之差——这个差是可正可负的。不难理解，平衡因子为负，则表示右子树高度比左子树高度要大一些。</p><p>那么<strong>平衡二叉树指的是这样的一种二叉树：它的每一个结点的平衡因子绝对值都不大于1</strong>。也就是说，若二叉树中每一个结点的左子树、右子树高度之差为-1、0或者1时，这棵树就是平衡二叉树了。</p><p>当然，平衡二叉树其实是特殊的二叉查找树。因此从代码实现角度看，与一般的二叉树定义不同的是，平衡因子必须出现在定义中，这也是方便后续的插入调整等操作。而通常我们将结点所在子树的高度保存到结点定义之中：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct s &#123;    int val;    int height; &#x2F;&#x2F; 以当前结点为根的子树的高度；若为叶子则就是1    struct s* left;    struct s* right;&#125; Node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新高度"><a href="#更新高度" class="headerlink" title="更新高度"></a>更新高度</h2><p>既然平衡二叉树的定义中新增了<code>height</code>字段，因此在很多操作（如插入、建立等）中就会频繁地出现高度的更新且其不可或缺。由于插入操作是递归形式实现，因此我们定义的更新高度函数只需要简单的更新取该结点左子树和右子树高度较大值，加上1即可。然后这个操作会不断地随着递归的结束，自底向上的调用，从而保证了整棵树所有结点高度的更新。</p><p>注意，这里单独实现了获取结点高度的函数<code>getHeight(Node* node)</code>，是因为考虑结点为NULL的特殊情况，方便后续代码编写。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getHeight(Node* node) &#123;    if(node &#x3D;&#x3D; NULL)return 0;    return node-&gt;height;&#125;void updateHeight(Node* root) &#123;    root-&gt;height &#x3D; 1 + max(getHeight(root-&gt;left), getHeight(root-&gt;right));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>平衡二叉树最常见的知识点是插入操作。本文重点记录如何对平衡二叉树进行插入。显然，平衡二叉树其实是特殊的二叉查找树，每插入一个结点，就有可能“打破平衡”。因此关键在于，如何将这种非平衡的二叉树调整为平衡二叉树。</p><h3 id="左旋、右旋"><a href="#左旋、右旋" class="headerlink" title="左旋、右旋"></a>左旋、右旋</h3><p>在正式介绍如何调整之前，我们来看如何调整当前的根结点。以下图为例，现在希望将根结点调整为$R’$，如何做？</p><p>为了有一个形象化的表述将整个调整过程描述出来，我们将$R$称为当前根结点（但是很快他就不是了），将$R’$称为新任根结点（他马上就是了），旧领导离任、新领导上任，是不是得有一套交接手续，才能完成权利的更迭？不妨按照这个路子理解接下来的调整过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%B7%A6%E6%97%8B.png" alt="左旋"></p><p>图中，云朵形框表示一棵子树结构，圆形框表示一个具体的结点；按照上图从左至右的顺序依次为：</p><ol><li>【旧任领导即将下台，新任领导即将上台】选中当前根结点和它的右结点；</li><li>【旧任领导为下台做准备，接手新任领导手下的工作】当前根结点的右孩子指向它原先右孩子的左孩子；</li><li>【新任领导为上台做准备，开始管理旧任领导】当前根结点成为其原先的右孩子的左孩子</li><li>【交接完毕，权利更迭完成】原先的右孩子成为当前的最新根结点</li></ol><p><strong>这个调整过程，称为左旋</strong>。代码也很简单明了。只不过<strong>需要注意，在完成树中结点指针域的指向调整后，需要立即更新其高度（也就是当前根结点$R$和新任根结点$R’$，具体的更新操作前文已经有过说明）</strong>：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void leftRotate(Node* &amp;root) &#123;    Node* temp &#x3D; root-&gt;right;    root-&gt;right &#x3D; temp-&gt;left;    temp-&gt;left &#x3D; root;    updateHeight(temp);    updateHeight(root);    root &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与之相对地，是<strong>右旋</strong>操作。这是两个对称的操作过程，不再赘述。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%8F%B3%E6%97%8B.png" alt="右旋"></p><p>右旋代码如下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void rightRotate(Node* &amp;root) &#123;    Node* temp &#x3D; root-&gt;left;    root-&gt;left &#x3D; temp-&gt;right;    temp-&gt;right &#x3D; root;    updateHeight(temp);    updateHeight(root);    root &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四种树型"><a href="#四种树型" class="headerlink" title="四种树型"></a>四种树型</h3><p>有了上面的左旋、右旋基本操作后，接下来我们来看看针对几种不同的非平衡二叉树结构，该如何调整树型。</p><p>我们从根结点平衡因子角度考虑，当插入一个结点而导致树失衡时，一定导致某（几）个结点的平衡因子为2或者-2。不妨考虑平衡因子为2的情况，此时，以该结点为根的子树结构还可能有下面两种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/LL%E4%B8%8ELR%E5%9E%8B.png" alt="LL与LR型"></p><p>方便起见，记根结点为$R_1$，图中标出平衡因子为1或者-1的结点为$R_2$（$R_1$的左孩子）</p><ul><li>对于上图左侧的LL型，处理方式比较简单，直接对$R_1$进行右旋即可，即调用<code>rightRotate(R_1)</code>；</li><li>对于右侧的LR型，则先对$R_1$的左孩子$R_2$进行左旋（此时忽略$R_1$），然后再对$R_1$进行右旋，即先调用<code>leftRotate(R_1-&gt;left)</code>，再调用<code>rightRotate(R_1)</code>。</li></ul><p>根结点平衡因子为-2的情况与上面的情况对称，类似的有RR、RL型：</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/RR%E4%B8%8ERL%E5%9E%8B.png" alt="RR与RL型"></p><p>它们的调整方式不难推导出：</p><ul><li>对于RR型，直接对根结点$R_1$进行左旋，即调用<code>leftRotate(R_1)</code>；</li><li>对于RL型，则先对根结点的右孩子$R_2$进行右旋（此时忽略根结点），然后再对根结点$R_1$进行左旋，即先调用<code>rightRotate(R_1-&gt;right)</code>，再调用<code>leftRotate(R_1)</code>。</li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>当然，目前我们已经知晓了几种不同失衡情况下的调整方法。那么，如何判断发生了失衡呢？很简单，只需要判断根结点的平衡因子是否为2或者-2，如果是则进一步判断其左孩子或者右孩子的平衡因子是否为1或者-1即可。于是，我们在写出完整的平衡二叉树插入结点之前，还需要编写获取某结点平衡因子的函数<code>getBalancedFactor(Node* node)</code>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getBalancedFactor(Node* node) &#123;    &#x2F;&#x2F; 保证node不为NULL    return getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>插入操作的完整代码，可以看作在普通的二叉查找树上进行插入的代码基础上，进行了一番添加（毕竟二叉平衡树是特殊的二叉查找树）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct s &#123;int val, height;struct s* left;struct s* right;&#125; Node;int getHeight(Node* root) &#123;if(root &#x3D;&#x3D; NULL)return 0;return root-&gt;height;&#125;void updateHeight(Node* root) &#123;root-&gt;height &#x3D; 1 + max(getHeight(root-&gt;left), getHeight(root-&gt;right));&#125;void leftRotate(Node* &amp;root) &#123;&#x2F;&#x2F; 左旋root，当前根结点的右孩子为新任根结点 Node* rchild &#x3D; root-&gt;right;root-&gt;right &#x3D; rchild-&gt;left; &#x2F;&#x2F; 当前根结点右孩子改为新任根结点的左孩子 rchild-&gt;left &#x3D; root; &#x2F;&#x2F; 新任根结点的左孩子改为当前根结点 updateHeight(root);updateHeight(rchild);root &#x3D; rchild; &#x2F;&#x2F; 新任根结点正式成为根结点 &#125;void rightRotate(Node* &amp;root) &#123;&#x2F;&#x2F; 右旋root，当前根结点的左孩子为新任根结点Node* lchild &#x3D; root-&gt;left;root-&gt;left &#x3D; lchild-&gt;right;lchild-&gt;right &#x3D; root;updateHeight(root);updateHeight(lchild);root &#x3D; lchild; &#125;int getBalancedFactor(Node* root) &#123;return getHeight(root-&gt;left) - getHeight(root-&gt;right);&#125;void insertNode(Node* &amp;root, int val) &#123;if(root &#x3D;&#x3D; NULL) &#123;Node* newNode &#x3D; new Node();newNode-&gt;val &#x3D; val;newNode-&gt;height &#x3D; 1;newNode-&gt;left &#x3D; newNode-&gt;right &#x3D; NULL;root &#x3D; newNode;&#x2F;&#x2F;cout&lt;&lt;newNode-&gt;val&lt;&lt;&quot; &quot;;return;&#125;if(val &lt; root-&gt;val) &#123;        &#x2F;&#x2F; 往左子树插入结点，此时根结点平衡因子可能为2（不可能为-2）insertNode(root-&gt;left, val);        &#x2F;&#x2F; 插入结点完成后，需要对当前的子树高度进行更新、调整（如果它不是平衡二叉树的话）；注意这是一个递归的过程，将随着递归的结束自底向上不断进行更新、调整，最终确保所有子树的高度正确无误、整棵树是平衡二叉树。updateHeight(root);        if(getBalancedFactor(root) &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F; 左子树更高if(getBalancedFactor(root-&gt;left) &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F; LLrightRotate(root);&#125; else if(getBalancedFactor(root-&gt;left) &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F; LRleftRotate(root-&gt;left);rightRotate(root);&#125;&#125;&#125; else &#123;insertNode(root-&gt;right, val);        &#x2F;&#x2F; 插入结点完成后，需要对当前的子树高度进行更新、调整（如果它不是平衡二叉树的话）；注意这是一个递归的过程，将随着递归的结束自底向上不断进行更新、调整，最终确保所有子树的高度正确无误、整棵树是平衡二叉树。updateHeight(root);if(getBalancedFactor(root) &#x3D;&#x3D; -2) &#123;            &#x2F;&#x2F; 往右子树插入结点，此时根结点平衡因子可能为-2（不可能为2）if(getBalancedFactor(root-&gt;right) &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F; RRleftRotate(root);&#125; else if(getBalancedFactor(root-&gt;right) &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F; RLrightRotate(root-&gt;right);leftRotate(root);&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/10/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/10/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有$n$件物品，每件物品的重量为$w_i$，价值为$c_i$。现在需要选出若干件物品放入一个容量为$V$的背包中（每件物品至多选一次），使得在选入背包的物品重量之和不超过容量$V$的前提下，让背包中物品的价值之和最大，求最大价值。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>一种暴力解法，每一件物品按照“选”“不选”进行分支，可以构建出一棵树；对这棵树进行搜索，求出所有情况的物品价值之和，取最大值。</p><p>这种做法时间复杂度很高。一种可能的优化方法是，先将物品按照重量进行非递减排序，然后依次考虑每一个物品的选取与否。如果选取了当前物品，而导致超出背包容量，那么当前分支可以被剪去（直接返回结果即可）——这样达到剪枝效果。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>0-1背包问题是一种非常经典的可以用动态规划求解的问题。对于给定的$n$个物品、总容量为$V$的背包情况下，我们定义一个数组$\mathrm{dp[n][V]}$，其中</p><script type="math/tex; mode=display">\mathrm{dp[i][w]}表示给定前i个物品、总容量为w的背包情况下的选取物品价值之和的最大值。</script><p>其中，$i\in \{0,1,\cdots,n-1\}, w\in \{0,1,\cdots,V\}$。</p><p>接下来考虑状态转移，也就是考虑第$i$个物品的选取问题：</p><ul><li>若不选第$i$个物品，那么显然有<script type="math/tex; mode=display">\mathrm{dp[i][w] = dp[i-1][w]}</script></li></ul><ul><li>若选第$i$个物品，就得确保考虑前$i-1$个物品的子问题时，还有足够的容量支持$w_i$放入，即<script type="math/tex; mode=display">\mathrm{dp[i][w] = dp[i-1][w-w_i] + c_i}</script></li></ul><p>综上，我们得到状态转移方程为</p><script type="math/tex; mode=display">\mathrm{dp[i][w] = \max \left\{ dp[i-1][w], dp[i-1][w-w_i]+c_i \right\}}</script><h2 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h2><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><blockquote><p>传送门：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p></blockquote><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个题其实可以这样理解：从一堆数字中选取若干个数字，使其和为指定的数（不妨记作target），那么我们可以将其转化为0-1背包问题，只不过这个问题中，每一个物品的重量和价值均相等。那么我们按照上述思路得到$\mathrm{dp}$数组后，只需判断$\mathrm{dp[n][V]}==V$是否成立即可。状态转移方程为</p><script type="math/tex; mode=display">\mathrm{dp[i][w] = \max \left\{ dp[i-1][w], dp[i-1][w-w_i]+w_i \right\}}</script>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leecode hot 10 正则表达式匹配</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>传送门：<a href="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两个字符串进行匹配，一个是主串，一个是模式串，如何匹配？和比较经典的最长递增子序列问题相似地，我们也可以采取动态规划的思想来解出此题。</p><p>对于给定的主串$s$，以及模式串$p$，它们的长度分别为$m,n$，我们定义一个数组$dp[m+1][n+1]$，其中$dp[i][j]$表示主串的前$i$个字符组成的子串和模式串的前$j$个字符组成的子串匹配，即$s[0:i]$和$p[0:j]$匹配。</p><blockquote><p>借助python包numpy写法，对于字符串str，$str[i:j]$表示截取字符串str的$[i,j)$区间子串。</p></blockquote><p>由此我们可以仿照“最大编辑距离”问题中的思考方式，考虑当前两个字符串的末尾字符，从而得出状态转移方程。</p><ol><li><p>若$p[j-1]=*$</p><p>这种情况稍显复杂。此时必须选取$p[i-2]$，看它是否和主串末尾字符匹配：</p><ol><li><p>若$p[j-2]=s[i-1]$</p><p>也就是说，主串末尾字符$s[i-1]$和模式串的$p[i-2:i]$（$x<em>$整体，$x$为普通字符）匹配上了。<em>*关键来了。这时，可以有三种方式继续将$s[0:i-1]$与模式串$p$进行匹配。</em></em></p><ul><li><p>保留$x*$整体，匹配$s[0:i-1]$与$p[0:j]$，即$dp[i-1][j]$</p><p>举个例子，如$\mathrm{abaaa}$与$\mathrm{aba*}$</p></li><li><p>舍弃$x*$整体，且舍弃刚刚的匹配策略，继续匹配$s[0:i]$与$p[0:j-2]$，即$dp[i][j-2]$</p><p>举个例子，如$\mathrm{abaaa}$与$\mathrm{abaaaa*}$</p></li><li><p>舍弃$x*$整体，但是采取刚刚的匹配策略，继续匹配$s[0:i-1]$与$p[0:j-2]$，即$dp[i-1][j-2]$</p><p>举个例子，如$\mathrm{abaaa}$与$\mathrm{abaaa*}$</p></li></ul></li><li><p>若$p[j-2]\ne s[i-1]$</p><p>这种情况较简单，此时要想匹配上，只能按$x<em>$中的$x$一次也不出现来算，且<em>*此时主串末尾字符$s[i-1]$</em></em>是没有匹配上的。因此接下来匹配$s[0:i]$与$p[0:j-2]$，即$dp[i][j-2]$</p></li></ol></li><li><p>若$p[j-1]\ne *$</p><p>这种情况最为简单，判断主串末位字符和模式串末位字符是否匹配（注意考虑通配符$.$），如果它们匹配，进一步判断主串的前$i-1$个字符子串和模式串的前$j-1$个字符子串是否匹配，描述为两个条件的交：$\mathrm{singleMatch(p[j-1],s[i-1])} \&amp;\&amp; dp[i-1][j-1]$</p></li></ol><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>综合得到状态转移方程：</p><p>$dp[i][j]=\begin{cases} \mathrm{singleMatch(p[j-1], s[i-1]) \&amp;\&amp;  dp[i-1][j-1]}, \quad p[j-1] \ne <em> \\\\ \mathrm{dp[i-1][j] || dp[i][j-2] || dp[i-1][j-2], \quad p[j-1]=</em> \&amp;\&amp; p[j-2]=s[i-1] } \\\\ \mathrm{dp[i][j-2],\quad otherwise}  \end{cases}$</p><h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><p>状态转移、边界条件是动态规划的关键。下面思考一下边界条件如何书写。以实际的例子进行说明：</p><ul><li><p>$m=n=0$时</p><p>此时字符串匹配成功，比较理想的情况，$dp[0][0]=1$</p></li><li><p>$m=0,n&gt;0$时</p><p>例如<code>&quot;&quot;</code>与<code>&quot;a*b*&quot;</code>、<code>&quot;&quot;</code>与<code>&quot;b*c&quot;</code>，事实上当$p[i-1]=*$时，有$dp[0][i]=dp[0][i-2]$（比如第一个例子$dp[0][0]=dp[0][2]=dp[0][4]=1$，细品）；其余情况匹配失败</p></li><li><p>$m&gt;0,n=0$时</p><p>例如<code>&quot;abac&quot;</code>与<code>&quot;&quot;</code>，此时必然匹配失败，$dp[i][0]=0$</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>采用自底向上的迭代写法，编写完整的动态规划代码如下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int dp[25][25];    bool isSingleMatch(char ch1, char ch2) &#123;        if(ch1 &#x3D;&#x3D; &#39;.&#39; || ch2 &#x3D;&#x3D; &#39;.&#39;)    return true;        return ch1 &#x3D;&#x3D; ch2;    &#125;    bool isMatch(string s, string p) &#123;        &#x2F;&#x2F; dp[i][j]表示s[0:i-1]是否匹配p[0:i-1]                &#x2F;&#x2F; 考虑边界        memset(dp, 0, sizeof(dp));        dp[0][0] &#x3D; 1;        int i, j;        &#x2F;&#x2F; s&#x3D;&quot;&quot; p&#x3D;&quot;a*b*ccd*&quot;        for(i&#x3D;1; i&lt;&#x3D;p.size(); i++) &#123;            if(p[i-1] &#x3D;&#x3D; &#39;*&#39;)   dp[0][i] &#x3D; dp[0][i-2];        &#125;        &#x2F;&#x2F; 迭代        for(i&#x3D;1; i&lt;&#x3D;s.size(); i++) &#123;            for(j&#x3D;1; j&lt;&#x3D;p.size(); j++) &#123;                if(p[j-1] &#x3D;&#x3D; &#39;*&#39;) &#123;                    if(isSingleMatch(p[j-2], s[i-1]))  dp[i][j] &#x3D; dp[i-1][j] || dp[i-1][j-2] || dp[i][j-2];                    else    dp[i][j] &#x3D; dp[i][j-2];                &#125; else &#123;                    dp[i][j] &#x3D; isSingleMatch(p[j-1], s[i-1]) &amp;&amp; dp[i-1][j-1];                &#125;            &#125;        &#125;        return dp[s.size()][p.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也可以编写自底向上的带备忘录式动态规划代码。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isSingleMatch(char ch1, char ch2) &#123;        if(ch1 &#x3D;&#x3D; &#39;.&#39; || ch2 &#x3D;&#x3D; &#39;.&#39;)    return true;        return ch1 &#x3D;&#x3D; ch2;    &#125;    int dp[25][25];    string S, P;    int DP(int i, int j) &#123;        &#x2F;&#x2F; s[0:i), p[0:j)是否匹配，前i、j个字符        if(dp[i][j] !&#x3D; -1)  return dp[i][j];        if(P[j-1] &#x3D;&#x3D; &#39;*&#39;) &#123;            if(!isSingleMatch(S[i-1], P[j-2])) &#123;                &#x2F;&#x2F; aaa  ab*                return dp[i][j] &#x3D; DP(i, j-2);            &#125; else &#123;                &#x2F;&#x2F; aaa  aa*                return dp[i][j] &#x3D; DP(i, j-2) || DP(i-1, j-2) || DP(i-1, j);            &#125;        &#125; else &#123;            if(isSingleMatch(S[i-1], P[j-1])) &#123;                return dp[i][j] &#x3D; DP(i-1, j-1);            &#125; else  return dp[i][j] &#x3D; 0;        &#125;    &#125;    bool isMatch(string s, string p) &#123;        &#x2F;&#x2F; s &#x3D; &quot;aa&quot;        &#x2F;&#x2F; p &#x3D; &quot;a*&quot;        int i, j;        S &#x3D; s, P &#x3D; p;        memset(dp, -1, sizeof(dp));        dp[0][0] &#x3D; 1;        for(i&#x3D;1; i&lt;&#x3D;s.size(); i++)   dp[i][0] &#x3D; 0;        for(i&#x3D;1; i&lt;&#x3D;p.size(); i++) &#123;            if(p[i-1] &#x3D;&#x3D; &#39;*&#39;) dp[0][i] &#x3D; dp[0][i-2];            else    dp[0][i] &#x3D; 0;        &#125;        for(i&#x3D;1; i&lt;&#x3D;s.size(); i++) &#123;            for(j&#x3D;1; j&lt;&#x3D;p.size(); j++) &#123;                dp[i][j] &#x3D; DP(i, j);            &#125;        &#125;        return dp[s.size()][p.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
          <category> leecode hot 100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哔哩哔哩课程评价指南开发经历——深度学习</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/07/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%AF%BE%E7%A8%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E5%8D%97%E5%BC%80%E5%8F%91%E7%BB%8F%E5%8E%86%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/07/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%AF%BE%E7%A8%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E5%8D%97%E5%BC%80%E5%8F%91%E7%BB%8F%E5%8E%86%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一篇讲解到了抓包爬取哔哩哔哩课程的评论。接下来需要对这些评论文本进行情感分类——本质上就是一个文本二分类问题。于是使用较为熟悉的深度学习方法进行解决——搭建深度学习模型。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——深度学习.assets\image-20230807102935419.png" alt="深度学习模型结构图"></p><p>此处需要强调的是，需要获取中文分词的拼音，将中文分词和拼音均送入后续的神经网络，还需要在送入全连接层前进行拼接。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="第一步：制作数据集"><a href="#第一步：制作数据集" class="headerlink" title="第一步：制作数据集"></a>第一步：制作数据集</h3><p>制作数据集是一件很繁琐的事情，这里为了简化工作，暂且制作了一个由100条好评和100条差评组成的数据集。</p><h3 id="第二步：预处理文本"><a href="#第二步：预处理文本" class="headerlink" title="第二步：预处理文本"></a>第二步：预处理文本</h3><p>由于我们只考虑中文评论文本，而很多评论中包含很多对分类结果没有意义的英文和数字，以及一些特殊字符（比如空格、换行等），因此编写一个对文本进行预处理的函数。另外预处理完成后，使用<code>jieba</code>对中文评论文本进行分词，<strong>剔除其中的停用词，得到最终的中文分词结果后，再获取它们的拼音，得到最终的数据集</strong>。</p><h4 id="剔除英文、数字并分词"><a href="#剔除英文、数字并分词" class="headerlink" title="剔除英文、数字并分词"></a>剔除英文、数字并分词</h4><p>使用正则表达式可以很方便地实现这一效果。具体参考了这篇博客：<a href="https://blog.csdn.net/Wuyeyu2001/article/details/127324156">https://blog.csdn.net/Wuyeyu2001/article/details/127324156</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">pre_filter</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''参考: https://blog.csdn.net/Wuyeyu2001/article/details/127324156'''</span>    text <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'[a-zA-Z0-9]'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span>    text <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'\W'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span>    <span class="token keyword">return</span> jieba<span class="token punctuation">.</span>lcut<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="剔除停用词"><a href="#剔除停用词" class="headerlink" title="剔除停用词"></a>剔除停用词</h4><p>停用词可以理解为一些语气词、助词等实际意义较弱的词，需要在文本分类中进行去除。从网上下载已经总结出来的停用词文本文件：<a href="https://github.com/goto456/stopwords">https://github.com/goto456/stopwords</a></p><p>然后进行读取，并将其中的词存储到列表中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 读取停用词</span>stop_words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'../data/stopwords/hit_stopwords.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    lines <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">:</span>        stop_words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的剔除停用词，可以编写一个过滤器<code>filter</code>，将存在与停用词表中的词过滤掉即可。</p><h4 id="获取词汇拼音"><a href="#获取词汇拼音" class="headerlink" title="获取词汇拼音"></a>获取词汇拼音</h4><p>需要使用一个强有力的包<code>xpinyin</code>，按照如下语句调用即可很方便地获取目标语句的拼音（带音调）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> Pinyin<span class="token punctuation">(</span><span class="token punctuation">)</span>data <span class="token operator">=</span> <span class="token string">"哔哩 哔哩 好用 喜欢"</span>pinyin_data <span class="token operator">=</span> p<span class="token punctuation">.</span>get_pinyin<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> tone_marks<span class="token operator">=</span><span class="token string">'marks'</span><span class="token punctuation">)</span><span class="token comment"># pinyin_data: bìlī bìlī hǎoyòng xǐhuān</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>项目中只需要将<code>data</code>替换成已经划分好的中文分词即可。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>综上，完整的文本预处理得到新的文本数据集的代码如下。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">csv_file <span class="token operator">=</span> <span class="token string">"../data/dataset.csv"</span>content <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>csv_file<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'gbk'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>valuessave_file <span class="token operator">=</span> <span class="token string">"../data/new_worddataset.csv"</span>save_pinyin_file <span class="token operator">=</span> <span class="token string">"../data/new_dataset.csv"</span> <span class="token comment"># 最终得到的新数据集文件</span>p <span class="token operator">=</span> Pinyin<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>save_file<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f1<span class="token punctuation">,</span> <span class="token builtin">open</span><span class="token punctuation">(</span>save_pinyin_file<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f2<span class="token punctuation">:</span>    writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>f1<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">,</span> <span class="token string">'label'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    pinyin_writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>f2<span class="token punctuation">)</span>    pinyin_writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'text'</span><span class="token punctuation">,</span> <span class="token string">'pinyin'</span><span class="token punctuation">,</span> <span class="token string">'label'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> sample <span class="token keyword">in</span> content<span class="token punctuation">:</span>        reply<span class="token punctuation">,</span> label <span class="token operator">=</span> sample<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sample<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        reply <span class="token operator">=</span> pre_filter<span class="token punctuation">(</span>reply<span class="token punctuation">)</span>        data <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">filter</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> w<span class="token punctuation">:</span> w <span class="token keyword">not</span> <span class="token keyword">in</span> stop_words<span class="token punctuation">,</span> reply<span class="token punctuation">)</span><span class="token punctuation">)</span>        data <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token comment"># 获取分词的拼音</span>        pinyin_data <span class="token operator">=</span> p<span class="token punctuation">.</span>get_pinyin<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> tone_marks<span class="token operator">=</span><span class="token string">'marks'</span><span class="token punctuation">)</span>        writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">,</span> label<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 将评论文本、拼音、标签一起写入.csv文件，成为完整的一条样本</span>        pinyin_writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">,</span> pinyin_data<span class="token punctuation">,</span> label<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原始的数据集长这样：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——深度学习.assets\image-20230807110234144.png" alt="image-20230807110234144"></p><p>转化后的数据集长这样：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——深度学习.assets\image-20230807110326385.png" alt="image-20230807110326385"></p><h3 id="第三步：搭建深度学习模型"><a href="#第三步：搭建深度学习模型" class="headerlink" title="第三步：搭建深度学习模型"></a>第三步：搭建深度学习模型</h3><p>我们的深度学习模型由于需要进行文本分类，因此还需要额外一个嵌入（Embedding）层。此外还需要LSTM层和CNN层、全连接层。</p><h4 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h4><p>对词嵌入（word embedding）可以这样理解：计算机程序的处理对象通常是数值对象，而无法直接处理人类所使用的自然语言（字符串），比如计算机视觉中的图像处理，不也是把图像转化成一个一个的像素点数值吗？与此类似，<strong>将自然语言的“词汇”转化为可以被计算机程序所计算的数值的过程，就是所谓的词嵌入</strong>。更具体地，可以理解为，通过实现构建一个<strong>词典</strong>（<strong>词汇到向量的映射，每一个词汇对应一个数学向量，即词向量</strong>），然后处理自然语言时，每每在词典中查找每一个词汇，就将其替换为其所对应的词向量。</p><p>那么重点来了，如何得到这样的一个“词典”？一旦得到它，不就可以对用户输入的自然语言进行<code>jieba</code>分词、查找词汇替换词向量、送入计算程序为计算机处理了？所以接下来看看构建词典的方法。</p><p>本项目中使用的技术是<strong>word2vec</strong>。也就是训练大规模的中文语料，得到一个大的词表，其中每一个词就对应着一个词向量。那么先将目光聚焦到当前构建词表的任务中，而不要去看原初的文本分类大任务。</p><h5 id="下载中文语料库"><a href="#下载中文语料库" class="headerlink" title="下载中文语料库"></a>下载中文语料库</h5><p>开源的中文语料库特别多，随便到网络上下载一个即可，比如金庸的某小说也行。本项目中已经准备好了一份文本文件，其中的中文语料均已经分词完成。</p><h5 id="调用gensim库进行训练"><a href="#调用gensim库进行训练" class="headerlink" title="调用gensim库进行训练"></a>调用gensim库进行训练</h5><p>注意，我们的文本分类模型需要接受中文评论和它的拼音作为输入，那么也就是说，我们需要先分别训练一个中文词表和中文拼音词表。它们的训练大同小异，这里仅仅以中文词表的训练构建为例进行说明了。</p><p>导入所需要的包：<code>gensim</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> gensim<span class="token punctuation">.</span>models <span class="token keyword">import</span> KeyedVectors<span class="token punctuation">,</span>word2vec<span class="token punctuation">,</span>Word2Vec<span class="token keyword">from</span> gensim <span class="token keyword">import</span> utils<span class="token keyword">import</span> jieba<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建一个语料处理类，实际上是一个可迭代对象，在其<code>__iter__()</code>方法中，每次产出文本文件中的一行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyCorpus</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> corpus_path<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>corpus_path <span class="token operator">=</span> corpus_path    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> <span class="token builtin">open</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>corpus_path<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#对读取的句子进行简单的处理</span>            <span class="token keyword">yield</span> utils<span class="token punctuation">.</span>simple_preprocess<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用上面定义好的语料处理类，读取准备好的中文语料文件；将读取的结果送入<code>Word2Vec</code>对象，并指定词向量维度为$300$（<strong>一般称之为嵌入维度，embedding_dim</strong>）。<code>Word2Vec</code>是<code>gensim</code>包中很有用的word2vec训练工具。训练完成后，将模型保存下来（这里选择保存为.vector和.bin文件，当然也可以选择保存为其他格式的模型文件，只不过，.vector模型文件支持点开预览各个词以及对应的词向量）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sentences <span class="token operator">=</span> MyCorpus<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span>model <span class="token operator">=</span> Word2Vec<span class="token punctuation">(</span>sentences<span class="token operator">=</span>sentences<span class="token punctuation">,</span> vector_size<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>wv<span class="token punctuation">.</span>save_word2vec_format<span class="token punctuation">(</span><span class="token string">'dl/word2vec.vector'</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>wv<span class="token punctuation">.</span>save_word2vec_format<span class="token punctuation">(</span><span class="token string">'dl/word2vec.bin'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="创建词向量权重矩阵"><a href="#创建词向量权重矩阵" class="headerlink" title="创建词向量权重矩阵"></a>创建词向量权重矩阵</h5><p>训练完成后，我们就得到了基于下载的中文语料的中文词向量。为了能够更方便地使用词嵌入，我们需要用到<code>torch</code>提供的一个接口<code>torch.nn.Embedding.from_pretrained()</code>导入已经训练完毕得到的词向量权重矩阵。</p><p>下面根据训练得到的word2vec模型，创建权重矩阵。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——深度学习.assets\image-20230807122825229.png" alt="word2vec模型文件概览"></p><p>我们先导入之前保存好的模型文件<code>word2vec.vector</code>：</p><p><code>word_dict = KeyedVectors.load_word2vec_format(&#39;./word2vec.vector&#39;)</code></p><p>然后获取全部的词，取出它们对应的词向量存入矩阵的同时，建立<strong>中文词到数值索引的映射</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">word_list <span class="token operator">=</span> word_dict<span class="token punctuation">.</span>index_to_key <span class="token comment"># ['一个', '可以']</span>vocab_size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word_list<span class="token punctuation">)</span>word2index <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment"># 词表，中文词到数值索引的映射表</span>embeddings <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>vocab_size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> embed_dim<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 嵌入词表的权重矩阵</span><span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>word_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    word2index<span class="token punctuation">[</span>word_list<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx    embeddings<span class="token punctuation">[</span>idx<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>word_dict<span class="token punctuation">[</span>word_list<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 填充</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义嵌入层代码如下</p><p><code>net = torch.nn.Embedding.from_pretrained(embeddings=embeddings, freeze=True)</code></p><p>这里的<code>embeddings</code>就是上面填充得到的词向量权重文件。在嵌入层接受输入时，只需要根据之前建立的<strong>中文词导数值索引的映射</strong>，将输入的分词转化为它们对应的数值索引，然后送入嵌入层，即可转化为词向量，继续后续的程序了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哔哩哔哩课程评价指南开发经历——网络爬虫</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/04/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%AF%BE%E7%A8%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E5%8D%97%E5%BC%80%E5%8F%91%E7%BB%8F%E5%8E%86%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/04/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%AF%BE%E7%A8%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E5%8D%97%E5%BC%80%E5%8F%91%E7%BB%8F%E5%8E%86%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>既然要从评论角度，对哔哩哔哩的课程进行优质与劣质的分类，那么其中一个很重要的环节就是爬取课程视频下方的评论。这些评论文本送入训练好的深度学习模型，进行情感分类，综合得到课程质量分类结果。本文主要记录个人在爬取哔哩哔哩视频评论的过程与心得。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们只需要爬取视频下方的一级评论。所有对评论的回复均不予关注。我们需要以表格形式将同一个视频的前200条评论展示出来。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——网络爬虫.assets\image-20230804223114222.png" alt="需要爬取的部分"></p><h2 id="抓包爬取"><a href="#抓包爬取" class="headerlink" title="抓包爬取"></a>抓包爬取</h2><p>点开查看网页源代码会发现，评论部分的源代码实际上是不存在的（换言之，展示出来的页面源代码不完整）。因此，需要进行抓包爬取。按下F12键，点击“网络”选项卡，查找含有reply关键字的响应资源，不难找到评论所在的响应资源。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——网络爬虫.assets\image-20230804223715554.png" alt="找到评论区域文本资源"></p><p>然后在标头中看一下它的请求链接：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——网络爬虫.assets\image-20230804223852683.png" alt="请求链接"></p><p>完整链接为<code>https://api.bilibili.com/x/v2/reply/main?csrf=660751d5c3b843b85b100ece74c17f36&amp;mode=3&amp;oid=443609142&amp;pagination_str=%7B%22offset%22:%22%22%7D&amp;plat=1&amp;seek_rpid=&amp;type=1</code></p><p>另外其实可以发现，原哔哩哔哩视频的评论是分批获取的，因为用户在不断往下拉时，会相应地刷新出现新的评论。因此评论的资源请求也是同样地分批进行。这个道理可以类比计算机网络中的数据报分组。全部评论就如同完整的数据报，而哔哩哔哩中每一页存在20条评论，可以类比为每一个分组大小就是20，由此进行分组请求。事实上，请求信息的相应字段也证实了这一点。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——网络爬虫.assets\image-20230804224357146.png" alt="评论分段获取"></p><p>字段<code>is_begin</code>和<code>is_end</code>分别指示了当前的分片是否为开头或者结尾。<code>next</code>字段指示的是下一个分片，可以理解为分片索引。理想状态是根据<code>next</code>的迭代自增爬取完全部的评论，但是上面的请求链接似乎压根不含这个字段！怎么办？</p><h3 id="关键：获取oid"><a href="#关键：获取oid" class="headerlink" title="关键：获取oid"></a>关键：获取oid</h3><p>参考网络上众多爬取哔哩哔哩评论的教程，我们可以发现现在的评论请求链接有一些变化了（过去请求链接中显式地包含着<code>next</code>数组，显而易见地可以按照上面的理想情况爬取）：</p><p><code>https://api.bilibili.com/x/v2/reply/main?jsonp=jsonp&amp;next=&#123;num&#125;&amp;type=1&amp;oid=&#123;oid&#125;&amp;mode=3&amp;plat=1&amp;_=1647577851745</code></p><p>不过不变的是，字段<code>csrf</code>在请求链接中确实没用，可以直接删去。于是请求链接变为：</p><p><code>https://api.bilibili.com/x/v2/reply/main?mode=3&amp;oid=443609142&amp;pagination_str=%7B%22offset%22:%22%22%7D&amp;plat=1&amp;seek_rpid=&amp;type=1</code></p><p>但是原来的请求链接现在还能用吗？不妨试一试，显然此处的字段<code>oid</code>具有课程唯一性，不同的课程的全部评论可以通过该字段进行区分。那我们只需要拿到<code>oid</code>字段，填入原先的请求链接中的<code>oid</code>字段，看看能不能照样显示出网页文本。结果居然是可以的。那么我们仍然可以按照理想情况来进行爬取评论了：只需要填入课程的<code>oid</code>即可。</p><p>爬取到的内容实际上是json对象。所包含的有用评论信息在其中的子属性下。通过不断地迭代取值，便可以取出所需要的属性值。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——网络爬虫.assets\image-20230804225533049.png" alt="爬取到的json对象"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>考虑到后续需要封装到后端，我们实现一个爬取评论的函数即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_root_reply</span><span class="token punctuation">(</span>oid<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 网页头</span>    headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36"</span><span class="token punctuation">,</span>        <span class="token string">"referer"</span><span class="token punctuation">:</span> <span class="token string">"https://www.bilibili.com/"</span>    <span class="token punctuation">&#125;</span>    num <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># oid = 443609142</span>    replay_index <span class="token operator">=</span> <span class="token number">1</span>    <span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'lanyin.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    replies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment"># 评论数组</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 只需要前10×20=200条评论</span>        <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">11</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        URL <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"https://api.bilibili.com/x/v2/reply/main?jsonp=jsonp&amp;next=</span><span class="token interpolation"><span class="token punctuation">&#123;</span>num<span class="token punctuation">&#125;</span></span><span class="token string">&amp;type=1&amp;oid=</span><span class="token interpolation"><span class="token punctuation">&#123;</span>oid<span class="token punctuation">&#125;</span></span><span class="token string">&amp;mode=3&amp;plat=1&amp;_=1647577851745"</span></span>  <span class="token comment"># 获得网页源码</span>        respond <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>URL<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>  <span class="token comment"># 获得源代码 抓包</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>respond<span class="token punctuation">.</span>status_code <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 如果响应为200就继续，否则退出</span>            respond<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">"UTF-8"</span>            html <span class="token operator">=</span> respond<span class="token punctuation">.</span>text            json_html <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token comment"># 把格式转化为json格式 一个是好让pprint打印，一个是好寻找关键代码</span>            <span class="token keyword">if</span> json_html<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'replies'</span><span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>json_html<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'replies'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">for</span> reply_num <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>json_html<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'replies'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 一页只能读取20条评论</span>                reply <span class="token operator">=</span> json_html<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'replies'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>reply_num<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span>                reply <span class="token operator">=</span> post_filter<span class="token punctuation">(</span>reply<span class="token punctuation">)</span> <span class="token comment"># post_filter()暂时按下不表，他相当于是一个后处理过滤器</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"[</span><span class="token interpolation"><span class="token punctuation">&#123;</span>reply_num<span class="token punctuation">&#125;</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">&#123;</span>num<span class="token punctuation">&#125;</span></span><span class="token string">]: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>reply<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>                replies<span class="token punctuation">.</span>append<span class="token punctuation">(</span>reply<span class="token punctuation">)</span>                <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>replay_index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.'</span> <span class="token operator">+</span> reply <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>                replay_index <span class="token operator">+=</span> <span class="token number">1</span>            num <span class="token operator">+=</span> <span class="token number">1</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token string">"Error"</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> replies<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>post_filter()</code>函数负责去除评论中的换行符以及其中的emoji表情符转化后的[]文本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">post_filter</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""去除评论文本中的换行符，以及emoji经转化后的[]文本信息"""</span>    text <span class="token operator">=</span> text<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">u"\\&#123;.*?&#125;|\\[.*?]"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>做了一个简单的前端和后端，展示一下爬取到的评论效果：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\哔哩哔哩课程评价指南开发经历——网络爬虫.assets\image-20230804230046542.png" alt="展示爬取到的评论"></p>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二型曲线积分</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/01/%E7%AC%AC%E4%BA%8C%E5%9E%8B%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/01/%E7%AC%AC%E4%BA%8C%E5%9E%8B%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在第九章，我们已经学习了多元函数积分学——二重积分、三重积分、第一型曲线积分、第一型曲面积分等等，这些都是不涉及方向的曲线、曲面等几何体上的积分；而在第十章，我们扩大了函数的范围，扩大到了向量场的有向曲线和有向曲面上。</p></blockquote><p>本章的主要内容包括：</p><p><a href="#一、向量函数与向量场">    </a> <a href="#一、向量函数与向量场">一、向量函数与向量场</a></p><p><a href="#二、第二型曲线积分的计算">二、第二型曲线积分的计算</a></p><p><a href="#计算——知识点1：化定积分计算">知识点1：化定积分计算</a></p><p><a href="#三、格林公式">    </a><a href="#三、格林公式">三、格林公式</a></p><p><a href="#知识点2：格林公式的内容与理解">知识点2：格林公式的内容与理解</a></p><p><a href="#知识点3：灵活使用格林公式">知识点3：灵活使用格林公式</a></p><p><a href="#四、积分与路径无关">    </a><a href="#四、积分与路径无关">四、积分与路径无关</a></p><p><a href="#知识点4：求全微分的原函数、解全微分方程">知识点4：求全微分的原函数、解全微分方程</a></p><h2 id="一、向量函数与向量场"><a href="#一、向量函数与向量场" class="headerlink" title="一、向量函数与向量场"></a>一、向量函数与向量场</h2><h3 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h3><p>我们之前学过数量函数，它们相当于“数量”，不带有方向；此处的<strong>向量函数</strong>，通俗理解，他们</p><ul><li>既是“向量”，具有向量的表示形式：$\mathbf{x}=\{a,b,\dots\}$；</li><li>也具有函数的特征——每一个维度上都是一个独立的数量函数：$\{f(M), g(M), \dots \}$，$M$为一点；</li></ul><p>因此表示为向量函数 $\mathbf{F}(M)=\{ f(M), g(M), \dots \} $。</p><p>以空间中的向量函数为例：</p><script type="math/tex; mode=display">\begin{aligned} \mathbf{F}(x,y,z) &= P(x,y,z)\mathbf{i}+Q(x,y,z)\mathbf{j}+R(x,y,z)\mathbf{k}\\\\&= \{ P(x,y,z),Q(x,y,z),R(x,y,z) \} \end{aligned}</script><h3 id="向量函数的导数"><a href="#向量函数的导数" class="headerlink" title="向量函数的导数"></a>向量函数的导数</h3><p>简单点说，对向量函数求导，就是对每一个维度上的数量函数分别求导。同样地，以上面的空间中向量函数为例，有</p><script type="math/tex; mode=display">\frac{\partial \mathbf{F}}{\partial x} = \left\{ \frac{\partial P}{\partial x}, \frac{\partial Q}{\partial x}, \frac{\partial R}{\partial x} \right\}</script><h3 id="几个微分关系"><a href="#几个微分关系" class="headerlink" title="几个微分关系"></a>几个微分关系</h3><p>曲线$C$为空间上的一条曲线，$ds$为弧微分，则有</p><script type="math/tex; mode=display">\begin{cases} dx=ds·\cos\alpha \\ dy=ds·\cos\beta \\ dz=ds·\cos\gamma \end{cases}</script><p>事实上，$ds$可以看做空间上一条很短的直线：</p><script type="math/tex; mode=display">ds=\sqrt{(dx)^2+(dy)^2+(dz)^2}</script><p>若$x=x(t),y=y(t),z=z(t)$，则有</p><script type="math/tex; mode=display">ds=\sqrt{(x'(t))^2+(y'(t))^2+(z'(t))^2}dt</script><h2 id="二、第二型曲线积分"><a href="#二、第二型曲线积分" class="headerlink" title="二、第二型曲线积分"></a>二、第二型曲线积分</h2><h3 id="第二型曲线积分的概念"><a href="#第二型曲线积分的概念" class="headerlink" title="第二型曲线积分的概念"></a>第二型曲线积分的概念</h3><p>这里引入一个实际例子——变力作功。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816132211499.png" alt="img"></p><p> <strong>需要注意第二型曲线积分的记号和形式</strong>：</p><script type="math/tex; mode=display">\begin{aligned} d\mathbf{r}&=\{ dx,dy \} \\\\ \mathbf{F}&=\{ P(x,y),Q(x,y) \}\\\\ \int_l \mathbf{F}d\mathbf{r}&=\int_l\{ P(x,y),Q(x,y) \}·\{ dx,dy \} \\\\ &= \int_lP(x,y)dx+Q(x,y)dy \end{aligned}</script><h3 id="二型积分的性质"><a href="#二型积分的性质" class="headerlink" title="二型积分的性质"></a>二型积分的性质</h3><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816065236742.png" alt="img"></p><h3 id="知识点1：化定积分计算"><a href="#知识点1：化定积分计算" class="headerlink" title="知识点1：化定积分计算"></a><em>知识点1：化定积分计算</em></h3><p>第一种计算方式，就是<strong>将第二型曲线积分转化为定积分的计算</strong>（证明用到了拉格朗日中值定理，将第二型曲线积分的和式的极限恰好转化为了定积分和式的极限）。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745670.png" alt="img"></p><p><strong>具体做法：</strong></p><ol><li><strong>将曲线的参数方程代入到被积表达式中，</strong></li><li><strong>曲线起点对应的参数为定积分下限，终点参数对应定积分上限，</strong></li><li><strong>就化为了定积分运算。</strong></li></ol><p>看道例题：</p><p><strong>例1</strong> 求$\displaystyle \int_C ydx-xdy$，$C$为平面区域边界$D$的闭曲线，方向为逆时针，其中</p><script type="math/tex; mode=display">D:\begin{cases} 0 \leqslant x \leqslant 1 \\ 0 \leqslant y \leqslant 2 \end{cases}</script><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\image-20230802094740796.png" alt="image-20230802094740796" style="zoom:50%;" /></p><p>记</p><script type="math/tex; mode=display">C_1:y=0,(0,0)\to(1,0) \quad C_2: x=1, (1,0)\to(1,2) \\C_3:y=2,(1,2)\to(0,2) \quad C_4: x=0, (0,2)\to(0,0)</script><p>由二型积分<strong>可加性</strong>得</p><script type="math/tex; mode=display">\begin{aligned} \int_C ydx-xdy &= \int_{C_1} ydx-xdy + \int_{C_2}ydx-xdy + \int_{C_3}ydx-xdy + \int_{C_4}ydx-xdy \\\\ &=0 + \int_0^2-1dy+\int_1^02dx \\\\ &= -4 \end{aligned}</script><p><strong>例2</strong></p><p>求积分$\displaystyle \int_Cydx+2xydy,C:\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，方向为顺时针方向。</p><p>解：</p><p>得出曲线的参数方程$x = a \cos t, y = b\sin t$,</p><p>代入被积表达式中得到：</p><p>$\displaystyle \oint b\sin t da\cos t + 2a\cos tb\sin t db\sin t$,积分下限是起点参数0，积分上限是终点参数-2π（顺时针方向）</p><p>接下来按照定积分计算即可。</p><p><strong>例3</strong></p><p>计算$\displaystyle \int_C ydx$，其中$C:r=1-\cos \theta (0\leqslant \theta \leqslant \pi)$，由$(0,0)$到$(2,\pi)$。</p><p>首先做极坐标变换</p><script type="math/tex; mode=display">\begin{cases} x=r\cos\theta=(1-\cos\theta)\cos\theta \\ y=r\sin\theta=(1-\cos\theta)\sin\theta \end{cases}</script><p>由此得到参数方程，代入被积表达式可得</p><script type="math/tex; mode=display">\begin{aligned} &\int_0^\pi(1-\cos\theta)\sin\theta d(1-\cos\theta)\cos\theta \\\\ =& \int_0^\pi(1-\cos\theta)\sin\theta(\cos\theta-\cos^2\theta)'d\theta \\\\ =&-\frac{3\pi}{4}  \end{aligned}</script><h3 id="第二型曲线积分与第一型曲线积分的关系"><a href="#第二型曲线积分与第一型曲线积分的关系" class="headerlink" title="第二型曲线积分与第一型曲线积分的关系"></a>第二型曲线积分与第一型曲线积分的关系</h3><p>实际上，根据弧微分和坐标微元之间的关系，可以很快得到结果：</p><script type="math/tex; mode=display">ds=dx\cos\alpha</script><p>我们回到最初第二型曲线积分的例子：</p><script type="math/tex; mode=display">\int_C\mathbf{F}d\mathbf{r}=\int_CPdx+Qdy+Rdz,\quad \mathbf{F}=\{P, Q, R\}</script><p>将曲线$C$用参数方程表示出来，即</p><script type="math/tex; mode=display">C:\begin{cases} x=x(t) \\ y=y(t) \\ z=z(t) \end{cases}, t:\alpha_0\to\beta_0</script><p>曲线$C$上参数$t$对应的点处，与$t$增加方向一致的切向量为$\{ x’(t),y’(t),z’(t) \}$，进而得到方向余弦</p><script type="math/tex; mode=display">\cos\alpha=\frac{\pm x'(t)}{\sqrt{(x'(t))^2+(y'(t))^2+(z'(t))^2}}</script><p>对于二型积分，只考虑$Pdx$项，变形得</p><script type="math/tex; mode=display">\begin{aligned} \int_CPdx &= \int_{\alpha_0}^{\beta_0}Px'(t)dt \\\\ &= \int_{\alpha_0}^{\beta_0}P\cos\alpha \sqrt{(x'(t))^2+(y'(t))^2+(z'(t))^2}dt \\\\ &=\int_{\alpha_0}^{\beta_0}P\cos\alpha ds \end{aligned}</script><p>这就是从第二型曲线积分$\displaystyle \int_C Pdx$转化得到了第一型曲线积分$\displaystyle \int_{\alpha_0}^{\beta_0}P\cos\alpha ds$。</p><h2 id="三、格林公式"><a href="#三、格林公式" class="headerlink" title="三、格林公式"></a>三、格林公式</h2><h3 id="知识点2：格林公式的内容与理解"><a href="#知识点2：格林公式的内容与理解" class="headerlink" title="知识点2：格林公式的内容与理解"></a><strong><em>知识点2：格林公式的内容与理解</em></strong></h3><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745675.png" alt="img"></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816072911765.png" alt="img"></p><p>格林公式的三个前提：</p><ol><li>平面上的闭区域D；</li><li>P、Q在D区域上都具有连续的一阶偏导数；</li><li>格林公式默认计算的是闭曲线的正向。</li></ol><ul><li>公式的理解：</li></ul><p>从左向右看，格林公式提供了又一条计算二型积分的途径，它将第二型曲线积分转化为了一个闭区域上的二重积分。</p><p>从右向左看，格林公式也提供了一种计算二重积分的途径，思路是将二重积分转化为第二型曲线积分后，再使用参数方程转为定积分的计算。</p><ul><li>公式的适用条件：</li></ul><p>我们知道的是，二重积分一般来说也不简单计算，因此我们需要先验一下右侧被积表达式的简洁性，若它的形式较为简单，就可以用格林公式了，转为二重积分后，再使用柱坐标、球坐标或者一般的解法。</p><p>值得注意的是公式本身的条件：</p><ol><li>必须是平面上的闭区域。若不是，可以考虑补线（与坐标轴垂直的线段，方便计算，因为可以保证一个坐标分量为常数，对该坐标分量的积分就为0）。</li><li>P、Q要在闭区域上具有连续的一阶偏导数。这一点验证起来通常比较麻烦，但是目前我们所知的是所有的初等函数在其定义域内都满足这个条件。我们着重考虑分母为零的情况（函数自然没有连续的一阶偏导数），此时“挖”去包含这一点的闭区域，然后利用格林公式。</li><li>曲线的正向还是负向很好处理，添加负号即可反向。</li></ol><h3 id="知识点3：灵活使用格林公式"><a href="#知识点3：灵活使用格林公式" class="headerlink" title="知识点3：灵活使用格林公式"></a><strong><em>知识点3：灵活使用格林公式</em></strong></h3><p><strong>例4</strong></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816090115460.png" alt="img"></p><p>分析：贸然求导会很麻烦，观察给出的闭曲线方程，正好得出分母其实就等于1，而第二型曲线积分中被积表达式中的变量均满足积分路径方程，可以替换而不影响正确结果。化简之后，再使用格林公式。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745676.png" alt="img"></p><p><strong>例5</strong></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816081639222.png" alt="img"></p><p>分析：我们发现虽然可以仍用最开始的化定积分的方法，但是计算起来太复杂了，因此还是考虑格林公式。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745677.png" alt="img"></p><ul><li><strong>可以小结一下使用格林公式的解题步骤：</strong></li></ul><ol><li><strong>是否可以对比较复杂的被积表达式作出化简</strong></li><li><strong>预先计算化简后的两个偏导数，看看方不方便利用格林公式</strong></li><li><strong>判断满不满足格林公式的使用条件</strong></li><li><strong>不满足则作出变换，比如补线</strong></li><li><strong>在满足条件后，使用格林公式</strong></li><li><strong>计算原被积表达式的积分（去掉补的线）</strong></li></ol><p><strong>例6</strong></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816083537466.png" alt="img"></p><p>解：</p><p>首先也是计算两个偏导数： </p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816083626806.png" alt="img"><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745778.png" alt="img"></p><p>发现结果很简单，居然是0，因此这一题用格林公式一定很简单，下面就需要验证三个前提了：</p><p>曲线C为椭圆，当然围成了一个闭区域；但是P、Q在该闭区域内部的(0, 0)点根本没有定义，更别说一阶偏导数了。因此，要用格林公式，就需要在不考虑该点的情况下使用，所以就需要补闭曲线C0，同时C0上的积分需要便于计算；因此就想到补圆（去分母）C0：<img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq.png" alt="x^2+y^2 = R^2">,其方向为了和题中曲线给的逆时针对应，所以为顺时针方向，两者构成的复连通域即为正向。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816084246196.png" alt="img"></p><p>最后还需要计算补的圆上的二型积分，此时体现出来了这样补线的优势（直接去掉了分母简化了形式，也可以利用格林公式） </p><p> <img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745779.png" alt="img"></p><p><strong>例7</strong></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745780.png" alt="img">!</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816085233422.png" alt="img"></p><h2 id="四、积分与路径无关"><a href="#四、积分与路径无关" class="headerlink" title="四、积分与路径无关"></a>四、积分与路径无关</h2><blockquote><p>求<img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\int xdx&plus;ydy.png" alt="\int xdx+ydy">， 积分曲线C分别为：</p><p>1）<img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq-169090119745781.png" alt="y=x">; 由（0,0）到（1,1）；</p><p>2) <img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq-169090119745782.png" alt="y=x^2">, 由（0,0）到（1,1）；</p><p>3）<img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\sin 1}.png" alt="y=\frac{\sin x}{\sin 1}">, 由（0,0）到（1,1）；</p><p>…</p><p>它们的结果都等于1。</p><p><strong>我们会发现，当被积表达式满足一定的条件的时候，这个积分就与积分路径无关了，换言之，也许题目给了一条很复杂的曲线作为积分路径，但是我们可以直接换成一条最简单的路径求积分，结果是不变的。</strong></p></blockquote><p>以上用数学语言表述为：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816075512498.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816075520612.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑‘</p><ul><li>判定方法</li></ul><p>当然我们也需要注意积分与路径无关定理的使用前提。</p><p>目前我们不可能根据定义来判定积分与路径无关，只能寻求更加直接、容易操作的判定方法。请看书中给出的四个等价命题：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745783.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>可以看出，实际上，第4个命题才是最容易实现的判定方法，即我们在拿到一道题目时，可以预先计算出两个对应的偏导数，若它们相等，则积分与路径无关成立。</p><ul><li>具体操作</li></ul><ol><li>预先计算两个偏导数</li><li>成立，则选取与坐标轴垂直的折线路径计算（此时转化为了很简单的定积分计算）</li></ol><p>应用解题：</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745784.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><ul><li>利用积分与路径无关求二型积分</li></ul><p><strong>例</strong></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745785.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> OB：x = x, y = 0;    BA: x = <img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\pi }{2}.png" alt="\frac{\pi }{2}">, y = y.</p><ul><li><h3 id="知识点4：求全微分的原函数、解全微分方程"><a href="#知识点4：求全微分的原函数、解全微分方程" class="headerlink" title="知识点4：求全微分的原函数、解全微分方程"></a><strong><em>知识点4：求全微分的原函数、解全微分方程</em></strong></h3></li></ul><blockquote><p>先提一提原函数与全微分的概念（以二元函数为例）</p><p>若存在一个二元函数u(x, y)使得 <img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq-169090119745886.png" alt="du = P(x,y)dx+Q(x,y)dy">,则</p><p> 称<img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq-169090119745887.png" alt="P(x,y)dx+Q(x,y)dy"> 为一个全微分，</p><p> 称u(x, y)为 <img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq-169090119745887.png" alt="P(x,y)dx+Q(x,y)dy"> 的一个原函数，</p><p>称 <img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\eq-169090119745887.png" alt="P(x,y)dx+Q(x,y)dy"> = 0为一个全微分方程。</p></blockquote><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816134245532.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>例</strong></p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816124635599.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 按照题意，两个偏导数恒相等即可求出a的值。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745888.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>例</strong></p><p>解方程<img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\20210816131832389.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 首先判断出来，这是一个全微分方程，然后利用定理求出原函数，注意最后给原函数加上一个常数，得到的才是最终的通解。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\第二型曲线积分.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzNzExODc4,size_16,color_FFFFFF,t_70-169090119745889.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>总结</p><p>以上差不多就是第二型曲线积分的全部内容，主要就是在讲如何计算第二型曲线积分，以及对格林公式、积分与路径无关定理的理解与运用。</p><p>其中，计算第二型曲线积分，我们已经知道的方法有三种：</p><ol><li>最基本的方法：化成定积分计算</li><li>使用格林公式，化成二重积分</li><li>积分与路径无关，换积分路径</li></ol><p>第一种方法，最基本、直接，但是有多情况下难以求出参数方程，即使求出了参数方程，代入后使得被积表达式异常复杂；</p><p>第二种方法，最重要、方便，往往题目不会允许我们直接使用，而是需要变换一下才可以使用格林公式，其次就是二重积分的底子也是需要的；</p><p>第三种方法（其实本质上说，第三种方法可以转化为第二种方法），换成折线段分开积分，计算起来一般很简单。</p><p>而对于求解全微分方程，这部分内容与微分方程一章联系紧密，用到的却是二型积分的方法，牢记公式套用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型</title>
      <link href="/mid-lake-pavilion.github.io/2023/08/01/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/mid-lake-pavilion.github.io/2023/08/01/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>给定$d$维样本点$\mathbf{x}=(x_1; x_2;…; x_d)$，线性模型要学习一个线性组合</p><script type="math/tex; mode=display">f(\mathbf{x})=w_1x_1+w_2x_2+...+w_dx_d+b</script><p>用向量形式表示为</p><script type="math/tex; mode=display">f(\mathbf{x})=\mathbf{w}^T\mathbf{x}+b\quad w,x\in R^d</script><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>当然，回归问题总是要学习一个“对象”，在线性回归中，这个“对象”就是上面的线性组合；为了评价学习到的结果到底怎么样，通常采用均方误差，来量化学习结果和真实值之间的差距</p><script type="math/tex; mode=display">\mathrm{MSE}=\sum_{i=1}^m(f(\mathbf{x}^{(i)})-y^{(i)})^2</script><p>在此，<strong>约定$(\mathbf{x}^{(i)}, y^{(i)})$表示第i个数据样本，$x^{(i)}_j$表示第i个数据样本的第j个特征分量，$y^{(i)}$表示第i个样本的标签</strong>。</p><p>而根据数据集求解使得均方误差最小的模型参数$\mathbf{w},b$的过程，称为最小二乘参数估计。常用的方法是<strong>梯度下降</strong>，因此需要对参数求梯度</p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial MSE}{\partial \mathbf{w}}&=\frac{\partial\displaystyle \sum_{i=1}^m\left(\mathbf{w}^T\mathbf{x}^{(i)}+b-y^{(i)}\right)^2}{\partial \mathbf{w}}\\\\&=2\left(\mathbf{w}\sum_{i=1}^m(\mathbf{x}^{(i)})^2-\sum_{i=1}^m(y^{(i)}-b)\mathbf{x}^{(i)}\right) \end{aligned}</script><p>类似地，有</p><script type="math/tex; mode=display">\frac{\partial MSE}{\partial b}=2\left(mb-\sum_{i=1}^m(y^{(i)}-\mathbf{w}\mathbf{x}^{(i)})\right)</script><p>令梯度等于零，即可求解参数的最优解$w_<em>,b_</em>$。</p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>更一般地，我们把刚才的数据集表示为矩阵</p><script type="math/tex; mode=display">X = \begin{bmatrix} x_{11} & x_{12} & ... & x_{1d} & 1 \\ x_{21} & x_{22} & ... & x_{2d} & 1\\ ... & ... & ... & ... & ... \\ x_{m1} & x_{m2} & ... & x_{md} & 1 \end{bmatrix}=\begin{bmatrix} x_1^T & 1  \\ x_2^T & 1 \\ ... & ... \\ x_m^T & 1 \end{bmatrix}</script><p>标签记作</p><script type="math/tex; mode=display">y=\begin{bmatrix} y_1 \\ y_2 \\...\\y_m \end{bmatrix}</script><p>同样地，我们对$\mathbf{w}$求梯度得到</p><script type="math/tex; mode=display">\frac{\partial MSE}{\partial \mathbf{w}} = 2X^T(X\mathbf{w}-y)</script><p>令上式为零，得到参数最优解的解析解形式</p><script type="math/tex; mode=display">\mathbf{w}_*=(X^TX)^{-1}X^Ty</script><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>上面的问题是一般的回归问题，那些模型的输出可以是一定范围内的任意数；而有一些问题，比如分类问题，它要求模型的输出只能是几种类别中的一个。</p><p>以最简单的二分类问题为例，我们基于上面已经建立起来的线性模型推导出符合解决二分类问题的模型——最简单的做法其实是直接给原来的输出加上一个“分段函数”；我们常用Sigmoid函数来达到这个效果</p><script type="math/tex; mode=display">Sigmoid(z)=\frac{1}{1+e^{-z}}</script><p>将z代换为原先的线性组合，得到适用于二分类问题的逻辑回归模型</p><script type="math/tex; mode=display">g(x)=\frac{1}{1+e^{-(w^Tx+b)}}</script><p>接下来使用极大似然估计法来使得概率最大化。</p><h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><p>线性判别分析（Linear Discriminant Analysis，LDA），也称“Fisher判别分析”，主要思想是，给定训练数据集情况下，<strong>设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230801080329164.png" alt="线性判别分析示意图，来自周志华《机器学习》"></p><p>接下来，我们以简单的二分类问题，来逐步推导一下LDA的数学原理。</p><h3 id="二分类LDA"><a href="#二分类LDA" class="headerlink" title="二分类LDA"></a>二分类LDA</h3><blockquote><p>为了方便讨论，约定</p><ul><li>$X_i$表示第i类样本点的集合</li><li>$\mu_i$表示第i类样本点的均值向量</li><li>$\mathbf{w}$表示直线的方向向量</li></ul><p>另外，向量内积可以表示为$x·w=w^Tx$，其中$w,x\in \mathbb{R}^n$，而向量x在直线w上的投影则可以表示为$\frac{w^Tx}{||w||_2}$，也就是说，如果w模长为1，那么向量x在直线w上的投影就可以表示为$w^Tx$。为此，我们接下来都假设$||w||_2=1$。以下图为例进行简单说明。</p><script type="math/tex; mode=display">\begin{aligned} &\mathbf{x}·\mathbf{w}=||\mathbf{x}||·||\mathbf{w}||·\cos\theta \\\\ &\Rightarrow \mathrm{Prj}_\mathbf{w}\mathbf{x} = ||\mathbf{x}||·\theta=\frac{\mathbf{x}·\mathbf{w}}{||\mathbf{w}||}  \end{aligned}</script></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/diagram-1-16908718997321.png" alt="向量投影示意图"></p><p>再回顾上面关于LDA的两条基本原则：</p><ol><li>同类样例的投影点尽可能接近</li><li>异类样例的投影点尽可能远离</li></ol><p>为了衡量这两条原则，引入了量化指标<strong>散度矩阵</strong>。</p><h4 id="散度矩阵"><a href="#散度矩阵" class="headerlink" title="散度矩阵"></a>散度矩阵</h4><p>先考虑类间散度矩阵。可以直接采用类的均值向量$\mu_i,i\in\{0,1\}$在直线上的投影距离$w^T\mu_i$，考虑如下量化标准</p><script type="math/tex; mode=display">(w^T\mu_0-w^T\mu_1)^2=(w^T(\mu_0-\mu_1))^2=w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw</script><p>上式中，$(\mu_0-\mu_1)(\mu_0-\mu_1)^T$即为<strong>类间散度矩阵</strong>，记作$S_b$。</p><p>再考虑类内散度矩阵。与方差类似，我们考虑</p><script type="math/tex; mode=display">D(X_i)=\sum_{x\in X_i}(w^Tx-w^T\mu_i)^2,\ i\in \{0,1\}</script><p>进而有如下量化标准</p><script type="math/tex; mode=display">\begin{aligned} \sum_{i=0}^1D(X_i)&=\sum_{i=0}^1\sum_{x\in X_i}(w^Tx-w^T\mu_i)^2\\\\ &=w^T\sum_{i=0}^1\sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^Tw \end{aligned}</script><p>上式中，$\displaystyle \sum_{i=0}^1\sum_{x\in X_i}(x-\mu_0)(x-\mu_0)^T$即为<strong>类内散度矩阵</strong>，记作$S_w$。</p><p>综上，有定义</p><ul><li>类间散度矩阵$S_b=(\mu_0-\mu_1)(\mu_0-\mu_1)^T \in \mathbb{R}^{n\times n}$</li><li>类内散度矩阵$S_w=\displaystyle \displaystyle \sum_{i=0}^1\sum_{x\in X_i}(x-\mu_0)(x-\mu_0)^T\in \mathbb{R}^{n\times n}$</li></ul><h4 id="目标函数与拉格朗日法求解优化问题"><a href="#目标函数与拉格朗日法求解优化问题" class="headerlink" title="目标函数与拉格朗日法求解优化问题"></a>目标函数与拉格朗日法求解优化问题</h4><p>我们的目标函数被称为<strong>广义瑞利商</strong>，最大化之即可。</p><script type="math/tex; mode=display">\begin{aligned} &\max J \\\\ &J=\frac{\mathbf{w}^TS_b\mathbf{w}}{\mathbf{w}^TS_w\mathbf{w}} \end{aligned}</script><p><strong>经过观察，$J$的取值与$\mathbf{w}$的模长无关。</strong>因此，令$w^TS_ww=1$，我们将原问题转化为如下的优化问题：</p><script type="math/tex; mode=display">\begin{aligned} &\max_\mathbf{w} \mathbf{w}^TS_b\mathbf{w}\\\\&s.t.\mathbf{w}^TS_w\mathbf{w}=1 \end{aligned}</script><p>这是一个很典型的约束优化问题，可以用拉格朗日乘子法求解。</p><script type="math/tex; mode=display">L(w,\lambda)=-\mathbf{w}^TS_b\mathbf{w}+\lambda(\mathbf{w}^TS_w\mathbf{w}-1)</script><p>其中$\lambda$即为拉格朗日乘子。对$\mathbf{w}$求偏导数得</p><script type="math/tex; mode=display">\frac{\partial L(\mathbf{w},\lambda)}{\partial \mathbf{w}}=-2S_b\mathbf{w}+2\lambda S_w\mathbf{w}</script><p>令上式等于零，得到</p><script type="math/tex; mode=display">S_b\mathbf{w}_*=\lambda S_w\mathbf{w}_*</script><p>再结合先前的式子</p><script type="math/tex; mode=display">S_b\mathbf{w}_*=(\mu_0-\mu_1)(\mu_0-\mu_1)^T\mathbf{w}_*</script><p>得到</p><script type="math/tex; mode=display">\lambda S_w\mathbf{w}_*=(\mu_0-\mu_1)(\mu_0-\mu_1)^T\mathbf{w}_*</script><p><strong>我们并不关心w的模长，只关心它的方向</strong>，而$(\mu_0-\mu_1)^T\mathbf{w}_*$是一个标量，不妨记作k，因此有</p><script type="math/tex; mode=display">\mathbf{w}_*=\frac{k}{\lambda}S_w^{-1}(\mu_0-\mu_1)</script><p>舍去标量系数，仅保留其中的方向信息，得</p><script type="math/tex; mode=display">\mathbf{w}_*=S_w^{-1}(\mu_0-\mu_1)</script><p>这便是<strong>直线的方向向量</strong>。</p><h4 id="直接求解"><a href="#直接求解" class="headerlink" title="直接求解"></a>直接求解</h4><p>事实上，如果要直接求解优化问题</p><script type="math/tex; mode=display">\begin{aligned} &\max J \\\\ &J=\frac{\mathbf{w}^TS_b\mathbf{w}}{\mathbf{w}^TS_w\mathbf{w}} \end{aligned}</script><p>也是可行的。毕竟上面的解法忽略了$\mathbf{w}$的模长而只考虑了其方向。首先对$J$求关于$\mathbf{w}$的梯度</p><script type="math/tex; mode=display">\begin{aligned} \nabla_\mathbf{w}J &= \frac{2S_b\mathbf{w}(\mathbf{w}^TS_w\mathbf{w})-2(\mathbf{w}^TS_b\mathbf{w})S_w\mathbf{w}}{(\mathbf{w}^TS_w\mathbf{w})^2}\end{aligned}</script><p>令上式等于0，整理得</p><script type="math/tex; mode=display">\begin{aligned} S_b\mathbf{w}(\mathbf{w}^TS_w\mathbf{w})-(\mathbf{w}^TS_b\mathbf{w})S_w\mathbf{w}&=0 \\\\ S_b\mathbf{w}(\mathbf{w}^TS_w\mathbf{w}) &= (\mathbf{w}^TS_b\mathbf{w})S_w\mathbf{w}\\\\ S_b\mathbf{w} &= \frac{\mathbf{w}^TS_b\mathbf{w}}{\mathbf{w}^TS_w\mathbf{w}}S_w\mathbf{w} \\\\ S_w^{-1}S_b\mathbf{w} &= \lambda \mathbf{w} \end{aligned}</script><p>这里记$\displaystyle \lambda=J=\frac{\mathbf{w}^TS_b\mathbf{w}}{\mathbf{w}^TS_w\mathbf{w}}$，实际上<strong>将原优化问题转化为了求解$S_w^{-1}S_b$的最大特征值的问题</strong>。而$\mathbf{w}$就是该特征值对应的特征向量。</p><h3 id="多类LDA"><a href="#多类LDA" class="headerlink" title="多类LDA"></a>多类LDA</h3><p>和上面的二类问题类似地，我们有由$m$个样本组成的数据集</p><script type="math/tex; mode=display">\mathrm{D}=\{ (\mathbf{x}^{(1)},y^{(1)}), (\mathbf{x}^{(2)}, y^{(2)}), \cdots,(\mathbf{x}^{(m)}, y^{(m)}) \}</script><p>其中，$\mathbf{x}^{(i)}\in\mathbb{R}^n$数据集$\mathrm{D}$共包含$k$个类别，每一个类别包含的样本数量为$N_i,i\in \{1,2,\cdots, k\}$，所包含的样本集合记作$X_i$，且该类别样本均值为$\displaystyle \mu_i=\frac{1}{N_i}\sum_{j=1}^{N_i}X_i^{(j)}$，样本的协方差矩阵记作$\displaystyle \Sigma_i=\sum_{\mathbf{x}^{(j)}\in X_i}(\mathbf{x}^{(j)}-\mu_i)(\mathbf{x}^{(j)}-\mu_i)^T$。</p><p>和二类问题有差异的是，此时的低维空间不一定就是一条直线，而是一个空间，不妨设为$d$维空间。那么这时就需要利用到该$d$维空间的一组基$\{\mathbf{w}_1,\mathbf{w}_2,\cdots,\mathbf{w}_d\}$了。将这组基拼接起来写成矩阵</p><script type="math/tex; mode=display">W_{n\times d}=[\mathbf{w}_1, \mathbf{w}_2, \cdots, \mathbf{w}_d]</script><p>先考虑类间散度矩阵。计算全部样本的均值$\displaystyle \mu=\frac{1}{m}\sum_{i=1}^m\mathbf{x}^{(i)}$，类间散度矩阵表示为</p><script type="math/tex; mode=display">S_b=\sum_{i=1}^k N_i\left( \mu_i-\mu \right)(\mu_i - \mu)^T</script><p>类内散度矩阵表示为</p><script type="math/tex; mode=display">S_w=\sum_{i=1}^k \Sigma_i = \sum_{i=1}^k \sum_{\mathbf{x}^{(j)}\in X_i}\left( \mathbf{x}^{(j)}-\mu_i \right)\left( \mathbf{x}^{(j)}-\mu_i \right)^T</script><p>如果按照二类LDA的做法，我们应该得到优化问题</p><script type="math/tex; mode=display">\max_W \frac{W^TS_bW}{W^TS_wW}</script><p>但是，上式中的分子、分母均为矩阵而不是标量，因此无法按照二类LDA的求解方法进行优化。所幸的是，我们却可以使用其他的一些优化函数进行等价的替代，比如</p><script type="math/tex; mode=display">\begin{aligned} J(W)&=\frac{\displaystyle \prod_{diag}W^TS_bW}{\displaystyle \prod_{diag}W^TS_wW} \\\\ &= \frac{\displaystyle \prod_{i=1}^d\mathbf{w}_i^TS_b\mathbf{w}_i}{\displaystyle \prod_{i=1}^d\mathbf{w}_i^TS_w\mathbf{w}_i} \\\\ &=\prod_{i=1}^d\frac{\mathbf{w}_i^TS_b\mathbf{w}_i}{\mathbf{w}_i^TS_w\mathbf{w}_i} \end{aligned}</script><p>进而转化为优化问题</p><script type="math/tex; mode=display">\max J(W)</script><p>而事实上，$J(W)$形式中出现了之前提到过的广义瑞利商，问题也就可以按照二类LDA优化方法求解了。</p><h2 id="类别不平衡问题"><a href="#类别不平衡问题" class="headerlink" title="类别不平衡问题"></a>类别不平衡问题</h2><p>当训练数据集中不同类别的样例数目有差别时，会对学习造成影响。比如正例太少、反例太多。解决类别不平衡学习的基本策略为<strong>再平衡</strong>：</p><p>不妨以线性模型为例</p><script type="math/tex; mode=display">y=\mathbf{w}^T\mathbf{x}+b</script><p>假设输出结果$y&gt;0.5$时判别为正例，否则判别为反例，也即分类器的决策规则为</p><script type="math/tex; mode=display">\frac{y}{1-y}>1，预测为正例</script><p>但是由于数据集类别不平衡学习，<strong>希望分类器执行的决策为</strong></p><script type="math/tex; mode=display">\frac{y}{1-y}>\frac{m^+}{m^-}，预测为正例</script><p>其中$\frac{m^+}{m^-}$为观测几率，是数据集中正例数量与反例数量之比；也就是说只要高于该值，就表示为正例。</p><p>所以<strong>再平衡策略</strong>就是对预测值进行调整：</p><script type="math/tex; mode=display">\frac{y'}{1-y'}=\frac{y}{1-y}\times \frac{m^-}{m^+}</script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boltzmann Machine，玻尔兹曼机</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/31/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/31/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><p><strong>玻尔兹曼机是一种基于能量的概率模型</strong>。常见的玻尔兹曼机有两层：显层和隐层，示意图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA-16908186893771.jpg" alt="玻尔兹曼机"></p><p>其中，显层$\mathbf{v}\in \{0,1\}^D$，隐层$\mathbf{h}\in\{0,1\}^P$。即显层有D个结点，隐层有P个结点，每一个结点的状态用0或者1表示，整体服从伯努利分布：</p><ul><li>$\mathbf{v}=[v_1,v_2,…,v_D]^T$</li><li>$\mathbf{h}=[h_1,h_2,…,h_P]^T$</li></ul><p>下面约定权重系数：</p><ul><li>$w_{ij}$表示连接显层结点$v_i$和隐层结点$h_j$的边权重</li><li>$l_{ij}$表示连接两个显层结点$v_i$和$v_j$的边权重</li><li>$j_{ij}$表示连接两个隐层结点$h_i$和$h_j$的边权重</li></ul><p>基于能量定义玻尔兹曼机的概率密度函数</p><script type="math/tex; mode=display">P(\mathbf{v},\mathbf{h})=\frac{e^{-E(\mathbf{v},\mathbf{h})}}{Z}</script><p>其中$Z$为配分函数</p><script type="math/tex; mode=display">Z=\sum\limits_\mathbf{v}\sum\limits_\mathbf{h}e^{-E(\mathbf{v},\mathbf{h})}</script><p>其中$E(\mathbf{v},\mathbf{h})$即为模型的能量，定义为</p><p>$E(\mathbf{v},\mathbf{h})=-(\mathbf{v}^TW\mathbf{h}+\frac{1}{2}\mathbf{v}^TL\mathbf{v}+\frac{1}{2}\mathbf{h}^TJ\mathbf{h})$</p><blockquote><p>上述公式上由三部分构成，可以看作隐层内部、显层内部和隐层显层之间的能量之和。不妨以隐层和显层之间进行分析：取任意两个结点$v_i,h_j$和之间的边$w_{ij}$，计算局部能量</p><script type="math/tex; mode=display">\varepsilon_{ij}=v_iw_{ij}h_j</script><p>则这一部分的总的能量为</p><script type="math/tex; mode=display">\sum\limits_{i=1}^D\sum\limits_{j=1}^P\varepsilon_{ij}=\sum\limits_{i=1}^D\sum\limits_{j=1}^Pv_iw_{ij}h_j=\mathbf{v}^TW\mathbf{h}\in \mathbb{R}</script></blockquote><h2 id="基于对数极大似然估计的梯度上升"><a href="#基于对数极大似然估计的梯度上升" class="headerlink" title="基于对数极大似然估计的梯度上升"></a>基于对数极大似然估计的梯度上升</h2><p>这一部分，我们从极大似然估计出发，对概率密度$P(v,h)$进行极大值推导，其中</p><script type="math/tex; mode=display">P(\mathbf{v},\mathbf{h})=\frac{e^{-E(\mathbf{v},\mathbf{h})}}{Z}</script><p>假设现在有样本集$V$，极大似然估计要求每一个样本出现的概率达到极大值，即边缘密度$\prod\limits_vP(v)$达到最大，其中</p><script type="math/tex; mode=display">P(\mathbf{v})=\sum\limits_\mathbf{h}P(\mathbf{v},\mathbf{h})</script><p>由对数极大似然估计，将乘积进行转换</p><script type="math/tex; mode=display">S=\log\prod\limits_\mathbf{v}P(\mathbf{v})=\sum\limits_\mathbf{v}\log P(\mathbf{v})</script><p>记参数$\theta=[W,J,L]$，它们的含义上文已经提过；只需求解</p><script type="math/tex; mode=display">\frac{\partial S}{\partial \theta}=\sum\limits_\mathbf{v}\frac{\partial \log P(\mathbf{v})}{\partial \theta}</script><p>具体的数学推导见附录，这里直接给出结果</p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial S}{\partial \theta}&=\sum\limits_\mathbf{v}\frac{\partial \log P(\mathbf{v})}{\partial \theta}\\\\ &=\sum\limits_\mathbf{v}\sum\limits_\mathbf{h}P(\mathbf{v},\mathbf{h})\frac{\partial E(\mathbf{v},\mathbf{h})}{\partial \theta}-\sum\limits_\mathbf{h}P(\mathbf{h}|\mathbf{v})\frac{\partial E(\mathbf{v},\mathbf{h})}{\partial \theta} \end{aligned}</script><p>$\theta$由三个参数组成，我们以其中一个为例（$W$）进行说明</p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial S}{\partial W}&=\sum\limits_\mathbf{v}\sum\limits_\mathbf{h}P(\mathbf{v},\mathbf{h})\frac{\partial E(\mathbf{v},\mathbf{h})}{\partial W}-\sum\limits_\mathbf{h}P(\mathbf{h}|\mathbf{v})\frac{\partial E(\mathbf{v},\mathbf{h})}{\partial W}\\\\ &= \sum\limits_\mathbf{v}\sum\limits_\mathbf{h}P(\mathbf{h}|\mathbf{v})\mathbf{v}\mathbf{h}^T-|V|\sum\limits_\mathbf{v}\sum\limits_\mathbf{h}P(\mathbf{v},\mathbf{h})\mathbf{v}\mathbf{h}^T \end{aligned}</script><p>其中$P(h|v)$是真实数据的经验分布，记作$P_{data}$；而$P(v,h)$看作模型的后验分布，记作$P_{model}$。上式用期望表示为</p><script type="math/tex; mode=display">\frac{\partial S}{\partial W}=\mathbb{E}_{p_{data}}(\mathbf{v}\mathbf{h}^T)-\mathbb{E}_{p_{model}}(\mathbf{v}\mathbf{h}^T)</script><p>同理有</p><script type="math/tex; mode=display">\frac{\partial S}{\partial J}=\mathbb{E}_{p_{data}}(hh^T)-\mathbb{E}_{p_{model}}(hh^T)</script><script type="math/tex; mode=display">\frac{\partial S}{\partial L}=\mathbb{E}_{p_{data}}(vv^T)-\mathbb{E}_{p_{model}}(vv^T)</script><p><strong>因此，基于对数极大似然估计的梯度上升法，每一步的参数更新表示为</strong></p><script type="math/tex; mode=display">\begin{aligned} W\gets W+\eta \frac{\partial S}{\partial W} \\ J \gets J+\eta \frac{\partial S}{\partial J} \\ L \gets L+\eta \frac{\partial S}{\partial L} \end{aligned}</script><p>其中$\eta \in \mathbb{R}$指步长。</p><h2 id="基于MCMC的梯度上升"><a href="#基于MCMC的梯度上升" class="headerlink" title="基于MCMC的梯度上升"></a>基于MCMC的梯度上升</h2><p>我们已经建立了基于极大似然估计求出了梯度上升的数学模型。但是实际上对于普通的玻尔兹曼机（并非受限玻尔兹曼机），后验分布是无法求出的。基于MCMC的方法提供了一条解决思路，转化到受限玻尔兹曼机（简称RBM）中求解。</p><p>相比于普通的玻尔兹曼机，RBM有更多特性，都是基于<strong>它的网络结构是一个偶图</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA-16908187093782.jpg" alt="受限玻尔兹曼机"></p><p>显层$v$，隐层$h$，我们约定</p><script type="math/tex; mode=display">v_{-i}=\{ v_1,v_2,\dots, v_D \} - \{v_i\},\quad i\in \{1,2,\dots,D\}</script><p>在<strong>普通的玻尔兹曼机</strong>中有条件概率：</p><script type="math/tex; mode=display">P(v_i=1|h,v_{-i})=\sigma(\sum\limits_{j=1}^PW_{ij}h_j+\sum\limits_{k=1,k\ne i}^DL_{ik}v_k) \\ P(h_j=1|v,h_{-j})=\sigma(\sum\limits_{i=1}^DW_{ij}v_i+\sum\limits_{k=1,k\ne j}^PJ_{jk}h_k)</script><p>在RBM中，由于显层内部、隐层内部不再有边相连，因此<strong>不同的隐层之间的状态互不相关</strong>，下式成立</p><script type="math/tex; mode=display">P(h|v)=\prod\limits_{j=1}^PP(h_j|v)</script><script type="math/tex; mode=display">P(h_j=1|v)=P(h_j=1|v,h_{-j})=\sigma(\sum\limits_{i=1}^DW_{ij}v_i)</script><h2 id="平均场推断"><a href="#平均场推断" class="headerlink" title="平均场推断"></a>平均场推断</h2><p>虽然MCMC可以一定程度上解决上述问题，但是一旦采样规模变大，后验概率仍然无法求出。接下来从变分推断的平均场理论来求出后验概率。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积与逆卷积</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/31/%E5%8D%B7%E7%A7%AF%E4%B8%8E%E9%80%86%E5%8D%B7%E7%A7%AF/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/31/%E5%8D%B7%E7%A7%AF%E4%B8%8E%E9%80%86%E5%8D%B7%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="尺寸计算公式"><a href="#尺寸计算公式" class="headerlink" title="尺寸计算公式"></a>尺寸计算公式</h2><p>先给出两种模式下的输出特征图尺寸计算公式。在二维数据模式（如图像）下，尺寸应该是对两个维度宽、高的大小描述，用元组$(w,h)$描述最为恰当。但是此处，为了统一、方便描述，暂且只考虑某一个维度（比如，宽）上的尺寸，且做出如下约定：</p><ul><li>输入（input）尺寸为$i$</li><li>输出（output）尺寸为$o$</li><li>卷积核（kernel）尺寸为$k$</li><li>步长（stride）为$s$</li><li>填充（padding）为$p$</li><li>out_padding（逆置卷积特有）为$op$</li></ul><p><strong>卷积层</strong>输出尺寸公式描述为</p><script type="math/tex; mode=display">o = \left \lfloor  \frac{i+2p-k}{s} \right \rfloor + 1</script><p><strong>逆置卷积层</strong>输出尺寸公式描述为</p><script type="math/tex; mode=display">o = (i-1)\times s - 2p + k + op</script><h2 id="如何保持图像经过卷积和逆置卷积尺寸不变"><a href="#如何保持图像经过卷积和逆置卷积尺寸不变" class="headerlink" title="如何保持图像经过卷积和逆置卷积尺寸不变"></a>如何保持图像经过卷积和逆置卷积尺寸不变</h2><p>在自编码器等模型中，要求输入数据和模型输出数据尺寸完全一致是很常见的。而这种范式的模型中，通常在编码器部分需要用到下采样等技术对输入数据进行降维，而在解码器部分用到上采样等技术对编码器的紧凑编码结果进行原始数据的重构。其中，下采样技术包括池化，而逆置卷积可以视为上采样技术的一种。</p><p>那么接下来我尝试探究一下满足如何的条件，可以使得数据通过卷积、逆置卷积之后尺寸保持不变呢？</p><p>首先，我们从数学推导开始，也就是上面给出的两个尺寸计算公式。这里，更清晰地，我们记</p><ul><li>最原始的数据尺寸为$i$</li><li>卷积部分的卷积核尺寸为$k_1$，逆置卷积的卷积核尺寸为$k_2$</li><li>卷积部分的步长为$s_1$，逆置卷积部分的步长为$s_2$</li><li>卷积部分的填充为$p_1$，逆置卷积部分的填充为$p_2$</li><li>卷积输出尺寸为$z$，逆置卷积输出尺寸为$o$</li><li>暂且认为逆置卷积特有的$op=0$，原因按下不表</li></ul><p>定义了更加清晰的数学符号后，代入上述公式，得到</p><script type="math/tex; mode=display">z = \left \lfloor  \frac{i+2p_1-k_1}{s_1} \right \rfloor + 1</script><script type="math/tex; mode=display">o = (z-1)\times s_2 - 2p_2 + k_2 + op</script><p>于是，将(3)式代入(4)式，我们得到最终输出尺寸和最初输入尺寸之间的代数关系</p><script type="math/tex; mode=display">o = \left \lfloor  \frac{i+2p_1-k_1}{s_1} \right \rfloor\times s_2 - 2p_2 + k_2 + op</script><p><strong>注意，实际编程时，$z$的结果早已确定，而不是可以人为地和$s_2$进行可能存在的约分</strong>。那么为了能够去除此处的向下取整符号，我们简单分情况讨论一下。</p><ul><li><p>最简单的情况：$s_1=1$。此时有</p><script type="math/tex; mode=display">o = (i+2p_1-k_1) \times s_2 - 2p_2 + k_2 + op</script><p>这时，<strong>逆置卷积层和卷积层的各个参数保持一致（即$p_1=p_2,k_1=k_2,s_1=s_2$，代入上式得到$o=i$），便可以使得输入数据尺寸保持不变（特征图$S_1$通过卷积层、逆置卷积层后得到的特征图$S_2$，两者尺寸一致即$S_1=S_2$）。</strong></p></li><li><p>稍复杂的情况：$s_1 \ne 1$但是$s_1 | (i+2p_1-k_1)$（整除）。此时操作同上，各个参数对应相等即可。</p></li><li><p>最复杂的情况：$s_1 \ne 1$且不存在整除。此时，为了保持数据尺寸不变，就需要用上之前提过的output_padding（$op$）了。此前情况下我们认为$op=0$，设置这个属性的值不为零，其他的各个参数对应相等，可以使得$o$与$i$相等。</p></li></ul><p>综上所述，<strong>在设计模型时</strong>，有时需要精心设计卷积层和逆置卷积的各个参数，使得数据尺寸能够前后匹配一致。如何选择参数上面的数学分析已经给出。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/30/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/30/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>主成分分析是一种使用极为广泛的数据降维方法，比如，给定一组m维数据，可以利用主成分分析，将这组数据降为n维数据，其中$n&lt;m$。</p><h2 id="从最简单的例子谈起"><a href="#从最简单的例子谈起" class="headerlink" title="从最简单的例子谈起"></a>从最简单的例子谈起</h2><p>为了使得主成分分析原理更加直观，当然选择维度为2的情况进行说明：考虑平面上的5个点，我们现在准备将其降维成1维样本点，<strong>也即将二维样本点投影到某条直线上</strong>。</p><blockquote><p>下图是给定的两条直线，两种情况下，原始二维样本点均为A、B、C、D、E；</p><ul><li>第一种情况下，降维后的投影点为G、H、C、J</li><li>第二种情况下，降维后的投影点为H、I、J、K</li></ul><p>为了方便讨论，将投影定义为投影点到原点的距离，已在图中用紫色线段标出。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20221123231428500.png" alt="第一种降维"></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20221123231048106.png" alt="第二种降维"></p><p>给出的两条直线，哪一条直线上的投影更好呢？我们直观感受到，第二种情况效果更好。实际上，相比于第一种情况，第二种情况下，二维点在直线上的投影方差最大，更具有代表性。</p><p>因此，我们从投影方差角度理解主成分分析：</p><p><strong>要把m维数据降维至n维，就需要找到n个互相正交的方向轴，使得原m维数据每一个方向上的投影的方差达到最大。</strong>其中，$n&lt;m$。</p><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><blockquote><p>给定k个样本点，每一个样本点$z^{(i)} \in \mathbb{R}^m$维度均为m，记作Z=$(\mathbf{z}^{(1)},\mathbf{z}^{(2)} ,…,\mathbf{z}^{(k)} )$，下面进行数学推导。</p><p>注意：此处的$\mathbf{z}^{(i)}$以及下文的$\mathbf{x}^{(i)}, \mathbf{u}_i, \xi_{i}$均为列向量。</p></blockquote><p>首先进行中心化，计算均值$\mu=\frac{1}{n}\sum_{i=1}^kz^{(i)}$，中心化之后的样本点即为</p><script type="math/tex; mode=display">\mathbf{x}^{(i)} = \mathbf{z}^{(i)} - \mu</script><p>我们先找第一主轴$u_1$。考虑各个样本点$x_i$在第一主轴上的投影，当方差最大时，也即投影的绝对值最大：</p><script type="math/tex; mode=display">\max_{\mathbf{u}_1}\frac{1}{n}\sum_{i=1}^k|\mathbf{x}^{(i)}·\mathbf{u}_1|</script><p>此处的·表示向量内积，而向量内积表示投影的大小。</p><p>等价地，我们只需求如下式子的最大值：</p><script type="math/tex; mode=display">\begin{aligned} \sum_{i=1}^k(\mathbf{x}^{(i)}·\mathbf{u}_1)^2&=\sum_{i=1}^k(\mathbf{x}^{(i)T}\mathbf{u}_1)^2\\\\ &=\sum_{i=1}^k(\mathbf{x}^{(i)T}\mathbf{u}_1)^T(\mathbf{x}^{(i)T}\mathbf{u}_1)\\\\ &=\sum_{i=1}^k\mathbf{u}_1^T\mathbf{x}^{(i)}\mathbf{x}^{(i)T}\mathbf{u}_1\\\\ &=\mathbf{u}_1^T(\sum_{i=1}^k\mathbf{x}^{(i)}\mathbf{x}^{(i)T})\mathbf{u}_1 \end{aligned}</script><p>记$X=(\mathbf{x}^{(1)},\mathbf{x}^{(2)},…,\mathbf{x}^{(k)})$，则等价变换为</p><script type="math/tex; mode=display">\mathbf{u}_1^TXX^T\mathbf{u}_1</script><p>这是一个二次型。我们接下来求解这个目标式子的最大值，以及$\mathbf{u}_1$取何值时达到最大值。</p><h3 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h3><script type="math/tex; mode=display">\begin{aligned} &\max_{\mathbf{u}_1}\mathbf{u}_1^TXX^T\mathbf{u}_1\\\\  \Rightarrow &\max_{\mathbf{u}_1}(X^T\mathbf{u}_1)^T(X^T\mathbf{u}_1)\\\\ \Rightarrow &\max_{\mathbf{u}_1}||X^T\mathbf{u}_1||_2^2\\\\ \Rightarrow &\max_{\mathbf{u}_1}\left(\frac{||X^T\mathbf{u}_1||_2}{||\mathbf{u}_1||_2}\right)^2 \end{aligned}</script><p><strong>对于矩阵X，它对一个向量$u_1$做变换，前后向量的模长之比的最大值，其实就是矩阵X的最大奇异值。</strong></p><p>因此我们得到目标式子的最大值：</p><script type="math/tex; mode=display">\mathbf{u}_1^TXX^T\mathbf{u}_1=\left(\frac{||X^T\mathbf{u}_1||_2}{||\mathbf{u}_1||_2}\right)^2\leqslant \sigma_{max}(X)</script><h3 id="求第一主轴"><a href="#求第一主轴" class="headerlink" title="求第一主轴"></a>求第一主轴</h3><p>何时取等号呢？</p><p>我们设对称矩阵$XX^T$有$k$个特征值</p><script type="math/tex; mode=display">\lambda_1,\lambda_2,...,\lambda_k</script><p>相应地，有$k$个特征向量</p><script type="math/tex; mode=display">\xi_1,\xi_2,...,\xi_k</script><p>$k$个特征向量两两正交，可以作为一组标准正交基。</p><p>对于任意一个向量$\mathbf{x}$，可以表示为</p><script type="math/tex; mode=display">\mathbf{x}=\sum_{i=1}^k\alpha_i\xi_i</script><p>故而有</p><script type="math/tex; mode=display">||\mathbf{x}||_2^2=(\alpha_1,\alpha_2,...,\alpha_k)·(\alpha_1,\alpha_2,...,\alpha_k)=\sum_{i=1}^k\alpha_i^2</script><script type="math/tex; mode=display">||A\mathbf{x}||_2^2=(A\mathbf{x})^T(A\mathbf{x})=\mathbf{x}^TA^TA\mathbf{x}=\mathbf{x}·(A^TA\mathbf{x})=\left(\sum_{i=1}^k\alpha_i\xi_i\right)·\left(A^TA\sum_{i=1}^k\alpha_i\xi_i\right)</script><p>注意到$A^TA\xi_i=\lambda_i\xi_i$，进而得</p><script type="math/tex; mode=display">\begin{aligned} ||A\mathbf{x}||_2^2 &=\left(\sum_{i=1}^k\alpha_i\xi_i\right)·\left(\sum_{i=1}^k\alpha_i\lambda_i\xi_i\right) \\\\ &=(\alpha_1,\alpha_2,...,\alpha_k)·(\alpha_1\lambda_1,\alpha_2\lambda_2,...,\alpha_k\lambda_k) \\\\ &=\sum_{i=1}^k\alpha_i^2\lambda_i \end{aligned}</script><p>假设特征值从大到小排列，即$\lambda_1\geqslant\lambda_2\geqslant\dots\geqslant\lambda_k$，得</p><script type="math/tex; mode=display">||A\mathbf{x}||_2^2\leqslant\sum_{i=1}^k\alpha_i^2\lambda_1=\lambda_1||\mathbf{x}||_2^2</script><p>同样得到：</p><script type="math/tex; mode=display">\frac{||A\mathbf{x}||_2}{||\mathbf{x}||_2}\leqslant\sqrt{\lambda_1}=\sigma_1</script><p>具体地，此处<strong>$\mathbf{u}_1$为最大特征值$\lambda_1$对应的特征向量方向</strong>。</p><h3 id="求其他主轴"><a href="#求其他主轴" class="headerlink" title="求其他主轴"></a>求其他主轴</h3><p>同理，其他的$\mathbf{u}_i$即为第i大的特征值$\lambda_i$对应的特征向量的方向。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>对于k个m维样本$X_{m\times k}=(x_1,x_2,…,x_k)$（即每一列均为一个样本），我们的目标是将其降到n维：</p><ol><li><p>将样本去中心化：</p><p>$\forall x_i,x_i=x_i-\frac{1}{k}\sum_{j=1}^kx_j$</p><p>$X’=(x_1,x_2,…,x_k)$</p></li><li><p>计算样本的协方差矩阵</p><p>$C_{m\times m}=\frac{1}{k}X’X’^T$</p></li><li><p>求解出C的特征值和对应的特征向量</p><p>$\lambda_1,\lambda_2,…,\lambda_k$($\lambda_1\geqslant\lambda_2\geqslant\dots\geqslant\lambda_k$)</p><p>$\xi_1,\xi_2,…,\xi_k\in R^m$</p></li><li><p>将特征向量按照对应特征值大小从上到下按行排列成矩阵，前n行组成矩阵P</p><p>$P=(\xi_1,\xi_2,\dots,\xi_n)^T$</p></li><li><p>降维</p><p>$Y_{n\times k}=P_{n \times m}X_{m\times k}$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/27/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/27/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>说到二分法，必须要提到的便是<strong>二分查找算法</strong>。</p><blockquote><p>_Problem: Binary Search_</p><p>在一个严格递增序列A中寻找一个指定元素x，如果能找到，那么输出它的下标；如果不能找到，那么输出-1。</p></blockquote><p>以在递增序列$[1,2,4,6,7,9,10,11,15]$中查找元素11为例，演示二分查找法的步骤。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E4%BA%8C%E5%88%86%E6%B3%95.png" alt="二分查找法示意图"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int BinarySearch(int left, int right, int tgt) &#123;    &#x2F;&#x2F; 在[left, right]中查找    while(left &lt; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if(ns[mid] &lt; tgt) &#123;            left &#x3D; mid + 1;        &#125; else if(ns[mid] &gt; tgt) &#123;            right &#x3D; mid;        &#125; else return mid;    &#125;    &#x2F;&#x2F; 到这里，必有left&#x3D;&#x3D;right，退化为    if(ns[left] !&#x3D; tgt)return -1; &#x2F;&#x2F; 没找到    return left;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，二分法也可以使用递归写法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int BinarySearch(int left, int right, int tgt) &#123;    if(left &#x3D;&#x3D; right) &#123;        &#x2F;&#x2F; 如果区间退化为一个点，那么直接判断该点是否就是目标元素        if(ns[left] !&#x3D; tgt)return -1;        elsereturn left;    &#125;    &#x2F;&#x2F; 递归    int mid &#x3D; left + (right - left) &#x2F; 2;    if(ns[mid] &lt; tgt)return BinarySearch(mid+1, right, tgt);    else if(ns[mid] &gt; tgt)return BinarySearch(left, mid, tgt);    elsereturn mid;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="经典例题：旋转数组"><a href="#经典例题：旋转数组" class="headerlink" title="经典例题：旋转数组"></a>经典例题：旋转数组</h2><h3 id="旋转数组中的元素查找"><a href="#旋转数组中的元素查找" class="headerlink" title="旋转数组中的元素查找"></a>旋转数组中的元素查找</h3><blockquote><p>问题链接：<a href="https://sunnywhy.com/sfbj/4/5/164">https://sunnywhy.com/sfbj/4/5/164</a></p><p>旋转数组是指，对一个给定的位置，将数组中该位置右侧（含该位置）的所有元素移至数组最左侧后形成的数组。例如[1,2,3,4,5]将元素3所在位置右侧的部分移到数组最前面后可以形成[3,4,5,1,2]，而将元素4所在位置右侧的部分移到数组最前面后可以形成[4,5,1,2,3]。</p><p>现在给定一个由<strong>严格递增序列</strong>形成的旋转数组A，在其中寻找一个元素x。如果存在，那么输出x所在的下标；否则输出-1。</p></blockquote><p>不妨记序列为<code>ns</code>，而二分法逃不开中间元素<code>ns[mid]</code>，因此先考虑序列中的中间元素<code>ns[mid]</code>与整个序列的关系。假设严格递增序列形成的旋转数组<code>ns</code>为</p><script type="math/tex; mode=display">\mathrm{ns} = [5, 7, 8, 9, 1, 3]</script><p>稍加思索便可发现，<code>ns</code>一定由两段严格递增的序列拼接而成。也就是说，<code>mid</code>划分出来的两段子序列必有至少一侧是严格递增的（如果运气好，<code>mid</code>恰好就是连接点，比如上面例子的下标3，那么其两侧的子序列均为严格递增）。而<strong>只需判断<code>ns[mid]</code>是否大于<code>ns[left]</code>，如果大于，则左侧为严格递增子序列；反之亦然</strong>。判断出哪一侧严格递增后，进一步判断目标元素<code>target</code>是否在整个范围内，进行二分即可。</p><p>具体地，以<code>ns[mid]&gt;ns[left]</code>即左侧为严格递增子序列为例有</p><ul><li>若<code>ns[left]&lt;target&lt;ns[mid]</code>，则搜索区间变为$[left, mid]$；</li><li>否则，搜索区间变为$[mid+1, right]$</li></ul><p>另外注意，应该单独考虑<code>ns[mid]==target</code>这种情况，因为这种情况直接得到答案，可以直接返回结果。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int binarySearch(int left, int right, int tgt) &#123;&#x2F;&#x2F; [5, 7, 8, 9, 1, 3]if(left &#x3D;&#x3D; right)return ns[left] &#x3D;&#x3D; tgt ? left : -1;int mid &#x3D; left + (right - left) &#x2F; 2;if(ns[mid] &#x3D;&#x3D; tgt)return mid;if(ns[mid] &lt; ns[right]) &#123;&#x2F;&#x2F; 旋转点一定在mid左侧，[mid, right]单调递增if(ns[mid] &lt; tgt &amp;&amp; tgt &lt;&#x3D; ns[right])return binarySearch(mid+1, right, tgt);elsereturn binarySearch(left, mid, tgt);&#125; else &#123;&#x2F;&#x2F; 旋转点一定在mid或者mid右侧，[left, mid]单调递增 if(ns[mid] &gt; tgt &amp;&amp; tgt &gt;&#x3D; ns[left])return binarySearch(left, mid, tgt);return binarySearch(mid+1, right, tgt);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旋转数组求原序列中位数"><a href="#旋转数组求原序列中位数" class="headerlink" title="旋转数组求原序列中位数"></a>旋转数组求原序列中位数</h3><p>如何求出原严格递增序列的中位数？其实如果能够找出两个严格递增子序列的“拼接点”，问题便迎刃而解了：左侧子序列元素均大于右侧子序列元素，而两个子序列内部严格递增，此时只需要$\mathcal{O}(1)$时间便可求出中位数。于是关键在于求出拼接点。</p><p>和前一部分类似地，要进行二分，就要判断拼接点到底在左侧区间还是右侧区间。而根据<strong>“只需判断<code>ns[mid]</code>是否大于<code>ns[left]</code>，如果大于，则左侧为严格递增子序列；反之亦然”</strong>，拼接点不可能出现在严格递增子序列中，只可能出现在另一侧，于是可以得到如下代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int binarySearch(int left, int right) &#123;    while(left &lt; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        &#x2F;&#x2F; 如果满足ns[mid]&gt;ns[mid+1]，那么mid就是拼接点下标        if(ns[mid] &gt; ns[mid+1])return mid;        if(ns[mid] &gt; ns[left]) &#123;            &#x2F;&#x2F; [left, mid]严格递增，拼接点只可能出现在[mid+1, right]            left &#x3D; mid + 1;        &#125; else &#123;            &#x2F;&#x2F; [mid+1, right]严格递增，拼接点只可能出现在[left, mid]            right &#x3D; mid;        &#125;    &#125;    &#x2F;&#x2F; 此时必有left &#x3D;&#x3D; right，退化为一个点，由于拼接点必然存在，因此直接返回    return left;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到拼接的下标后，根据序列长度奇偶性取出数组中中间元素便不难了。下面是完整的代码。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std;&#x2F;* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop *&#x2F;vector&lt;int&gt; ns;int binarySearch(int left, int right) &#123;while(left &lt; right) &#123;int mid &#x3D; left + (right - left) &#x2F; 2;if(ns[mid] &gt; ns[mid+1])return mid;if(ns[mid] &gt; ns[left])left &#x3D; mid + 1;elseright &#x3D; mid;&#125;return left;&#125;int main(int argc, char** argv) &#123;int n;scanf(&quot;%d&quot;, &amp;n);while(n--) &#123;int a;scanf(&quot;%d&quot;, &amp;a);ns.push_back(a);&#125;int idx &#x3D; binarySearch(0, ns.size()-1);if(ns.size() % 2) &#123;printf(&quot;%.1lf&quot;, ns[(idx+1+ns.size()&#x2F;2)%ns.size()]&#x2F;1.0);&#125; else &#123;int tmp &#x3D; (idx + ns.size()&#x2F;2) % ns.size();printf(&quot;%.1lf&quot;, (ns[tmp] + ns[(tmp+1)%ns.size()])&#x2F;2.0);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>To be continued…</p>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/27/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/27/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="算法背景"><a href="#算法背景" class="headerlink" title="算法背景"></a>算法背景</h2><p>SVM有三宝：间隔、对偶、核技巧。</p><h3 id="宝一：间隔"><a href="#宝一：间隔" class="headerlink" title="宝一：间隔"></a>宝一：间隔</h3><p>从间隔角度来看，支持向量机可以分为三种：</p><ul><li>硬间隔支持向量机</li><li>软间隔支持向量机</li><li>核支持向量机</li></ul><h4 id="硬间隔SVM"><a href="#硬间隔SVM" class="headerlink" title="硬间隔SVM"></a>硬间隔SVM</h4><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/diagram-1.png" alt="（硬间隔）支持向量机直观图（二维）"></p><p>给定一组样本集合：$\{ (\mathbf{x}^{(1)}, y^{(1)}), (\mathbf{x}^{(2)}, y^{(2)}), \cdots, (\mathbf{x}^{(N)}, y^{(N)}) \}$，其中$\mathbf{x}^{(i)}\in \mathbb{R}^p, y^{(i)}\in \{-1,1\}$。</p><p>上图是二维数据情况下，支持向量机对样本的二分类的直观描述：<strong>找到一条超平面，将两类样本完全分开</strong>。而满足这个条件的超平面其实是有无数个的，究竟该选择哪一个呢？有如下限制：<strong>选取间隔最大的超平面，它恰好能够将不同类别完全分开。</strong></p><p>我们先将“间隔”按下不表，来用简洁的数学语言描述一下最简单的支持向量机：</p><script type="math/tex; mode=display">\begin{aligned} &\max \mathrm{margin}(\mathbf{w},b) \\\\ &s.t. (\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)} > 0 \end{aligned}</script><p>注意这里我们将条件</p><script type="math/tex; mode=display">\begin{cases} \mathbf{w}^T\mathbf{x}^{(i)}+b>0, y^{(i)}=1 \\\\ \mathbf{w}^T\mathbf{x}^{(i)}+b<0, y^{(i)}=-1  \end{cases}</script><p>统一成一个</p><script type="math/tex; mode=display">(\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)} > 0</script><p>接下来我们关注一下所谓的“间隔”$\mathrm{margin}$。<strong>间隔实际上指的是所有的点到该超平面的距离（$\mathrm{dis}$）的最小值</strong>。由点到直线距离公式，可知样本$(\mathbf{x}^{(i)},y^{(i)})$到超平面$\mathbf{w}^T\mathbf{x}+b=0$的距离为</p><script type="math/tex; mode=display">\mathrm{dis}^{(i)} = \frac{|\mathbf{w}^T\mathbf{x}^{(i)}+b|}{||\mathbf{w}||}</script><p>借助标签，进一步将$\mathrm{dis}$绝对值去除：</p><script type="math/tex; mode=display">\mathrm{dis}^{(i)} = \frac{(\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)}}{||\mathbf{w}||}</script><p>故支持向量机描述为：</p><script type="math/tex; mode=display">\begin{aligned} &\max_{\mathbf{w},b}\min_{i} \frac{(\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)}}{||\mathbf{w}||} \\\\ &s.t. (\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)} > 0  \end{aligned}</script><p>接下来我们继续推导目标函数，将形式简化：</p><script type="math/tex; mode=display">\max_{\mathbf{w},b}\frac{1}{||\mathbf{w}||}\min_{i}y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b)</script><p>这个式子很有意思。首先一定有</p><script type="math/tex; mode=display">\exists \gamma > 0, s.t.\gamma=\min_iy^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b)</script><p>事实上，$\gamma$取值并不重要，因为对$\mathbf{w},b$的等比例缩放并不会影响到其所表示的超平面，换言之，下面两个超平面其实是完全等价的：</p><script type="math/tex; mode=display">\begin{cases} \mathbf{w}^T\mathbf{x}^{(i)}+b=0 \\\\ \frac{\mathbf{w}^T}{\gamma}\mathbf{x}^{(i)} + \frac{b}{\gamma}=0 \end{cases}</script><p>因此，为方便后续运算，令$\gamma=1$，进而得到待优化的目标函数与约束条件</p><script type="math/tex; mode=display">\begin{aligned} &\max_{\mathbf{w},b}\frac{1}{||\mathbf{w}||} \\\\ &s.t.(\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)} \geqslant 1 \end{aligned}</script><p>而通常我们习惯求解最小优化问题，于是最终的支持向量机描述为</p><script type="math/tex; mode=display">\begin{aligned} &\min_{\mathbf{w},b} \frac{||\mathbf{w}||}{2} \\\\ &s.t. (\mathbf{w}^T\mathbf{x}^{(i)}+b)y^{(i)} \geqslant 1  \end{aligned}</script><p>接下来我们尝试求解这个带约束优化问题。</p><h4 id="求解约束优化问题"><a href="#求解约束优化问题" class="headerlink" title="求解约束优化问题"></a>求解约束优化问题</h4><p>对于约束优化问题，引入拉格朗日函数，将其转化为无约束优化问题：</p><script type="math/tex; mode=display">\begin{aligned} &\min_{\mathbf{w},b}\max_{\Lambda}\mathcal{L}(\mathbf{w},b,\Lambda) \\\\ &s.t. \Lambda \geqslant 0 \end{aligned}</script><p>其中$\Lambda=[\lambda_1,\lambda_2,\cdots,\lambda_N], \mathbf{w}=[w_1,w_2,\cdots,w_N]$</p><p>根据强对偶条件，该优化问题也可等价于：</p><script type="math/tex; mode=display">\begin{aligned} &\max_{\Lambda}\min_{\mathbf{w},b}\mathcal{L}(\mathbf{w},b,\Lambda) \\\\ &s.t. \Lambda \geqslant 0 \end{aligned}</script><p>拉格朗日函数为</p><script type="math/tex; mode=display">\mathcal{L}(\mathbf{w},b,\Lambda)=\frac{||\mathbf{w}||}{2} + \sum_{i=1}^N\lambda_i(1-y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b))</script><p>关于约束优化问题(8)(9)(10)之间的等价性，下面从逻辑分析角度进行简单的分析（并非严格的数学证明）。</p><h5 id="9-到-8"><a href="#9-到-8" class="headerlink" title="(9)到(8)"></a>(9)到(8)</h5><p>相比于(8)，(9)实际上是一个无约束问题。我们分别考虑下面两种情况：</p><ol><li>$\exists i \in \{1,2,\cdots,N\}, s.t. 1-y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b)&gt;0$</li><li>$\forall i \in \{1,2,\cdots,N\}, 1-y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b) \leqslant 0$</li></ol><p>对于第一情况，显然取$\lambda_i=\infty$，有</p><script type="math/tex; mode=display">\max_{\Lambda}\mathcal{L}(\mathbf{w},b,\Lambda) = \infty</script><p>对于第二种情况，显然取$\Lambda=\mathbf{0}$，有</p><script type="math/tex; mode=display">\max_{\Lambda}\mathcal{L}(\mathbf{w},b,\Lambda)=\frac{||\mathbf{w}||}{2}</script><p>综上有</p><script type="math/tex; mode=display">\min_{\mathbf{w},b}\max_{\Lambda}\mathcal{L}(\mathbf{w},b,\Lambda)=\min_{\mathbf{w},b}\left\{ \infty, \frac{||\mathbf{w}||}{2} \right\}=\min_{\mathbf{w},b}\frac{||\mathbf{w}||}{2}</script><p>换言之，(9)通过改变待优化目标函数的形式，将(8)中的约束条件隐式地包含了，故而不再需要额外的约束条件。</p><h5 id="9-和-10"><a href="#9-和-10" class="headerlink" title="(9)和(10)"></a>(9)和(10)</h5><p>这两个约束优化问题互为对偶问题。且此时待优化函数是凸函数，满足<strong>强对偶</strong>条件，因此它们等价。</p><blockquote><p><strong>对偶问题</strong></p><p>原问题DP如下</p><script type="math/tex; mode=display">\max_{\mathbf{w},b}\min_i \mathcal{L}(\mathbf{w},b,\Lambda)</script><p>其对偶问题LP为</p><script type="math/tex; mode=display">\min_i\max_{\mathbf{w},b}\mathcal{L}(\mathbf{w},b,\Lambda)</script><p>记DP问题的最优解为$d^<em>$，LP问题的最优解为$p^</em>$，则有</p><script type="math/tex; mode=display">d^*\leqslant p^*</script><p>上式也称为<strong>弱对偶条件</strong>。</p><p>而当约束函数为凸函数时，有$d^<em>=p^</em>$，此时称为<strong>强对偶</strong>。</p></blockquote><h5 id="求解最小优化问题"><a href="#求解最小优化问题" class="headerlink" title="求解最小优化问题"></a>求解最小优化问题</h5><p>我们对优化问题(10)进行求解：</p><script type="math/tex; mode=display">\begin{aligned} &\max_{\Lambda}\min_{\mathbf{w},b}\mathcal{L}(\mathbf{w},b,\Lambda) \\\\ &s.t. \Lambda \geqslant 0 \end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\mathcal{L}(\mathbf{w},b,\Lambda)=\frac{||\mathbf{w}||}{2} + \sum_{i=1}^N\lambda_i(1-y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b))</script><p>先求解最小优化问题：显然只需对$\mathbf{w},b$求偏导即可。</p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial \mathcal{L}}{\partial \mathbf{w}} &= \mathbf{w} - \sum_{i=1}^N\lambda_iy^{(i)}\mathbf{x}^{(i)} \\\\ \frac{\partial \mathcal{L}}{\partial b} &= -\sum_{i=1}^N \lambda_iy^{(i)} \end{aligned}</script><p>令偏导数为零，得到</p><script type="math/tex; mode=display">\begin{aligned} &\mathbf{w}^*= \sum_{i=1}^N \lambda_iy^{(i)}\mathbf{x}^{(i)} \\\\ &\sum_{i=1}^N\lambda_iy^{(i)}=0 \end{aligned}</script><p> 接下来，将上式代入$\mathcal{L}$，整理得</p><script type="math/tex; mode=display">\begin{aligned} \min_{\mathbf{w},b} \mathcal{L}(\mathbf{w},b,\Lambda) &= \frac{||\sum_{i=1}^N \lambda_iy^{(i)}\mathbf{x}^{(i)}||}{2} - \sum_{i=1}^N\lambda_iy^{(i)}\left( \sum_{j=1}^N\lambda_jy^{(j)}\mathbf{x}^{(j)} \right)^T\mathbf{x}^{(i)} + \sum_{i=1}^N\lambda_i \\\\ &= \frac{1}{2}\left( \sum_{i=1}^N \lambda_iy^{(i)}\mathbf{x}^{(i)} \right)^T\left( \sum_{i=1}^N \lambda_iy^{(i)}\mathbf{x}^{(i)} \right) - \sum_{i=1}^N\sum_{j=1}^N \lambda_i\lambda_jy^{(i)}y^{(j)}<\mathbf{x}^{(i)},\mathbf{x}^{(j)}> + \sum_{i=1}^N\lambda_i \\\\ &=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\lambda_i\lambda_jy^{(i)}y^{(j)}<\mathbf{x}^{(i)},\mathbf{x}^{(j)}> - \sum_{i=1}^N\sum_{j=1}^N\lambda_i\lambda_jy^{(i)}y^{(j)}<\mathbf{x}^{(i)},\mathbf{x}^{(j)}> + \sum_{i=1}^N\lambda_i \\\\ &= -\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\lambda_i\lambda_jy^{(i)}y^{(j)}<\mathbf{x}^{(i)},\mathbf{x}^{(j)}> + \sum_{i=1}^N\lambda_i \end{aligned}</script><p> 到这里，我们得到如下等价的优化问题：</p><script type="math/tex; mode=display">\begin{aligned} &\max_{\Lambda} -\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\lambda_i\lambda_jy^{(i)}y^{(j)}<\mathbf{x}^{(i)},\mathbf{x}^{(j)}> + \sum_{i=1}^N\lambda_i \\\\ &s.t. \Lambda\geqslant 0 \\\\ & \quad \sum_{i=1}^N\lambda_iy^{(i)}=0 \end{aligned}</script><h5 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h5><p>转化到上述优化问题后，可以通过一些特定软件求解参数$\lambda_1,\lambda_2,\cdots,\lambda_N$，进而将该问题解决。下面介绍另一部分非常重要的内容：KKT条件。</p><p>由于带约束优化问题满足强对偶，因此它满足KKT条件。而KKT条件包括原始可行性、对偶可行性和互补松弛条件，即</p><script type="math/tex; mode=display">\begin{aligned} \nabla_\mathbf{w}\mathcal{L}=\nabla_{b}\mathcal{L}=0 \\\\ \lambda_i(1-y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b)) = 0 \\\\ \Lambda \geqslant 0 \\\\ 1-y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b) \leqslant 0 \end{aligned}</script><p>上述条件中，第一个式子在前文已经利用到，得到的结果即(21)。下面来思考一下第二个式子的含义：事实上，第二个式子（互补松弛条件）揭示了这样的一个真相：<strong>只有位于超平面$\mathbf{w}^T\mathbf{x}+b=1$和$\mathbf{w}^T\mathbf{x}+b=-1$上的样本点才对优化目标函数的值产生了影响</strong>（否则对应的拉格朗日乘子$\lambda_i$均为零）。多提一句，<strong>我们把这样的点称为支持向量，这正是算法模型名称的由来</strong>。</p><blockquote><p><strong>关于支持向量</strong></p><p>事实上，我们前面通过限定函数间隔定义过几何间隔：也就是说，所有样本点中，与决策超平面$\mathbf{w}^T\mathbf{x}+b=0$最近的点与之距离为$\frac{1}{||w||}$。可以利用点到距离公式验证，这样的点（也即支持向量）所在超平面就是$\mathbf{w}^T\mathbf{x}+b=1$以及$\mathbf{w}^T\mathbf{x}+b=-1$。</p></blockquote><p>那么，一定有</p><script type="math/tex; mode=display">\exists k\in \{1,2,\cdots,N\}, s.t.\quad 1-y^{(k)}(\mathbf{w}^T\mathbf{x}^{(k)}+b)=0</script><p>故而有</p><script type="math/tex; mode=display">\begin{aligned} y^{(k)}(\mathbf{w}^T\mathbf{x}^{(k)}+b)&=1 \\\\ \mathbf{w}^T\mathbf{x}^{(k)}+b&=y^{(k)} \\\\ b&=y^{(k)}-\mathbf{w}^T\mathbf{x}^{(k)}  \end{aligned}</script><p>结合(21)，得到最终的最优解</p><script type="math/tex; mode=display">\begin{aligned} \mathbf{w}^*&=\sum_{i=1}^N\lambda_iy^{(i)}\mathbf{x}^{(i)} \\\\b^*&=y^{(k)}-\sum_{i=1}^N\lambda_iy^{(i)}\mathbf{x}^{(i)T}\mathbf{x}^{(k)} \end{aligned}</script><h4 id="软间隔SVM"><a href="#软间隔SVM" class="headerlink" title="软间隔SVM"></a>软间隔SVM</h4><p>其实到这里，已经注意到了：上面的SVM实际上是找到一个最优的决策超平面将样本严格分开，因此它被称为<strong>硬间隔SVM</strong>。与之相对地，如果构建的SVM允许分类中出现一点点错误，以此来换取更好的泛化能力，这种模型则称为<strong>软间隔SVM</strong>。</p><p>在硬间隔SVM中，约束条件是严格的：</p><script type="math/tex; mode=display">y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b) \geqslant 1</script><p>而软间隔的引入实际上是对原来的目标函数加上一个惩罚项。首先，上述约束条件被放松，不再严格要求成立。另外需要引入一个参数$\xi_i$用于衡量这种“犯错误的程度”，即当$y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b)&lt;1$时，</p><script type="math/tex; mode=display">\xi_i= 1 - y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b)</script><p>注意，$\xi_i \geqslant 0$。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/diagram-1-16907197956691.png" alt="（软间隔）支持向量机直观图（二维）"></p><p>显然，$\xi_i$越大，表明样本“违反”原严格条件的程度越大，越应该受到惩罚。我们在原硬间隔SVM的目标函数基础上，添加一个带有惩罚系数$\mathcal{C}$的惩罚项，于是得到最终的<strong>软间隔SVM</strong>优化问题：</p><script type="math/tex; mode=display">\begin{aligned} &\min_{\mathbf{w},b}\frac{1}{2}||\mathbf{w}||+\mathcal{C}\sum_{i=1}^N\xi_i \\\\ &s.t. y^{(i)}(\mathbf{w}^T\mathbf{x}^{(i)}+b) \geqslant 1-\xi_i \\\\ & \quad \quad \xi_i \geqslant 0  \end{aligned}</script><p>To be continued…</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于MNIST数据集的小样本创新实践</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/25/%E5%9F%BA%E4%BA%8EMNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/25/%E5%9F%BA%E4%BA%8EMNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本实验来自学校课程《人工智能概论》实验三以及创新实践部分。具体的代码已经上传至个人github仓库，仓库地址：<a href="https://github.com/Luqingbys/mnist-classification">https://github.com/Luqingbys/mnist-classification</a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>实验目标：基于特定图像数据集，研究人工神经网络分类器的设计与实现方法。</p><p>实验要求：基于MNIST手写数字图像数据集，完成神经网络模型的网络设计及参数选择，并在训练集上进行训练，在测试集上进行性能评估。了解Pytorch或TensorFlow等深度学习框架，基于上述算法库完成实验内容。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="训练集分组"><a href="#训练集分组" class="headerlink" title="训练集分组"></a>训练集分组</h3><p>MNIST数据集是深度学习领域中的入门数据集，包含了不同人士的手写数字（0~9）的数字图像。其中，训练集包含了60000张手写数字图片，测试集包含了10000张图片，且各个类别的图片数量比较均衡。图像和标签文件中，数据均以二进制形式存储。</p><p>为了方便本部分实验将原始的完整训练集进行抽样分组，首先下载数据集后，按照类别划分出10个文件夹，存放每一个类别的图像。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">makeMnistPng</span><span class="token punctuation">(</span>image_dsets<span class="token punctuation">,</span> save_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''     将原始的二进制图像转存为.png格式，并分类文件夹存放    image_dsets: torchvision.datasets    save_path: str, default('data/MNIST/png/')    '''</span>    toPIL <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToPILImage<span class="token punctuation">(</span><span class="token punctuation">)</span>    initial_path <span class="token operator">=</span> save_path    <span class="token keyword">for</span> idx <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Making image file as .png for index &#123;&#125;......"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>        num_img <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># dir_path = './mnist_all/'</span>        save_path <span class="token operator">=</span> initial_path <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>save_path<span class="token punctuation">)</span><span class="token punctuation">:</span>            os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>save_path<span class="token punctuation">)</span>        <span class="token keyword">for</span> image<span class="token punctuation">,</span> label <span class="token keyword">in</span> image_dsets<span class="token punctuation">:</span>            <span class="token comment"># image: (1, 28, 28), label: (1, )</span>            <span class="token keyword">if</span> label <span class="token operator">==</span> idx<span class="token punctuation">:</span>                filename <span class="token operator">=</span> save_path <span class="token operator">+</span><span class="token string">'/mnist_'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>num_img<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.png'</span> <span class="token comment"># 'data/MNIST/png/1/mnist_666-1.png' .png前的一个字符必定是label</span>                <span class="token comment"># print(image.shape, label)</span>                <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>                    pic <span class="token operator">=</span> toPIL<span class="token punctuation">(</span>image<span class="token punctuation">)</span>                    pic<span class="token punctuation">.</span>save<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>                    <span class="token comment"># image.save(filename)</span>                num_img <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Success to make MNIST PNG image files. index=&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全连接神经网络"><a href="#全连接神经网络" class="headerlink" title="全连接神经网络"></a>全连接神经网络</h3><div class="table-container"><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>网络层数</td><td>2层全连接层</td></tr><tr><td>网络规模</td><td>输入层神经元数量28*28，  隐藏层神经元数量256，  输出层神经元数量10</td></tr><tr><td>激活函数</td><td>ReLU</td></tr><tr><td>学习率</td><td>0.001</td></tr><tr><td>损失函数</td><td>交叉熵损失</td></tr><tr><td>优化器</td><td>Adam</td></tr><tr><td>批量大小</td><td>32</td></tr><tr><td>训练轮数</td><td>5</td></tr></tbody></table></div><p>网络的输入是一个28×28即784维的一维向量，即原始图像的全部像素。由于图像尺寸均为28×28，在将图像送入网络前，需要将二维图像展平为一维向量。网络结构图如下。</p><p><img src="D:\我的大学\newBlogs\source\_posts\assets\基于MNIST数据集的小样本创新实践.assets\image-20230725093345800.png" alt="全连接层"></p><p>在10%、30%、50%、70%和100%的原始训练集情况下，进行模型的训练和测试。每一组实验模型均训练5轮。这里仅给出10%原始训练集情况下的实验结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725093838022.png" alt="训练损失变化情况"></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725093927610.png" alt="训练准确率变化情况"></p><p>训练全连接层模型完毕后，在完整测试集上的测试结果如下。</p><div class="table-container"><table><thead><tr><th></th><th><strong>precision</strong></th><th><strong>recall</strong></th><th><strong>f1-score</strong></th><th><strong>support</strong></th></tr></thead><tbody><tr><td>0</td><td>0.928092042</td><td>0.987755102</td><td>0.956994563</td><td>980</td></tr><tr><td>1</td><td>0.985777778</td><td>0.977092511</td><td>0.981415929</td><td>1135</td></tr><tr><td>2</td><td>0.954500495</td><td>0.935077519</td><td>0.944689183</td><td>1032</td></tr><tr><td>3</td><td>0.960122699</td><td>0.92970297</td><td>0.944668008</td><td>1010</td></tr><tr><td>4</td><td>0.913544669</td><td>0.968431772</td><td>0.94018784</td><td>982</td></tr><tr><td>5</td><td>0.960693642</td><td>0.93161435</td><td>0.945930563</td><td>892</td></tr><tr><td>6</td><td>0.949795082</td><td>0.967640919</td><td>0.958634953</td><td>958</td></tr><tr><td>7</td><td>0.944123314</td><td>0.953307393</td><td>0.948693127</td><td>1028</td></tr><tr><td>8</td><td>0.934443288</td><td>0.921971253</td><td>0.928165375</td><td>974</td></tr><tr><td>9</td><td>0.951143451</td><td>0.906838454</td><td>0.928462709</td><td>1009</td></tr><tr><td>accuracy</td><td>0.9483</td><td>0.9483</td><td>0.9483</td><td>0.9483</td></tr></tbody></table></div><p>全连接网络在各个训练集上的测试结果如下。</p><div class="table-container"><table><thead><tr><th>训练集样本数量</th><th>测试集准确率</th></tr></thead><tbody><tr><td>10%的原始训练集</td><td>0.9483</td></tr><tr><td>30%的原始训练集</td><td>0.9639</td></tr><tr><td>50%的原始训练集</td><td>0.9705</td></tr><tr><td>70%的原始训练集</td><td>0.9755</td></tr><tr><td>100%的原始训练集</td><td>0.9731</td></tr></tbody></table></div><h2 id="小样本创新实践"><a href="#小样本创新实践" class="headerlink" title="小样本创新实践"></a>小样本创新实践</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>以10%抽样的训练集数据为训练样本，剩余的训练样本可根据需要作为无标签数据进行利用。请查阅有关课外文献，探索新的特征表示或分类模型，要求是深度神经网络类型的学习方法。包括有监督、半监督或无监督等模式均可，代表性的方法如深度卷积网络、生成式对抗网络、强化学习、Transformer、自监督学习、去噪/变分自编码器等。在完整的测试集上进行性能的评估。本部分的撰写内容自行安排，将样本的选择、模型的构建、参数的设定、训练过程及结果进行清晰的描述与展示即可。要注重实验结果的对比，结合实验结果的分析得出模型的优点与缺点，以及可能改进的方向。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>五种解决方案：</p><ul><li>基于卷积神经网络的监督学习模式</li><li>基于深度卷积神经网络的迁移学习模式</li><li>基于自编码器的半监督学习模式</li><li>基于变分自编码器的半监督学习模式</li><li>基于条件对抗生成网络的数据增强</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/mnist.jpg" alt="解决方案图示"></p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><blockquote><p>卷积神经网络是一种有效处理图像分类问题的模型。相比于全连接网络，它有两大特点：关注局部信息、权值共享。前者由卷积操作决定，卷积核在图像像素之间进行窗口滑动，每次只有窗口内部的像素参与运算，如此使得卷积可以额外关注某些局部特征；后者则是因为单轮的扫描过程中，卷积核参数并不会发生变化，相当于此间所有的像素共享卷积核参数，如此可以大大减少模型参数数量。</p></blockquote><p>基于卷积神经网络的监督学习模式是很经典的图像分类解决方案。本实验用到的卷积神经网络结构比较简单，配置见表。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725094352553.png" alt="卷积神经网络结构"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BasicConv</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>BasicConv<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv2_drop <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout2d<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>F<span class="token punctuation">.</span>max_pool2d<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>F<span class="token punctuation">.</span>max_pool2d<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2_drop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>x<span class="token punctuation">,</span> training<span class="token operator">=</span>self<span class="token punctuation">.</span>training<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> F<span class="token punctuation">.</span>log_softmax<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="深度卷积神经网络"><a href="#深度卷积神经网络" class="headerlink" title="深度卷积神经网络"></a>深度卷积神经网络</h4><blockquote><p>事实上，目前已经有很多经典的深度卷积神经网络，比如ResNet[1]、DenseNet[2]等等。而我们使用一个预先训练好的模型作为基础，并改变最后几层，以便我们可以根据想要的类对图像进行分类。这种迁移学习模式，可以使我们在使用小数据集时获得更好的效果。因为在预训练模型中，已经从更大的数据集（如ImageNet）学习了基本的图像特征。</p></blockquote><p>这里，我们直接从网络上下载并导入经典深度卷积网络ResNet-50，具体的解决方案描述如下。</p><ol><li><p>导入预训练好的ResNet50模型；</p><p><code>self.resnet50 = models.resnet50(pretrained=True)</code></p></li><li><p>冻结ResNet模型的参数梯度，并将最后几层替换为适合本次实验所需的数据集分类的分类层；</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> param <span class="token keyword">in</span> self<span class="token punctuation">.</span>resnet50<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>param<span class="token punctuation">.</span>requires_grad <span class="token operator">=</span> <span class="token boolean">False</span>fc_inputs <span class="token operator">=</span> self<span class="token punctuation">.</span>resnet50<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>in_features    <span class="token comment"># 添加分类层</span>self<span class="token punctuation">.</span>resnet50<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>fc_inputs<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>LogSoftmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># For using NLLLoss()</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将预训练、微调的模型作为我们自己的模型进行训练、测试、评估。</p></li></ol><h4 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h4><h5 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h5><p>自编码器由两个部分组成，编码器和解码器。数学描述为</p><script type="math/tex; mode=display">\hat{x}=g(f(x))</script><p>编码器$f$由两层卷积层、两层全连接层组成，而解码器$g$的结构则与编码器相反。整个自编码器的结构如图。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725101005260.png" alt="自编码器结构"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AE</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_channels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> z_dim<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>AE<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'AE has been created!'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>z_dim <span class="token operator">=</span> z_dim        self<span class="token punctuation">.</span>encoder <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># [?,128,7,7]</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">6272</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> z_dim<span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># (b, 1, 28, 28) => (b, 1024) => (b, 20)</span>        self<span class="token punctuation">.</span>decoder <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>z_dim<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">6272</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Unflatten<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">encode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        h <span class="token operator">=</span> self<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token comment">#print('h: ', h.shape)</span>        <span class="token keyword">return</span> h        <span class="token keyword">def</span> <span class="token function">decode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>h<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="训练与评估"><a href="#训练与评估" class="headerlink" title="训练与评估"></a>训练与评估</h5><p>对于半监督学习，先在除开带标签的无标签数据集上训练自编码器，得到收敛的预训练模型，然后在有标签的训练集上训练分类器。<strong>注意，分类器可以相对弱化了，这里选取的就是简单的knn和mlp模型</strong>。最后，预训练模型和训练好的分类器一起组成新的模型在完整的测试集上进行测试。</p><p>预训练自编码器的代码如下。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train_ae</span><span class="token punctuation">(</span>net<span class="token punctuation">:</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">,</span> z_dim<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> trainloader<span class="token punctuation">,</span> validloader<span class="token punctuation">,</span> epochs<span class="token punctuation">,</span> valid_every<span class="token punctuation">,</span> output<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e-3</span><span class="token punctuation">)</span>start_epoch <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/reconstructed'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/reconstructed'</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/random_sample'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/random_sample'</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/weight'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/weight'</span><span class="token punctuation">)</span><span class="token comment"># training</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>start_epoch<span class="token punctuation">,</span> epochs<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> data <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>trainloader<span class="token punctuation">)</span><span class="token punctuation">:</span>            inputs <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>recon <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>recon_loss <span class="token operator">=</span> loss_func<span class="token punctuation">(</span>recon<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token comment"># zero out the paramter gradients</span>optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>recon_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># print statistics every 100 batches</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Epoch[&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Reconst Loss: &#123;:.4f&#125;"</span>  <span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> epochs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>trainloader<span class="token punctuation">)</span><span class="token punctuation">,</span> recon_loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token comment"># 重构图像可视化</span>x_concat <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>inputs<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">,</span> recon<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>save_image<span class="token punctuation">(</span>x_concat<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"./%s/reconstructed/epoch-%d.png"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>output<span class="token punctuation">,</span> epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># valid</span><span class="token keyword">if</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> valid_every <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>valid_avg_loss <span class="token operator">=</span> <span class="token number">0.0</span>best_valid_loss <span class="token operator">=</span> np<span class="token punctuation">.</span>inf<span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">for</span> idx<span class="token punctuation">,</span> valid_data <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>validloader<span class="token punctuation">)</span><span class="token punctuation">:</span>valid_inp <span class="token operator">=</span> valid_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token comment"># forward</span>valid_res <span class="token operator">=</span> net<span class="token punctuation">(</span>valid_inp<span class="token punctuation">)</span>valid_recon_loss <span class="token operator">=</span> loss_func<span class="token punctuation">(</span>valid_res<span class="token punctuation">,</span> valid_inp<span class="token punctuation">)</span>valid_avg_loss <span class="token operator">+=</span> valid_recon_lossvalid_avg_loss <span class="token operator">/=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>validloader<span class="token punctuation">.</span>dataset<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'valid loss:'</span><span class="token punctuation">,</span> valid_avg_loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># randomly sample some images' latent vectors from its distribution</span>z <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> z_dim<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>random_res <span class="token operator">=</span> net<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span>save_image<span class="token punctuation">(</span>random_res<span class="token punctuation">,</span> <span class="token string">"./%s/random_sample/epoch-%d.png"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>output<span class="token punctuation">,</span> epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># save model</span>is_best <span class="token operator">=</span> valid_avg_loss <span class="token operator">&lt;</span> best_valid_lossbest_valid_loss <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>valid_avg_loss<span class="token punctuation">,</span> best_valid_loss<span class="token punctuation">)</span><span class="token keyword">if</span> is_best<span class="token punctuation">:</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/weight/model_best.pth'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>output<span class="token operator">+</span><span class="token string">'/weight/model_final.pth'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Train finished!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自编码器训练完成后，保存为模型model，用它来提取原始数据集的特征。定义好训练集数据迭代器trainDataloader后，将读取出来的原始数据集喂给model，即可得到压缩后的特征，而这些特征正是喂给分类器的数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> imgs<span class="token punctuation">,</span> labels <span class="token keyword">in</span> trainDataloader<span class="token punctuation">:</span>    <span class="token comment"># model是训练好的自编码器</span>    features <span class="token operator">=</span> model<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    X<span class="token punctuation">.</span>append<span class="token punctuation">(</span>features<span class="token punctuation">)</span>    y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来训练分类器。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">model <span class="token operator">=</span> Mlp<span class="token punctuation">(</span>latent_dim<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e-3</span><span class="token punctuation">)</span>classifier <span class="token operator">=</span> Classifier<span class="token punctuation">(</span>model<span class="token operator">=</span>model<span class="token punctuation">,</span> features<span class="token operator">=</span>X<span class="token punctuation">,</span> labels<span class="token operator">=</span>y<span class="token punctuation">,</span> test_features<span class="token operator">=</span>X_test<span class="token punctuation">,</span> test_labels<span class="token operator">=</span>y_test<span class="token punctuation">,</span> lossFunc<span class="token operator">=</span>loss<span class="token punctuation">,</span> optimizer<span class="token operator">=</span>optimizer<span class="token punctuation">,</span> n_epoch<span class="token operator">=</span>args<span class="token punctuation">.</span>epochs<span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span>classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>output<span class="token operator">=</span>output_path<span class="token punctuation">)</span> <span class="token comment"># 训练分类器</span>predict <span class="token operator">=</span> classifier<span class="token punctuation">.</span>predict<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 预测</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h5><p>自编码器重构情况如下。从上至下分别为第1、20、50轮训练开始前的重构图像（原始数字和重构数字相间排列）。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725110745584.png" alt="第1轮训练前的重构图像"></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725110807103.png" alt="第20轮训练前的重构图像"></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725110812442.png" alt="第50轮训练前的重构图像"></p><p>模型评估结果见下表。</p><div class="table-container"><table><thead><tr><th></th><th>precision</th><th>recall</th><th>f1-score</th><th>support</th></tr></thead><tbody><tr><td>0</td><td>0.966135458</td><td>0.989795918</td><td>0.977822581</td><td>980</td></tr><tr><td>1</td><td>0.975694444</td><td>0.99030837</td><td>0.982947092</td><td>1135</td></tr><tr><td>2</td><td>0.97265625</td><td>0.965116279</td><td>0.968871595</td><td>1032</td></tr><tr><td>3</td><td>0.971028971</td><td>0.962376238</td><td>0.966683242</td><td>1010</td></tr><tr><td>4</td><td>0.964610718</td><td>0.971486762</td><td>0.96803653</td><td>982</td></tr><tr><td>5</td><td>0.951807229</td><td>0.974215247</td><td>0.962880886</td><td>892</td></tr><tr><td>6</td><td>0.978768577</td><td>0.962421712</td><td>0.970526316</td><td>958</td></tr><tr><td>7</td><td>0.96541502</td><td>0.950389105</td><td>0.957843137</td><td>1028</td></tr><tr><td>8</td><td>0.957671958</td><td>0.929158111</td><td>0.943199583</td><td>974</td></tr><tr><td>9</td><td>0.929273084</td><td>0.937561943</td><td>0.933399112</td><td>1009</td></tr><tr><td>accuracy</td><td>0.9635</td><td>0.9635</td><td>0.9635</td><td>0.9635</td></tr><tr><td>macro avg</td><td>0.963306171</td><td>0.963282968</td><td>0.963221007</td><td>10000</td></tr><tr><td>weighted avg</td><td>0.963552219</td><td>0.9635</td><td>0.963454132</td><td>10000</td></tr></tbody></table></div><h4 id="变分自编码器"><a href="#变分自编码器" class="headerlink" title="变分自编码器"></a>变分自编码器</h4><h5 id="模型简介-1"><a href="#模型简介-1" class="headerlink" title="模型简介"></a>模型简介</h5><p>变分自编码器与自编码器结构相似，只不过变分自编码器要学习的是数据的分布。编码器$f$输出$\mu$和$\sigma^2$，然后从该正态分布中采样得到编码器的最终输出，再通过解码器即可。</p><p>给定输入数据$x$，我们希望变分自编码器学习到输入数据的隐变量$z$的概率分布，也即隐变量$z$的后验分布</p><script type="math/tex; mode=display">p(z|x)</script><p>鉴于该后验分布的求解很困难，于是模型学习另一个分布$q(z|x)$来近似真实的后验分布$p(z|x)$。用KL散度表示两个分布之间的距离：</p><script type="math/tex; mode=display">\min KL(q(z|x)||p(z|x))</script><p>经过复杂的数学推导，变分自编码器的目标函数可以表示为</p><script type="math/tex; mode=display">\mathcal{L}=-D_{KL}(q(z|x)||p(z))+\mathbb{E}_{z\sim q(z|x)}(\log p(x|z))</script><p>进而转化为优化问题</p><script type="math/tex; mode=display">\max \mathcal{L}</script><p>但是目前这个式子仍然很抽象，需要继续进行推导，转化为更加清晰的形式，才能方便后续实验。为此，我们分别来看$\mathcal{L}$闭式解中的两项。</p><p>第一项，   也即KL散度。我们假设$p(z)$满足标准高斯分布，而$q(z|x)$也是服从高斯分布$\mathcal{N}(\mu, \sigma^2)$，其中的$\mu,\sigma^2$就是编码器网络的两个输出（事实上，实际实验过程中编码器输出结果为$\mu, \log \sigma^2$，因为$\sigma^2$恒为非负数，需要加上额外的激活函数才能得到，取对数后则不需要添加激活函数)，于是有</p><script type="math/tex; mode=display">p(z)=\mathcal{N}(z;0,1)\\q(z|x)=\mathcal{N}(z|x;\mu,\sigma^2)</script><p>则有</p><script type="math/tex; mode=display">\begin{aligned} D_{KL}(q(z|x)||p(z))&=D_{KL}(\mathcal{N}(\mu,\sigma^2)||\mathcal{N}(0,1))\\\\&=\int \frac{1}{\sqrt{2\pi \sigma^2}}\exp(\frac{-(x-\mu)^2}{2\sigma^2})\log \frac{\exp(\frac{-(x-\mu)^2}{2\sigma^2})/\sqrt{2\pi \sigma^2}}{\exp{(\frac{-x^2}{2})/\sqrt{2\pi}}}dx \\\\&=\frac{1}{2}\int \frac{1}{\sqrt{2\pi \sigma^2}}\exp(\frac{-(x-\mu)^2}{2\sigma^2})\left(-\log \sigma^2+x^2-\frac{(x-\mu)^2}{\sigma^2}\right)dx \\\\&=\frac{1}{2}(-\log \sigma^2+\mu^2+\sigma^2-1) \end{aligned}</script><p>第二项， $\mathbb{E}_{x\sim q(z|x)}(\log p(x|z))$ ，由于$z\sim q(z|x)$就是编码器的编码结果，而$p(x|z)$表示已知编码结果下得到原始输入的概率，这实际上就是解码器的含义，该期望的最大化，实际上等价于最小化重构误差。</p><p>综上，损失函数可以明确地确定为</p><script type="math/tex; mode=display">\mathrm{Loss}=\frac{1}{2}(-\log \sigma^2+\mu^2+\sigma^2-1)+L(x,\hat{x})</script><p>其中$L$表示常规的损失函数，本次实验中，选择的是$L1$损失，上述损失函数具体化为</p><script type="math/tex; mode=display">\mathrm{Loss}=\frac{1}{2}(-\log \sigma^2+\mu^2+\sigma^2-1)+|x-\hat{x}|</script><p>最后，整个变分自编码器的结构如图。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725110358689.png" alt="变分自编码器结构"></p><h5 id="训练与评估-1"><a href="#训练与评估-1" class="headerlink" title="训练与评估"></a>训练与评估</h5><p>变分自编码器的训练和自编码器类似，均需要利用到无标签的样本集。先定义一个损失函数，它就是上面提到的KL散度和重构误差的组合项：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">reconstruction_function <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span>size_average<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">loss_function</span><span class="token punctuation">(</span>recon_x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> mu<span class="token punctuation">,</span> logvar<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    recon_x: 重构图像    x: 原始图像    mu: 隐变量服从的高斯分布均值    logvar: 隐变量服从的高斯分布协方差    """</span>    BCE <span class="token operator">=</span> reconstruction_function<span class="token punctuation">(</span>recon_x<span class="token punctuation">,</span> x<span class="token punctuation">)</span>  <span class="token comment"># mse loss</span>    <span class="token comment"># loss = 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)</span>    KLD_element <span class="token operator">=</span> mu<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>add_<span class="token punctuation">(</span>logvar<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mul_<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>add_<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>add_<span class="token punctuation">(</span>logvar<span class="token punctuation">)</span>    KLD <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>KLD_element<span class="token punctuation">)</span><span class="token punctuation">.</span>mul_<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span>    <span class="token comment"># KL divergence</span>    <span class="token keyword">return</span> BCE <span class="token operator">+</span> KLD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h5><p>与自编码器类似，变分自编码器评估结果见下表。</p><div class="table-container"><table><thead><tr><th></th><th>precision</th><th>recall</th><th>f1-score</th><th>support</th></tr></thead><tbody><tr><td>0</td><td>0.938295788</td><td>0.97755102</td><td>0.957521239</td><td>980</td></tr><tr><td>1</td><td>0.960282436</td><td>0.958590308</td><td>0.959435626</td><td>1135</td></tr><tr><td>2</td><td>0.956256358</td><td>0.910852713</td><td>0.933002481</td><td>1032</td></tr><tr><td>3</td><td>0.915686275</td><td>0.924752475</td><td>0.920197044</td><td>1010</td></tr><tr><td>4</td><td>0.941176471</td><td>0.945010183</td><td>0.943089431</td><td>982</td></tr><tr><td>5</td><td>0.931034483</td><td>0.908071749</td><td>0.919409762</td><td>892</td></tr><tr><td>6</td><td>0.963196635</td><td>0.956158664</td><td>0.959664746</td><td>958</td></tr><tr><td>7</td><td>0.93957115</td><td>0.937743191</td><td>0.93865628</td><td>1028</td></tr><tr><td>8</td><td>0.886639676</td><td>0.899383984</td><td>0.892966361</td><td>974</td></tr><tr><td>9</td><td>0.905088063</td><td>0.916749257</td><td>0.910881339</td><td>1009</td></tr><tr><td>accuracy</td><td>0.9339</td><td>0.9339</td><td>0.9339</td><td>0.9339</td></tr><tr><td>macro avg</td><td>0.933722733</td><td>0.933486354</td><td>0.933482431</td><td>10000</td></tr><tr><td>weighted avg</td><td>0.934131061</td><td>0.9339</td><td>0.933894114</td><td>10000</td></tr></tbody></table></div><p>变分自编码器重构情况如下。从上至下分别为第1、20、50轮训练开始前的重构图像（原始数字和重构数字相间排列）。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725162433964-16902734808024.png" alt="第1轮训练前VAE的重构图像" style="zoom:150%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725162443943.png" alt="第20轮训练前VAE的重构图像" style="zoom:150%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725162450444.png" alt="第50轮训练前VAE的重构图像" style="zoom:150%;" /></p><p><strong>变分自编码器本质上是一种生成模型。</strong>下面是变分自编码器生成的图像（从隐空间随机采样噪声，经过解码器的输出结果）。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725162757863.png" alt="第1轮训练前VAE的生成图像" style="zoom:150%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725162900605.png" alt="第1轮训练前VAE的生成图像" style="zoom:150%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725162910761.png" alt="第1轮训练前VAE的生成图像" style="zoom:150%;" /></p><h4 id="条件对抗生成网络"><a href="#条件对抗生成网络" class="headerlink" title="条件对抗生成网络"></a>条件对抗生成网络</h4><p>条件对抗生成网络（CGAN）可以生成指定标签的手写数字图像。思路如下：</p><ul><li>在有标签数据集上训练CGAN</li><li>利用CGAN生成假样本</li><li>将假样本添加到原始的数据集中，做数据增强</li><li>训练分类模型</li></ul><h5 id="模型简介-2"><a href="#模型简介-2" class="headerlink" title="模型简介"></a>模型简介</h5><p>条件生成式对抗网络（CGAN）是对原始GAN的一种变形，生成器和判别器都增加额外信息 C 作为条件，条件可以是类别信息、或其他模态数据。通过将额外信息c输送给判别模型和生成模型,作为输入层的一部分,从而实现条件GAN。在生成模型中，先验输入噪声p(z)和条件信息c联合，条件GAN的目标函数是带有条件概率的二元极小极大值博弈。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">weights_init</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    classname <span class="token operator">=</span> m<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__    <span class="token keyword">if</span> classname<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'Conv'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.02</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> classname<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'BatchNorm'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.02</span><span class="token punctuation">)</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>constant_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Generator</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nz<span class="token punctuation">,</span> ngf<span class="token punctuation">,</span> num_classes<span class="token punctuation">,</span> nc<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Generator<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>image_path <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>nz<span class="token punctuation">,</span> ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        self<span class="token punctuation">.</span>label_path <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>num_classes<span class="token punctuation">,</span> ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        self<span class="token punctuation">.</span>main_path <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span> ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> ngf<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>ngf<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> nc<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Tanh<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> image<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">:</span>        image <span class="token operator">=</span> self<span class="token punctuation">.</span>image_path<span class="token punctuation">(</span>image<span class="token punctuation">)</span>        label <span class="token operator">=</span> self<span class="token punctuation">.</span>label_path<span class="token punctuation">(</span>label<span class="token punctuation">)</span>        inp <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>main_path<span class="token punctuation">(</span>inp<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Discriminator</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ndf<span class="token punctuation">,</span> num_classes<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> nc<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Discriminator<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>image_path <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>nc<span class="token punctuation">,</span> ndf<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>        self<span class="token punctuation">.</span>label_path <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_classes<span class="token punctuation">,</span> ndf<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>        self<span class="token punctuation">.</span>main_path <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>ndf<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> ndf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>ndf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>ndf<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> ndf<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>ndf<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>ndf<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> image<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">:</span>        image <span class="token operator">=</span> self<span class="token punctuation">.</span>image_path<span class="token punctuation">(</span>image<span class="token punctuation">)</span>        label <span class="token operator">=</span> self<span class="token punctuation">.</span>label_path<span class="token punctuation">(</span>label<span class="token punctuation">)</span>        inp <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>main_path<span class="token punctuation">(</span>inp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train_gan</span><span class="token punctuation">(</span>G<span class="token punctuation">:</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">,</span> D<span class="token punctuation">:</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">,</span> optimizerG<span class="token punctuation">,</span> optimizzerD<span class="token punctuation">,</span> trainloader<span class="token punctuation">,</span> epochs<span class="token punctuation">,</span> device<span class="token punctuation">,</span> output<span class="token punctuation">,</span> img_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>output <span class="token operator">+</span> <span class="token string">'/fake'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>output <span class="token operator">+</span> <span class="token string">'/fake'</span><span class="token punctuation">)</span>    G_losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    D_losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    D_x_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    D_z_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    img_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    loss_tep <span class="token operator">=</span> <span class="token number">10</span>    REAL_LABEL <span class="token operator">=</span> <span class="token number">1.</span>    FAKE_LABEL <span class="token operator">=</span> <span class="token number">0.</span>    label2hot <span class="token operator">=</span> torch<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    label_fills <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> img_size<span class="token punctuation">,</span> img_size<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        label_fills<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>img_size<span class="token punctuation">,</span> img_size<span class="token punctuation">)</span>    label_fills <span class="token operator">=</span> label_fills<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    fixed_noise <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    fixed_label <span class="token operator">=</span> label2hot<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>values<span class="token punctuation">]</span>    criterion <span class="token operator">=</span> nn<span class="token punctuation">.</span>BCELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Start training!"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>        start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> data <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>trainloader<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># TODO training Discriminator with true dataset, namely binary classify task</span>            D<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            real_img <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span> <span class="token comment"># true images</span>            b <span class="token operator">=</span> real_img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># batch_size</span>            real_labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> REAL_LABEL<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    <span class="token comment"># true images label, 1</span>            fake_labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FAKE_LABEL<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>   <span class="token comment"># fake images label, 0</span>            D_label <span class="token operator">=</span> label_fills<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment"># 训练判别器的数据标签,</span>            G_label <span class="token operator">=</span> label2hot<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment"># 训练生成器的数据标签, e.g. [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]</span>            out <span class="token operator">=</span> D<span class="token punctuation">(</span>real_img<span class="token punctuation">,</span> D_label<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># real_labels = real_labels.to(torch.float)</span>            error_D_real <span class="token operator">=</span> criterion<span class="token punctuation">(</span>out<span class="token punctuation">,</span> real_labels<span class="token punctuation">)</span>            error_D_real<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            D_x <span class="token operator">=</span> out<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 对真实图像的判定结果</span>            <span class="token comment"># TODO training Discriminator with fake dataset, namely binary classify task</span>            noise <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>            fake <span class="token operator">=</span> G<span class="token punctuation">(</span>noise<span class="token punctuation">,</span> G_label<span class="token punctuation">)</span> <span class="token comment"># 生成假样本</span>            out <span class="token operator">=</span> D<span class="token punctuation">(</span>fake<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D_label<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># fake_labels = fake_labels.to(torch.float)</span>            error_D_fake <span class="token operator">=</span> criterion<span class="token punctuation">(</span>out<span class="token punctuation">,</span> fake_labels<span class="token punctuation">)</span>            error_D_fake<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            D_G_z1 <span class="token operator">=</span> out<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 对假图像的判定结果</span>            loss_D <span class="token operator">=</span> error_D_real <span class="token operator">+</span> error_D_fake            optimizzerD<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># TODO update Generator parameters</span>            G<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            out <span class="token operator">=</span> D<span class="token punctuation">(</span>fake<span class="token punctuation">,</span> D_label<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            loss_G <span class="token operator">=</span> criterion<span class="token punctuation">(</span>out<span class="token punctuation">,</span> real_labels<span class="token punctuation">)</span>     <span class="token comment"># 生成器的损失函数是判别器对假样本的判别结果和真实样本标签（1）之间的差异，也就是说，生成器更希望判别器将假样本（fake）都判定为真实样本（real_labels）</span>            loss_G<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            D_G_z2 <span class="token operator">=</span> out<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            optimizerG<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>            end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            run_time <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span>end_time <span class="token operator">-</span> start_time<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Epoch: [</span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">&#123;</span>epochs<span class="token punctuation">&#125;</span></span><span class="token string">], Step: [</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">len</span><span class="token punctuation">(</span>trainloader<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">], Loss_D: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>loss_D<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">.4f</span><span class="token punctuation">&#125;</span></span><span class="token string">, Loss_G: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>loss_G<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token format-spec">.4f</span><span class="token punctuation">&#125;</span></span><span class="token string">, D(x): </span><span class="token interpolation"><span class="token punctuation">&#123;</span>D_x<span class="token punctuation">:</span><span class="token format-spec">.4f</span><span class="token punctuation">&#125;</span></span><span class="token string">, D(G(z)): [</span><span class="token interpolation"><span class="token punctuation">&#123;</span>D_G_z1<span class="token punctuation">:</span><span class="token format-spec">.4f</span><span class="token punctuation">&#125;</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">&#123;</span>D_G_z2<span class="token punctuation">:</span><span class="token format-spec">.4f</span><span class="token punctuation">&#125;</span></span><span class="token string">], Time: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>run_time<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'\r'</span><span class="token punctuation">)</span>            G_losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss_G<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            D_losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss_D<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            D_x_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>D_x<span class="token punctuation">)</span>            D_z_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>D_G_z2<span class="token punctuation">)</span>            <span class="token keyword">if</span> loss_G <span class="token operator">&lt;</span> loss_tep<span class="token punctuation">:</span>                torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>G<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> output<span class="token operator">+</span><span class="token string">'/model.pt'</span><span class="token punctuation">)</span>                loss_tep <span class="token operator">=</span> loss_G        <span class="token comment"># Check how the generator is doing by saving G's output on fixed_noise and fixed_label</span>        <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fake <span class="token operator">=</span> G<span class="token punctuation">(</span>fixed_noise<span class="token punctuation">,</span> fixed_label<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span>        fake_img <span class="token operator">=</span> utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>fake<span class="token punctuation">,</span> nrow<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>        save_image<span class="token punctuation">(</span>fake_img<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"./%s/fake/epoch-%d.png"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>output<span class="token punctuation">,</span> epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        img_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>fake<span class="token punctuation">,</span> nrow<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h5><p>共训练30轮。由于有标签样本数量较少，生成的数据质量较一般，如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/image-20230725171009917.png" alt="CGAN生成样本"></p><p>测试评估结果如下。</p><div class="table-container"><table><thead><tr><th></th><th>precision</th><th>recall</th><th>f1-score</th><th>support</th></tr></thead><tbody><tr><td>0</td><td>0.967967968</td><td>0.986734694</td><td>0.977261243</td><td>980</td></tr><tr><td>1</td><td>0.980752406</td><td>0.987665198</td><td>0.984196664</td><td>1135</td></tr><tr><td>2</td><td>0.952007835</td><td>0.941860465</td><td>0.946906965</td><td>1032</td></tr><tr><td>3</td><td>0.945365854</td><td>0.959405941</td><td>0.952334152</td><td>1010</td></tr><tr><td>4</td><td>0.964503043</td><td>0.968431772</td><td>0.966463415</td><td>982</td></tr><tr><td>5</td><td>0.96275395</td><td>0.956278027</td><td>0.959505062</td><td>892</td></tr><tr><td>6</td><td>0.971845673</td><td>0.972860125</td><td>0.972352634</td><td>958</td></tr><tr><td>7</td><td>0.940896092</td><td>0.960116732</td><td>0.950409244</td><td>1028</td></tr><tr><td>8</td><td>0.967567568</td><td>0.91889117</td><td>0.942601369</td><td>974</td></tr><tr><td>9</td><td>0.934458788</td><td>0.932606541</td><td>0.933531746</td><td>1009</td></tr><tr><td>accuracy</td><td>0.9588</td><td>0.9588</td><td>0.9588</td><td>0.9588</td></tr><tr><td>macro avg</td><td>0.958811918</td><td>0.958485066</td><td>0.958556249</td><td>10000</td></tr><tr><td>weighted avg</td><td>0.958852176</td><td>0.9588</td><td>0.958735209</td><td>10000</td></tr></tbody></table></div><h3 id="实验结果对比"><a href="#实验结果对比" class="headerlink" title="实验结果对比"></a>实验结果对比</h3><p>在10%有标签数据集的基础上，进一步减小有标签数据集所占比例为1%、0.1%甚至每类别单个图片。综合各个解决方案的实验结果见表。</p><div class="table-container"><table><thead><tr><th><strong>带标签样本数量占比，</strong>  <strong>每一个类别的样本数量</strong></th><th><strong>分类器</strong></th><th><strong>分类器训练轮数</strong></th><th><strong>预训练模型</strong></th><th><strong>测试准确率</strong></th></tr></thead><tbody><tr><td>10%, 600 samples per class</td><td>FCNet</td><td>5 epochs</td><td>None</td><td>0.9246</td></tr><tr><td>10%, 600 samples per class</td><td>ConvNet</td><td>5 epochs</td><td>None</td><td>0.9549</td></tr><tr><td>10%, 600 samples per class + 600 fake samples per class</td><td>ConvNet</td><td>5 epochs</td><td>CGAN</td><td>0.9588</td></tr><tr><td>10%, 600 samples per class</td><td>knn</td><td></td><td>VAE</td><td>0.8469</td></tr><tr><td>10%, 600 samples per class</td><td>mlp</td><td>50  epochs</td><td>VAE</td><td>0.9328</td></tr><tr><td>10%, 600 samples per class</td><td>knn</td><td></td><td>AE</td><td>0.9542</td></tr><tr><td><strong>10%, 600 samples per class</strong></td><td><strong>mlp</strong></td><td><strong>50 epochs</strong></td><td><strong>AE</strong></td><td><strong>0.9609</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1%, 60 samples per class</td><td>FCNet</td><td>10 epochs</td><td>None</td><td>0.8772</td></tr><tr><td>1%, 60 samples per class</td><td>ConvNet</td><td>50 epochs</td><td>None</td><td>0.9405</td></tr><tr><td>1%, 60 samples per class</td><td>knn</td><td></td><td>VAE</td><td>0.6673</td></tr><tr><td>1%, 60 samples per class</td><td>mlp</td><td>100 epochs</td><td>VAE</td><td>0.8497</td></tr><tr><td>1%, 60 samples per class</td><td>knn</td><td></td><td>AE</td><td>0.8911</td></tr><tr><td><strong>1%, 60 samples per class</strong></td><td><strong>mlp</strong></td><td><strong>100 epochs</strong></td><td><strong>AE</strong></td><td><strong>0.9332</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0.1%, 6 samples per class</td><td>FCNet</td><td>500 epochs</td><td>None</td><td>0.7425</td></tr><tr><td>0.1%, 6 samples per class</td><td>ConvNet</td><td>500 epochs</td><td>None</td><td>0.8132</td></tr><tr><td>0.1%, 6 samples per class</td><td>knn</td><td></td><td>VAE</td><td>0.4321</td></tr><tr><td>0.1%, 6 samples per class</td><td>mlp</td><td>50 epochs</td><td>VAE</td><td>0.5757</td></tr><tr><td>0.1%, 6 samples per class</td><td>knn</td><td></td><td>AE</td><td>0.754</td></tr><tr><td><strong>0.1%, 6 samples per class</strong></td><td><strong>mlp</strong></td><td><strong>500 epochs</strong></td><td><strong>AE</strong></td><td><strong>0.8837</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1 sample per class</td><td>FCNet</td><td>500 epochs</td><td>None</td><td>0.4087</td></tr><tr><td>1 sample per class</td><td>ConvNet</td><td>50 epochs</td><td>None</td><td>0.4997</td></tr><tr><td>1 sample per class</td><td>knn</td><td></td><td>VAE</td><td>0.18</td></tr><tr><td>1 sample per class</td><td>mlp</td><td>50 epochs</td><td>VAE</td><td>0.2841</td></tr><tr><td>1 sample per class</td><td>knn</td><td></td><td>AE</td><td>0.2103</td></tr><tr><td><strong>1 sample per class</strong></td><td><strong>mlp</strong></td><td><strong>1000 epochs</strong></td><td><strong>AE</strong></td><td><strong>0.6085</strong></td></tr></tbody></table></div><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><h3 id="关于两个正态分布的KL散度"><a href="#关于两个正态分布的KL散度" class="headerlink" title="关于两个正态分布的KL散度"></a>关于两个正态分布的KL散度</h3><p>本文关于变分自编码器的原理推导部分涉及了两个正态分布的KL散度计算问题。恰好前段时间参加某顶牛实验室笔试遇到这个问题，因此另作记录。</p><blockquote><p>Kullback-Leibler(KL)散度，通常在概率和统计中，我们会用更简单的近似分布来代替观察到的数据或复杂的分布。KL散度帮助我们衡量在选择近似值时损失了多少信息，即定量地描述两个分布之间的距离。具体地，考虑（连续型）随机变量$x$，存在两个概率分布$P,Q$，定义从P到Q的KL散度为</p><script type="math/tex; mode=display">\mathrm{D_{KL}}(P||Q)=\int p(x)\ln \frac{p(x)}{q(x)}dx</script><p>而一维随机变量$x$的正态分布概率密度函数为</p><script type="math/tex; mode=display">\mathcal{N}(x;\mu,\sigma^2)=\frac{1}{\sqrt{2\pi}\sigma}\exp{\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)}</script></blockquote><p>对于两个已知均值和方差的正态分布$\mathcal{N}_1(x;\mu_1,\sigma_1^2),\mathcal{N}_2(x;\mu_2,\sigma_2^2)$，有</p><script type="math/tex; mode=display">\begin{aligned} \mathrm{D_{KL}}(\mathcal{N}_1||\mathcal{N}_2) &= \int \frac{1}{\sqrt{2\pi}\sigma_1}\exp{\left(-\frac{(x-\mu_1)^2}{2\sigma_1^2}\right)} \ln \left( \frac{\frac{1}{\sqrt{2\pi}\sigma_1}\exp{\left(-\frac{(x-\mu_1)^2}{2\sigma_1^2}\right)}}{\frac{1}{\sqrt{2\pi}\sigma_2}\exp{\left(-\frac{(x-\mu_2)^2}{2\sigma_2^2}\right)}} \right)dx \\\\ &= \int \frac{1}{\sqrt{2\pi}\sigma_1}\exp \left( -\frac{(x-\mu_1)^2}{2\sigma_1^2} \right) \left( \ln \frac{\sigma_2}{\sigma_1}+\frac{(x-\mu_2)^2}{2\sigma_2^2}-\frac{(x-\mu_1)^2}{2\sigma_1^2} \right) dx \\\\ &= \int \frac{1}{\sqrt{2\pi}\sigma_1}\exp \left( -\frac{(x-\mu_1)^2}{2\sigma_1^2} \right) \ln \frac{\sigma_2}{\sigma_1}dx \\\\ &+ \int \frac{1}{\sqrt{2\pi}\sigma_1}\exp \left( -\frac{(x-\mu_1)^2}{2\sigma_1^2} \right) \frac{(x-\mu_2)^2}{2\sigma_2^2}dx \\\\ &- \int \frac{1}{\sqrt{2\pi}\sigma_1}\exp \left( -\frac{(x-\mu_1)^2}{2\sigma_1^2} \right) \frac{(x-\mu_1)^2}{2\sigma_1^2} dx \end{aligned}</script><p>显然，上式由三项组成，分别记作$A,B,C$，于是有</p><script type="math/tex; mode=display">\mathrm{D_{KL}}(\mathcal{N}_1||\mathcal{N}_2)=A+B-C</script><p>为了充分利用一些概率性质，同时为了简化公式，记概率密度</p><script type="math/tex; mode=display">f(x)=\mathcal{N}_1(x;\mu_1,\sigma_1^2)=\frac{1}{\sqrt{2\pi}\sigma_1}\exp{\left(-\frac{(x-\mu_1)^2}{2\sigma_1^2}\right)}</script><p>故有如下重要关系</p><script type="math/tex; mode=display">\int f(x) dx=1</script><script type="math/tex; mode=display">\mu_1=\mathbb{E}(x)=\int xf(x)dx</script><script type="math/tex; mode=display">\sigma_1^2=\mathrm{D}(x)=\mathbb{E}(x^2)-\mathbb{E}^2(x)=\mathbb{E}((x-\mathbb{E}(x))^2)=\int (x-\mu_1)^2f(x)dx</script><p>下面分别计算$A,B,C$：</p><p>对于$A$，显然它就是对概率密度的积分：</p><script type="math/tex; mode=display">A=\ln\frac{\sigma_2}{\sigma_1}\int f(x)dx=\ln \frac{\sigma_2}{\sigma_1}</script><p>对于$B$，将其拆开得</p><script type="math/tex; mode=display">\begin{aligned} B &= \frac{1}{2\sigma_2^2} \int (x^2f(x)-2\mu_2xf(x)+\mu_2^2f(x)) dx \\\\ &=\frac{1}{2\sigma^2}\left( \mathbb{E}(x^2) - 2\mu_2 \mathbb{E}(x) + \mu_2^2 \right) \\\\ &= \frac{1}{2\sigma_2^2}\left( \mathrm{D}(x)+\mathbb{E}^2(x)-2\mu_2\mathbb{E}(x)+\mu_2^2 \right) \\\\ &= \frac{1}{2\sigma_2^2}(\sigma_1^2+\mu_1^2-2\mu_1\mu_2+\mu_2^2) \end{aligned}</script><p>对于$C$，稍作整理发现它其实包含了方差：</p><script type="math/tex; mode=display">C=-\frac{1}{2\sigma_1^2} \int (x-\mu_1)^2f(x)dx=-\frac{\sigma_1^2}{2\sigma_1^2}=-\frac{1}{2}</script><p>综上得</p><script type="math/tex; mode=display">\mathrm{D_{KL}}(\mathcal{N}_1||\mathcal{N}_2)=\ln\frac{\sigma_2}{\sigma_1}+\frac{\sigma_1^2+(\mu_1-\mu_2)^2}{2\sigma_2^2}-\frac{1}{2}</script><p>特别地，在变分自编码器的数学推导中，$\mathcal{N}_2$是标准正态分布，故有</p><script type="math/tex; mode=display">\mathrm{D_{KL}}(\mathcal{N}_1(x;\mu,\sigma^2)||\mathcal{N}_2(x;0,1))=\frac{\sigma^2+\mu^2}{2}-\ln\sigma-\frac{1}{2}</script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Kullback-Leibler散度：<a href="https://zhuanlan.zhihu.com/p/100676922">https://zhuanlan.zhihu.com/p/100676922</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/24/%E5%88%86%E6%B2%BB/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/24/%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治，分而治之。将复杂的问题逐步划分为若干<strong>不相交</strong>的子问题，逐个击破后进行合并，得到最终的解。其步骤如下：</p><ul><li>划分（divide）</li><li>解决（conquer）</li><li>合并（merge）</li></ul><h2 id="经典：棋盘覆盖问题"><a href="#经典：棋盘覆盖问题" class="headerlink" title="经典：棋盘覆盖问题"></a>经典：棋盘覆盖问题</h2><p>给定一个大小为$2^k\times 2^k$（$k\in N_+$）的白色棋盘，其中有一个格子是黑色的。下图为$k=2$即4的棋盘示例。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/f76cd728-73c9-4a70-b90e-af0a6882461e.png" alt="棋盘示例图"></p><p>现在想用一种大小占三个小方格的形骨牌来覆盖整个棋盘，这种L形骨牌可以通过旋转得到下面四种形态：</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/58682a08-0683-4d35-8ab2-bb6f09a284d7.png" alt="四种L形骨牌"></p><p>注意，在覆盖的时候，骨牌之间不能相互覆盖，也不能覆盖初始状态下已经是黑色的那个格子。</p><p>请输出覆盖方案，下图是上面示例的覆盖方案（注：不同颜色只是用来区分不同的骨牌，与题意无关）。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/24247e36-1277-4c3d-8bc8-0ee0d8d4bc8b.png" alt="示例解"></p><h3 id="问题的解"><a href="#问题的解" class="headerlink" title="问题的解"></a>问题的解</h3><p>首先明确的是，该问题一定是有解的（不妨自己用数学归纳法证明一下）。而原问题其实是比较复杂的（很明显，棋盘较大，而仅给了一个特殊方格），因此考虑分治。</p><ul><li><p>divide</p><p>如何将原问题划分为若干互不相交的子问题？很直观的想法是，将棋盘进行四等分。但是仅给出了一个特殊方格，因此这样四等分后并不能得到四个子问题。这时就需要用到给定的L形骨牌了：<strong>将L形骨牌放置于未出现特殊方格的三个等分区域中，这样使得其也出现了“特殊方格”，进而划分出四个互不相交的子问题。</strong>接下来考虑递归边界：极限情况为$2\times 2$的棋盘，再划分时，四个方格均为特殊方格了，于是，当棋盘为$1\times 1$时，递归终止。</p></li><li><p>conquer</p></li><li><p>merge</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98.jpg" alt="棋盘覆盖问题的划分"></p><p>用区域的左下角坐标、右上角坐标和特殊点坐标表示该区域。以上图为例，则对于给定的区域$(<x_1,y_1>,<x_2,y_2>;<x_0,y_0>)$，令$x_m=\frac{x_1+x_2}{2},y_m=\frac{y_1+y_2}{2}$等分出四个子区域：</p><ul><li>$(<x_1,y_1>,<x_m,y_m>;<x_m,y_m>)$</li><li>$(<x_m+1,y_1>,<x_2,y_m>;<x_m+1,y_m>)$</li><li>$(<x_1,y_m+1>,<x_m,y_2>;<x_m,y_m+1>)$</li><li>$(<x_m+1,y_m+1>,<x_2,y_2>;<x_0,y_0>)$</li></ul><p>当判断出给定的特殊点$<x_0,y_0>$在右上角区域后，即可判断出L形骨牌的拐点坐标（即左下角区域的右上角坐标，其余四种情况同理分析）。</p><p>完整的解题代码如下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef pair&lt;int, int&gt; P;&#x2F;* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop *&#x2F;vector&lt;P&gt; vs;bool comp(P p1, P p2) &#123;if(p1.first &#x3D;&#x3D; p2.first)return p1.second &lt; p2.second;return p1.first &lt; p2.first;&#125;void cope(int x1, int y1, int x2, int y2, int x, int y) &#123;    &#x2F;*    * x1, y1为左下角坐标，x2, y2为右上角坐标    * x, y为特殊点坐标    *&#x2F;if(x1 &#x3D;&#x3D; x2 &amp;&amp; y1 &#x3D;&#x3D; y2)return;int midx &#x3D; x1 + (x2 - x1) &#x2F; 2;int midy &#x3D; y1 + (y2 - y1) &#x2F; 2;if(x &gt;&#x3D; x1 &amp;&amp; x &lt;&#x3D; midx &amp;&amp; y &gt;&#x3D; y1 &amp;&amp; y &lt;&#x3D; midy) &#123;&#x2F;&#x2F; 在左下方区域vs.push_back(&#123;midx+1, midy+1&#125;);cope(x1, y1, midx, midy, x, y);cope(midx+1, y1, x2, midy, midx+1, midy);cope(x1, midy+1, midx, y2, midx, midy+1);cope(midx+1, midy+1, x2, y2, midx+1, midy+1);&#125; else if(x &gt;&#x3D; midx+1 &amp;&amp; x &lt;&#x3D;x2 &amp;&amp; y &gt;&#x3D; y1 &amp;&amp; y &lt;&#x3D; midy) &#123;&#x2F;&#x2F; 在右下方区域vs.push_back(&#123;midx, midy+1&#125;);cope(x1, y1, midx, midy, midx, midy);cope(midx+1, y1, x2, midy, x, y);cope(x1, midy+1, midx, y2, midx, midy+1);cope(midx+1, midy+1, x2, y2, midx+1, midy+1);&#125; else if(x &gt;&#x3D; x1 &amp;&amp; x &lt;&#x3D; midx &amp;&amp; y &gt;&#x3D; midy+1 &amp;&amp; y &lt;&#x3D; y2) &#123;&#x2F;&#x2F; 在左上方区域vs.push_back(&#123;midx+1, midy&#125;);cope(x1, y1, midx, midy, midx, midy);cope(midx+1, y1, x2, midy, midx+1, midy);cope(x1, midy+1, midx, y2, x, y);cope(midx+1, midy+1, x2, y2, midx+1, midy+1); &#125; else &#123;&#x2F;&#x2F; 在右上方区域vs.push_back(&#123;midx, midy&#125;);cope(x1, y1, midx, midy, midx, midy);cope(midx+1, y1, x2, midy, midx+1, midy);cope(x1, midy+1, midx, y2, midx, midy+1);cope(midx+1, midy+1, x2, y2, x, y); &#125;&#125;int main(int argc, char** argv) &#123;int n, x0, y0;cin&gt;&gt;n&gt;&gt;x0&gt;&gt;y0;cope(1, 1, pow(2, n), pow(2, n), x0, y0);sort(vs.begin(), vs.end(), comp);for(vector&lt;P&gt;::iterator iter &#x3D; vs.begin(); iter !&#x3D; vs.end(); iter++) &#123;cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯算法</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/23/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/23/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近学习了《统计学习方法》第4章：朴素贝叶斯法，些许心得与数学推导，浅浅记录一下。</p></blockquote><p>贝叶斯理论系列在统计学中占用极其重要的地位。本节主要记录的是<strong>朴素贝叶斯法</strong>。它是一种基于<strong>贝叶斯定理</strong>和<strong>条件独立性假设</strong>的分类方法。</p><p>和感知机算法中类似，我们作出如下假设：</p><p>输入空间$\mathcal{X}\subseteq R^q$，输出空间$\mathcal{Y}=\{ c_1,c_2,\dots,c_k \}$，而输入的特征向量记作$\mathbf{x}\in\mathcal{X}\subseteq R^q$，输出类标记记作$y\in \mathcal{Y}$，而输入输出的随机变量记作$X,Y$。另外，我们把训练数据集表示为</p><script type="math/tex; mode=display">\begin{align} T=\{ (\mathbf{x}^{(1)},y^{(1)}), (\mathbf{x}^{(2)},y^{(2)}), \cdots, (\mathbf{x}^{(n)},y^{(n)}) \} \end{align}</script><p>那么，朴素贝叶斯法的基本思路是：</p><ul><li>基于条件独立性假设，学习输入输出的联合概率分布$P(X,Y)$</li><li>基于贝叶斯定理，求出后验概率的最大输出$P(Y|X)$</li></ul><h2 id="两个基本知识点"><a href="#两个基本知识点" class="headerlink" title="两个基本知识点"></a>两个基本知识点</h2><p>学习朴素贝叶斯法，离不开最基本的两个知识点：贝叶斯定理和条件独立性。下面分别记录一下这两者。</p><h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p>概率论与数理统计中已经学过贝叶斯定理，它的基本形式如下</p><script type="math/tex; mode=display">P(Y|X) = \frac{P(X|Y)P(Y)}{P(X)}</script><p>其中，可以作出如下理解：$X$是我们观测的变量，$Y$是我们需要估计的变量；而$P(Y)$则是<strong>先验概率</strong>，因为它实际上是在没有采样之前根据经验得到的一个概率值；$P(Y|X)$则是<strong>后验概率</strong>，因为此时已经进行了采样（给定$X$）。</p><h3 id="条件独立性"><a href="#条件独立性" class="headerlink" title="条件独立性"></a>条件独立性</h3><p>直接给出数学定义：假设三个随机变量（事件）$X,Y,Z$，若满足下式</p><script type="math/tex; mode=display">P(X,Y|Z) = P(X|Z)P(Y|Z)</script><p>则称$X,Y$条件独立。</p><p>注意<strong>条件独立性不等同于独立性</strong>。事实上，这两者并不能互推。</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><h3 id="用极大似然法作参数估计"><a href="#用极大似然法作参数估计" class="headerlink" title="用极大似然法作参数估计"></a>用极大似然法作参数估计</h3><p>这一部分主要是使用极大似然法估计参数。这一部分由于和课后习题关联甚密，因此在课后习题部分作详细描述。此处仅给出两个公式。</p><p>首先给出先验概率的估计</p><script type="math/tex; mode=display">P(Y=c_i)=\frac{\displaystyle \sum_{t=1}^n\left[ y^{(t)}=c_i \right]}{n} \tag{2}</script><p>其次，设$X_j$的取值有$S_j$种可能，记为$\{a_{j1}, a_{j2},\dots,a_{jS_j} \}$，因此条件概率的估计</p><script type="math/tex; mode=display">P(X_j=a_{jl}|Y=c_i) = \frac{\displaystyle \sum_{t=1}^n\left[ x^{(t)}_j=a_{jl},y^{(t)}=c_i \right]}{\displaystyle \sum_{t=1}^n\left[ y^{(t)}=c_i \right]} \tag{3}</script><h3 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h3><p>条件概率分布</p><script type="math/tex; mode=display">P(X=\mathbf{x}|Y=c_i)=P(X_1=x_1,X_2=x_2,\dots,X_p=x_p|Y=c_i),i\in\{1,2,\dots,k\}</script><p>而之前提过，朴素贝叶斯基于条件独立性假设<strong>在类确定的条件下，各个特征变量条件独立</strong>，因此上式可以转化为</p><script type="math/tex; mode=display">P(X=\mathbf{x}|Y=c_i)=\prod_{j=1}^pP(X_j=x_j|Y=c_i),i\in \{1,2,\dots,k\} \tag{4}</script><p>接下来，基于贝叶斯定理，计算后验概率</p><script type="math/tex; mode=display">P(Y=c_i|X=\mathbf{x})=\frac{P(X=\mathbf{x}|Y=c_i)P(Y=c_i)}{\sum\limits_iP(X=\mathbf{x}|Y=c_i)P(Y=c_i)} \tag{5}</script><p>于是可以把公式$4$代入公式$5$，得</p><script type="math/tex; mode=display">P(Y=c_i|X=\mathbf{x})=\frac{P(Y=c_i)\prod\limits_j P(X_j=x_j|Y=c_i)}{\sum\limits_iP(Y=c_i)\prod\limits_jP(X_j=x_j|Y=c_i)}</script><p>因此，朴素贝叶斯需要求出使得上述后验概率最大的分类结果$c_i$，即</p><script type="math/tex; mode=display">c_*=\arg\max_{c_i} = \frac{P(Y=c_i)\prod\limits_j P(X_j=x_j|Y=c_i)}{\sum\limits_iP(Y=c_i)\prod\limits_jP(X_j=x_j|Y=c_i)}</script><p>而上式的分母与$c_i$无关，因此可以化简为</p><script type="math/tex; mode=display">c_*=\arg\max_{c_i} = P(Y=c_i)\prod\limits_j P(X_j=x_j|Y=c_i)</script><h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>这一部分的详细描述同样见课后习题。需要指出的是，贝叶斯估计弥补了之前极大似然估计参数过程中还可能出现概率值为0这种意外的缺陷。我们在随机变量各个取值的频数上，赋予一个参数$\lambda&gt;0$，避免出现概率值为0的情况，于是式$2$变为下式</p><script type="math/tex; mode=display">\displaystyle P_\lambda(Y=c_i) = \frac{\displaystyle \sum_{t=1}^n \left[ y^{(t)}=c_i \right] + \lambda}{n+k \lambda}, \quad i= 1,2,\ldots,k \tag{6}</script><p>式$3$变为下式</p><script type="math/tex; mode=display">\displaystyle P_{\lambda}(X_j=a_{jl} | Y = c_i) = \frac{\displaystyle \sum_{t=1}^n \left[ x_j^{(t)}=a_{jl},y^{(t)}=c_i \right] + \lambda}{\displaystyle \sum_{t=1}^n \left[y^{(t)}=c_i\right] + S_j \lambda} \tag{7}</script><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h3><p>使用极大似然估计法推导出朴素贝叶斯法中的概率估计公式。为了和上文相匹配，此处摘录的证明公式符号和原书略有出入。</p><blockquote><ol><li>公式$2$，这里再次给出<script type="math/tex; mode=display">P(Y=c_i)=\frac{\displaystyle \sum_{t=1}^n\left[ y^{(t)}=c_i \right]}{n}</script></li></ol><ol><li>公式$3$，这里再次给出<script type="math/tex; mode=display">P(X_j=a_{jl}|Y=c_i) = \frac{\displaystyle \sum_{t=1}^n\left[ x^{(t)}_j=a_{jl},y^{(t)}=c_i \right]}{\displaystyle \sum_{t=1}^n\left[ y^{(t)}=c_i \right]}</script></li></ol></blockquote><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><p>我们知道<strong>极大似然估计法是一种典型的频率学派方法</strong>，思想是给定观测样本集$T$，求解出使得所有样本出现概率最大的参数，进而转化为优化问题</p><script type="math/tex; mode=display">\max f(\mathbf{x}^{(1)},\mathbf{x}^{(2)},\dots,\mathbf{x}^{(n)}|\theta)</script><p>更方便地，记</p><script type="math/tex; mode=display">\mathcal{L}(\theta) = f(\mathbf{x}^{(1)},\mathbf{x}^{(2)},\dots,\mathbf{x}^{(n)}|\theta)</script><p>则极大似然估计最终转化为求解最优参数</p><script type="math/tex; mode=display">\theta_* = \arg\max_\theta \mathcal{L}(\theta)</script><p>接下来求（偏）导数即可。</p><p>正是基于这样的思路，此处我们的思路就是将$P(Y=c_i)$转换为参数表示，求解出最优的参数即$P(Y=c_i)$的结果。</p><h4 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h4><p>设$P(Y=c_i)=\theta_i,i\in \{1,2,\dots,k\}$，则似然函数表示为</p><script type="math/tex; mode=display">\mathcal{L}(\theta_i) = P(y^{(1)},y^{(2)},\dots,y^{(n)}|\theta_i) \tag{8}</script><p>记$n$个样本中出现$y^{(j)}=c_i,j\in \{1,2,\dots,n\}$的样本数量为$m$，即</p><script type="math/tex; mode=display">m = \sum_{j=1}^n \left[ y^{(j)}=c_i \right]</script><p>因此，类别变量可以视为满足伯努利分布，$Y\sim B(n,\theta_i)$，因此似然函数式$8$可以化为</p><script type="math/tex; mode=display">\begin{aligned} \mathcal{L}(\theta_i) &= \prod_{j=1}^n P(y^{(j)}) \\ &= C_n^m \theta_i^m(1-\theta_i)^{n-m} \end{aligned}</script><p>为了方便计算，我们对上式取对数，得到对数似然函数</p><script type="math/tex; mode=display">\log \mathcal{L}(\theta_i) = \log C_n^m + m\log \theta_i + (n-m)\log (1-\theta_i)</script><p>接下来对其求导数即可：</p><script type="math/tex; mode=display">\frac{\partial}{\partial \theta_i} \mathcal{L}(\theta_i) = \frac{m}{\theta_i} + \frac{m-n}{1-\theta_i}</script><p>令上式等于0，得到最优参数，即</p><script type="math/tex; mode=display">\theta_* = \frac{m}{n}</script><p>也就是式子</p><script type="math/tex; mode=display">P(Y=c_i) = \theta_* = \frac{\sum\limits_{j=1}^n \left[ y^{(j)} = c_i \right]}{n},i\in \{1,2,\dots,k\}</script><h4 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h4><p>设$P(X_j=a_{jl}|Y=c_i)=\lambda_l$，则$P(X_j\ne a_{jl}|Y=c_i)=1-\lambda_l$，同样地，设</p><ul><li>$n$个样本中出现$y^{(k)}=c_i,k\in \{1,2,\dots,n\}$的样本数量为$m$</li><li>$n$个样本中同时出现$x^{(k)}_j=a_{jl},y^{(k)}=c_i,k\in\{1,2,\dots,n\},j\in\{1,2,\dots,p\}, l\in \{1,2,\dots,S_j\}$的样本数量为$t$</li></ul><p>我们考虑出现这$m$个样本的概率最大值，即似然函数</p><script type="math/tex; mode=display">\begin{aligned} \mathcal{L}(\lambda_l) &= C_m^t\lambda_l^t(1-\lambda_l)^{m-t} \end{aligned}</script><p>同理可以求得</p><script type="math/tex; mode=display">\lambda_* = \frac{t}{m}</script><p>也就是式子</p><script type="math/tex; mode=display">P(X_j=a_{jl}|Y=c_i) = \frac{\sum\limits_{k=1}^n \left[ x^{(k)}_j=a_{jl},y^{(k)}=c_i \right]}{\sum\limits_{k=1}^n \left[ y^{(k)}=c_i \right]}</script><h3 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h3><p>为了和上文相匹配，此处摘录的证明公式符号和原书略有出入。</p><blockquote><p>使用贝叶斯估计，证明</p><ol><li><p>公式$6$</p><script type="math/tex; mode=display">\displaystyle P_\lambda(Y=c_i) = \frac{\displaystyle \sum_{t=1}^n \left[ y^{(t)}=c_i \right] + \lambda}{n+k \lambda}, \quad i= 1,2,\ldots,k</script></li><li><p>公式$7$</p><script type="math/tex; mode=display">\displaystyle P_{\lambda}(X_j=a_{jl} | Y = c_i) = \frac{\displaystyle \sum_{t=1}^n \left[ x_j^{(t)}=a_{jl},y^{(t)}=c_i \right] + \lambda}{\displaystyle \sum_{t=1}^n \left[y^{(t)}=c_i\right] + S_j \lambda}</script></li></ol></blockquote><p>首先，在证明之前，先介绍一下题干中提到的<strong>贝叶斯估计</strong>，以及它和第一问中的<strong>极大似然估计</strong>有何区别和联系。</p><h4 id="贝叶斯估计-1"><a href="#贝叶斯估计-1" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h4><p>和频率学派的观点不同，贝叶斯学派普遍认为，<strong>待估计的参数$\theta$也是一个随机变量，因此它同样也服从某一个分布</strong>，它的数学描述如下</p><script type="math/tex; mode=display">\pi(\theta|X) = \frac{f(X|\theta)\pi(\theta)}{\displaystyle \int f(X|\theta)\pi(\theta)d\theta}</script><p>其中，</p><ul><li>$\pi(\theta)$是参数$\theta$的先验分布，往往是基于经验的、非采样的主观认识；</li><li>$\pi(\theta|X)$是后验分布，是基于采样后的、对先验进行了一些校正的分布。</li></ul><h4 id="狄利克雷分布（Dirichlet）"><a href="#狄利克雷分布（Dirichlet）" class="headerlink" title="狄利克雷分布（Dirichlet）"></a>狄利克雷分布（Dirichlet）</h4><p>狄利克雷分布描述了概率的分布，假设一组变量$\mathbf{x}=(x_1,x_2,\dots,x_d)$和参数$\Alpha=(\alpha_1,\alpha_2,\dots,\alpha_d)$，其中$\sum_ix_i=1$，$\alpha_i&gt;0$且$\hat{\alpha}=\sum_i\alpha_i$，变量满足参数为$\Alpha$的狄利克雷分布，即</p><script type="math/tex; mode=display">\mathbf{Dir}(\mathbf{x}|\Alpha) = \frac{\Gamma(\hat{\alpha})}{\displaystyle \prod_{i=1}^d\Gamma(\alpha_i)}\prod_{i=1}^dx_i^{\alpha_i-1}</script><p>狄利克雷分布有性质：</p><ul><li>期望$\displaystyle E(x_i)=\frac{\alpha_i}{\hat{\alpha}}$</li><li>方差$\displaystyle Var(x_i)=\frac{\alpha_i(\hat{\alpha}-\alpha_i)}{\hat{\alpha}^2(\hat{\alpha}+1)}$</li></ul><h4 id="证明1-1"><a href="#证明1-1" class="headerlink" title="证明1"></a>证明1</h4><p>和第一问类似的，我们将概率参数化，设</p><script type="math/tex; mode=display">\theta_i=P_\lambda(Y=c_i)</script><p>记所有样本中，出现$Y=c_i$的样本数量为$m_i$，即$m_i = \sum\limits_{t=1}^n\left[ y^{(t)}=c_i \right]$，我们把所有的$m_i$表示为$\mathbf{m}=(m_1,m_2,\dots,m_k)^T$，而参数$\Theta=(\theta_1,\theta_2,\dots,\theta_k)^T$；</p><p>我们选定参数$\Theta$满足狄利克雷分布，其中参数$\Alpha=(\alpha_1,\alpha_2,\dots,\alpha_k)^T$，于是有</p><script type="math/tex; mode=display">\mathbf{Dir}(\Theta|\mathbf{\Alpha}) = \frac{\displaystyle \Gamma(\hat{\alpha})}{\displaystyle \prod_{t=1}^k \Gamma(\alpha_i)}\prod_{t=1}^k\theta_t^{\alpha_t-1} \tag{9}</script><p>为了方便起见，把与$\Theta$无关的系数记成一个整体</p><script type="math/tex; mode=display">C(\Alpha) = \frac{\displaystyle \Gamma(\hat{\alpha})}{\displaystyle \prod_{t=1}^k \Gamma(\alpha_i)}</script><p>另外，在类别未知前提下，各个类别的样本数量一致，均为$\lambda$，也即</p><script type="math/tex; mode=display">\alpha_1=\alpha_2=\dots=\alpha_k=\lambda</script><p>于是，式$9$可以化为</p><script type="math/tex; mode=display">\mathbf{Dir}(\Theta|\mathbf{\Alpha}) = C(\lambda) \prod_{t=1}^k\theta_t^{\lambda-1}</script><p>考虑给定参数$\Theta$下出现所有样本的概率</p><script type="math/tex; mode=display">P(\mathbf{m}|\Theta) = \prod_{t=1}^k\theta_t^{m_t}</script><p>根据<strong>贝叶斯公式</strong>，得后验分布</p><script type="math/tex; mode=display">\begin{aligned} P(\Theta|\mathbf{m}) &= \frac{P(\mathbf{m}|\Theta)P(\Theta)}{P(\mathbf{m})} \\ &\propto P(\mathbf{m}|\Theta)P(\Theta) \\ &\propto C(\lambda)\prod_{t=1}^k\theta_t^{m_t}\theta_t^{\lambda-1} \\ &\propto \prod_{t=1}^k\theta_t^{m_t+\lambda-1} \end{aligned}</script><p>仔细观察发现，上式也是一个狄利克雷分布的形式，于是根据狄利克雷分布的性质得到期望值</p><script type="math/tex; mode=display">\begin{aligned}E(\theta_i) &= \frac{m_i+\lambda}{\displaystyle \sum_{t=1}^k(m_t+\lambda)} \\ &= \frac{m_i+\lambda}{\displaystyle \sum_{t=1}^km_t+k\lambda} \\  &= \frac{m_i+\lambda}{n+k\lambda} \end{aligned}</script><p>最后，随机变量$\theta_i$取$\theta_i$的期望，得到公式$6$。</p><h4 id="证明2-1"><a href="#证明2-1" class="headerlink" title="证明2"></a>证明2</h4><p>实际上，和上述证明1思路几乎一致，只不过这里换成了证明条件概率。</p><p>我们作出和证明1中类似的假设和记法：</p><ul><li>设所有样本中出现$X_j=a_{jl},Y=c_i$的样本数量为$m_l$，其中$X_j$有$S_j$种可能取值，即$m_l=\sum\limits_{t=1}^n\left[ x^{(t)}_j=a_{jl},y^{(t)}=c_i \right],l\in \{1,2,\dots,S_j\}$，记$\mathbf{m}=(m_1,m_2,\dots,m_{S_j})^T$</li><li>设$P_\lambda(X_j=a_{jl}|Y=c_i)=w_l$，记$\mathbf{w}=(w_1,w_2,\dots,w_{S_j})^T$</li></ul><p>类似地，给参数$\mathbf{w}$一个先验分布——参数为$\lambda$的狄利克雷分布，因此有</p><script type="math/tex; mode=display">\mathbf{Dir}(\mathbf{w}) = C(\lambda) \prod_{t=1}^{S_j}w_t^{m_t}</script><p>剩下的步骤和证明1后续过程几乎一致了，也是先用贝叶斯公式得到后验分布$P(\mathbf{w}|\mathbf{m})$，然后根据狄利克雷分布求出期望值，随即证明出式$7$。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++算法基础</title>
      <link href="/mid-lake-pavilion.github.io/2023/07/23/CPP%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/mid-lake-pavilion.github.io/2023/07/23/CPP%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>做算法题时，往往需要一些最基础的“编程常识”，可以提高解题效率。本篇博客将常见的C++编程解题知识进行记录。</p></blockquote><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><ul><li><code>int</code>。记住一点：<strong><code>int</code>存储数据绝对值数量级不超过$10^9$，而<code>long long</code>存储数据绝对值数量级不超过$10^{18}$</strong>。<ul><li><code>INT_MAX</code>：最大的<code>int</code>类型整数。</li><li><code>INT_MIN</code>：最小的<code>int</code>类型整数。</li></ul></li><li><code>float, double</code>。记住一点：遇到浮点数，尽量使用<code>double</code>。</li><li><code>string</code>。</li></ul><h2 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h2><ul><li><p>宏</p><p><code>#define PI 3.14159</code>，<code>#define P pair&lt;int, int&gt;</code></p></li><li><p>typedef关键字</p><p><code>typedef pair&lt;int, int&gt; P;</code>，<code>typedef long long LL</code></p></li></ul><h2 id="memset与fill"><a href="#memset与fill" class="headerlink" title="memset与fill"></a>memset与fill</h2><p><code>memset(array, element, buffer)</code>，位于头文件<code>&lt;stdio.h&gt;</code>中，将数组<code>array</code>中大小为<code>buffer</code>的区域全部置为同一个元素<code>element</code>（通常为0或者-1），常见用法为<code>memset(arr, 0, sizeof(arr))</code>，将数组<code>arr</code>初始化为全零。</p><p><code>fill(array, element, buffer)</code>，<code>element</code>为1，但是执行速度没有<code>memset</code>快。</p><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>结构体也有自己的构造函数，请注意：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct s &#123;    string name;    int age;    s(string name, int age): name(name), age(age) &#123;&#125;&#125; Student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果按照上述写法给结构体编写了显式的构造函数，那么就不能不经初始化定义一个结构体了，因为默认的构造函数<code>s() &#123;&#125;</code>被覆盖。因此，完整的、容错性最好的写法如下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct s &#123;    string name;    int age;    s() &#123;&#125; &#x2F;&#x2F; 显式编写空的构造函数，防止被覆盖    s(string name, int age): name(name), age(age) &#123;&#125;&#125; Student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>常用C++中的输入输出操作符<code>cin</code>和<code>cout</code>。</p><ul><li><code>cin</code>读取缓冲区，直到遇到空白符</li><li><code>getline(cin, str)</code>，其中<code>str</code>为<code>string</code>容器，<strong>它读取缓冲区，直到遇到换行符，因此很适合读取一整行的输入</strong></li><li><code>cout</code>将缓冲区输出</li></ul><h2 id="行末空格符处理"><a href="#行末空格符处理" class="headerlink" title="行末空格符处理"></a>行末空格符处理</h2><p>有些算法题要求控制行末不允许出现空格符，比较坑，因为可能导致格式错误，处理方法也很简单，在循环内部加一个判断分支即可（比较繁琐）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i;for(i&#x3D;0; i&lt;arr.size(); i++) &#123;    if(i !&#x3D; arr.size()-1)cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;    elsec&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自编码器-实战</title>
      <link href="/mid-lake-pavilion.github.io/2023/03/09/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-%E5%AE%9E%E6%88%98/"/>
      <url>/mid-lake-pavilion.github.io/2023/03/09/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>paper：Icentia11K: An Unsupervised Representation Learning Dataset for Arrhythmia Subtype Discovery，<a href="https://arxiv.org/pdf/1910.09570">https://arxiv.org/pdf/1910.09570</a></p><p>code： <a href="https://github.com/shawntan/icentia-ecg">https://github.com/shawntan/icentia-ecg</a></p><p>datasets： <a href="https://academictorrents.com/details/af04abfe9a3c96b30e5dd029eb185e19a7055272">https://academictorrents.com/details/af04abfe9a3c96b30e5dd029eb185e19a7055272</a></p></blockquote><p>这篇论文指出了基于心电信号进行心率分类这个任务，作者采取了半监督学习的方式，对以往已经取得不错结果的监督学习方式发起了挑战。同时，作者还公开了一个数据集。代码部分主要是对各种机器学习方法进行分类效果的评估。</p><p>这里着重看一看代码中关于自编码器的部分。</p><h2 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>自编码器其实是一类特殊的前馈神经网络。它所做的工作可以简单概括为：<strong>将输入复制到输出</strong>。除开常规的输入层$\mathbf{x}$和输出层$\mathbf{y}$，它往往还包含了隐藏层$\mathbf{h}$；其结构包括了两个部分：</p><ul><li>编码器（Encoder），表示为一个函数，将输入层$\mathbf{x}$映射到隐藏层$\mathbf{h}$：$\mathbf{h}=f(\mathbf{x})$</li><li>解码器（Decoder），表示为一个函数，将隐藏层$\mathbf{h}$映射到输出层$\mathbf{y}$：$\mathbf{y}=g(\mathbf{h})$</li></ul><p>那么，自编码器模型整体可以描述为</p><script type="math/tex; mode=display">\mathbf{y}=g(f(\mathbf{x}))</script><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-169007057373226.png" alt="自编码器"></p><p>如果只是一味地让自编码器的输出$\mathbf{y}$和输入$\mathbf{x}$完全相同，这毫无疑问舍近求远失去了意义。一般地，<strong>自编码器中更加关注编码器的输出结果，即隐藏层$\mathbf{h}$</strong>。比如，如果$\mathbf{h}$的维度比$\mathbf{x}$小，编码器就相当于学习到了原始输入的更加显著的特征。这种想法，与诸如主成分分析一般的降维算法有些相似。</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>自编码器也是前馈神经网络，它的训练和一般的前馈神经网络很类似，即定义损失函数、然后梯度下降，只不过，这是一种<strong>无监督的学习方式</strong>，无需额外的标注工作，因为它的学习目标就是原始的输入数据。更一般地，可以采取小批量的随机梯度下降，不断地逼近要学习的原始数据。</p><p>损失函数用数学语言描述为</p><script type="math/tex; mode=display">\mathbf{Loss}=\mathcal{L}(\mathbf{x},g(f(\mathbf{x})))</script><p>其中具体的损失函数$\mathcal{L}$因情况而定，比如可以是均方差$MSE$。</p><h2 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h2><p>接下来，借助现有的代码，理解一下自编码器以及训练过程。其实，正如前面提到过的，这个过程和一般的前馈神经网络很像。</p><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>准备数据始终是第一步，这一部分的代码主要在<code>train_autoencoder.py</code>中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># train_autoencoder.py</span><span class="token keyword">def</span> <span class="token function">data_stream</span><span class="token punctuation">(</span>filenames<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''     用于读取文件，返回可以拿来训练的数据用    filenames: list，文件名列表    shuffle: 是否打乱    batch_size: 批量，默认为16    '''</span>    stream <span class="token operator">=</span> data_io<span class="token punctuation">.</span>stream_file_list<span class="token punctuation">(</span>        filenames<span class="token punctuation">,</span>        buffer_count<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span>        batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span>        chunk_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>        shuffle<span class="token operator">=</span>shuffle    <span class="token punctuation">)</span>    stream <span class="token operator">=</span> data_io<span class="token punctuation">.</span>threaded<span class="token punctuation">(</span>stream<span class="token punctuation">,</span> queue_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> stream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数中将数据集进行了划分，比例为9:1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">directory <span class="token operator">=</span> <span class="token string">'icentia-ecg\datasets'</span> <span class="token comment"># 这里是自己定义的数据集存放位置（相对路径）</span>filenames <span class="token operator">=</span> <span class="token punctuation">[</span> directory <span class="token operator">+</span> <span class="token string">"\\%05d_batched.pkl.gz"</span> <span class="token operator">%</span> i              <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span> <span class="token punctuation">]</span> <span class="token comment"># 这里自己调整，不用全部的数据集，只使用编号00000到00020的数据集</span>train_count <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>filenames<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.9</span><span class="token punctuation">)</span><span class="token comment"># 划分训练集和验证集</span>train_filenames <span class="token operator">=</span> filenames<span class="token punctuation">[</span><span class="token punctuation">:</span>train_count<span class="token punctuation">]</span>valid_filenames <span class="token operator">=</span> filenames<span class="token punctuation">[</span>train_count<span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搭建自编码器"><a href="#搭建自编码器" class="headerlink" title="搭建自编码器"></a>搭建自编码器</h3><p>关于自编码器的模型的代码主要在<code>model.py</code>中的<code>class Autoencoder</code>，这里限于篇幅不贴出来，而是尝试绘制了自编码器的结构示意图。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/ecg%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-169007073195927.png" alt="ecg自编码器"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># model.py/Autoencoder</span><span class="token keyword">def</span> <span class="token function">encode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_flat<span class="token punctuation">)</span><span class="token punctuation">:</span>    encoding_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>frame_bn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>autoencode_1<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>input_flat<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> encoding_1<span class="token keyword">def</span> <span class="token function">decode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span><span class="token punctuation">:</span>    output <span class="token operator">=</span> self<span class="token punctuation">.</span>autoencode_1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>encoding<span class="token punctuation">)</span>    <span class="token keyword">return</span> output<span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">input</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">input</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>mean<span class="token punctuation">)</span> <span class="token operator">/</span> self<span class="token punctuation">.</span>std    input_flat <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    output <span class="token operator">=</span> self<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>input_flat<span class="token punctuation">)</span><span class="token punctuation">)</span>    output <span class="token operator">=</span> output<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># input为原始输入，output为自编码器的输出，直接计算损失</span>    loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">(</span>output <span class="token operator">-</span> <span class="token builtin">input</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># loss = torch.mean(abs(output - input))</span>    <span class="token keyword">return</span> loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中的自编码器结构还是很简单的，其实这里的编码器和解码器都只是一个类似残差块的结构（代码中的<code>ResidualEncoder</code>、<code>ResidualDecoder</code>），但是注意，实际上<code>Autoencoder</code>中的二级结构为<code>ConvAutoencoder</code>，只不过<code>ConvAutoencoder</code>这里仅由一个<code>ResidualEncoder</code>和一个<code>ResidualDecoder</code>构成。总的来说，编码器、解码器结构十分明显，它们结构上呈现出对称感，共同完成将原始输入映射到隐藏层编码，然后再映射回去的任务。</p><p>将程序运行的结果截图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Luqingbys/blogs_images@main/images/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="程序运行结果"></p><p>另外，<code>loss = torch.sqrt(torch.mean((output - input)**2))</code>可以看出，这里的损失函数选用的是均方根误差；学习的对象也正是原始的输入数据<code>input</code>，正是自编码器的初衷。</p><h3 id="开启训练"><a href="#开启训练" class="headerlink" title="开启训练"></a>开启训练</h3><p>再次回到<code>train_autoencoder.py</code>。在正式开启训练之前，创建模型，定义好优化器、参数等等准备工作。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># train</span>model <span class="token operator">=</span> Autoencoder<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># valid_data = torch.from_numpy(signal_data_valid).cuda()[:, None, :]</span><span class="token keyword">for</span> p <span class="token keyword">in</span> model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> p<span class="token punctuation">.</span>dim<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>        torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token comment"># model = torch.load('model.pt')</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>parameters <span class="token operator">=</span> model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 优化器</span>optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>parameters<span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e-3</span><span class="token punctuation">)</span> <span class="token comment"># , weight_decay=1e-6)</span><span class="token comment"># optimizer = optim.SGD(parameters, lr=0.05, momentum=0.999)</span>scheduler <span class="token operator">=</span> optim<span class="token punctuation">.</span>lr_scheduler<span class="token punctuation">.</span>ReduceLROnPlateau<span class="token punctuation">(</span>    optimizer<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'min'</span><span class="token punctuation">,</span>    factor<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> patience<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> threshold<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">,</span>    threshold_mode<span class="token operator">=</span><span class="token string">'rel'</span><span class="token punctuation">,</span> cooldown<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> min_lr<span class="token operator">=</span><span class="token number">1e-6</span><span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e-08</span><span class="token punctuation">)</span><span class="token comment"># 训练轮数</span>epochs <span class="token operator">=</span> <span class="token number">10</span><span class="token comment"># batch_count = signal_data_batched.shape[0] // batch_size</span>best_loss <span class="token operator">=</span> np<span class="token punctuation">.</span>infi <span class="token operator">=</span> <span class="token number">0</span><span class="token builtin">input</span> <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启训练。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># train_autoencoder.py</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    running_loss <span class="token operator">=</span> <span class="token number">0.0</span>    time_step_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> data_stream<span class="token punctuation">(</span>train_filenames<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># get the inputs</span>        <span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>data<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># zero the parameter gradients</span>        <span class="token comment"># forward + backward + optimize，model(input)直接返回输出和原始输入之间的损失</span>        loss <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>        <span class="token comment"># print(loss)</span>        <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>clip_grad_norm_<span class="token punctuation">(</span>parameters<span class="token punctuation">,</span> <span class="token number">10.</span><span class="token punctuation">)</span>            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># print statistics</span>        total_samples <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span>        running_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> total_samples        time_step_count <span class="token operator">+=</span> total_samples        i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> i <span class="token operator">%</span> report_every <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token comment"># print every 500 mini-batches</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[%d, %5d] loss: %.3f'</span> <span class="token operator">%</span>                  <span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> i<span class="token punctuation">,</span> running_loss <span class="token operator">/</span> time_step_count<span class="token punctuation">)</span><span class="token punctuation">)</span>            running_loss <span class="token operator">=</span> <span class="token number">0.0</span>            time_step_count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token punctuation">(</span>report_every <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># print()</span>            <span class="token comment"># print("REPORTING")</span>            <span class="token comment"># print()</span>            model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                total_loss <span class="token operator">=</span> <span class="token number">0.</span>                count <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">for</span> data <span class="token keyword">in</span> data_stream<span class="token punctuation">(</span>valid_filenames<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                        batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># get the inputs</span>                    <span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>data<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>                    loss <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>                    <span class="token comment"># print(loss)</span>                    total_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>data<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>                valid_loss <span class="token operator">=</span> total_loss <span class="token operator">/</span> count                <span class="token keyword">if</span> valid_loss <span class="token operator">&lt;</span> best_loss<span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Best valid loss:"</span><span class="token punctuation">,</span> valid_loss<span class="token punctuation">)</span>                    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'model.pt'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>                        torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>model<span class="token punctuation">,</span> f<span class="token punctuation">)</span>                    best_loss <span class="token operator">=</span> valid_loss                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Valid loss:"</span><span class="token punctuation">,</span> valid_loss<span class="token punctuation">)</span>            random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>valid_filenames<span class="token punctuation">)</span>            scheduler<span class="token punctuation">.</span>step<span class="token punctuation">(</span>valid_loss<span class="token punctuation">)</span>            model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python读写excel表格</title>
      <link href="/mid-lake-pavilion.github.io/2022/05/21/Python%E8%AF%BB%E5%86%99excel%E8%A1%A8%E6%A0%BC/"/>
      <url>/mid-lake-pavilion.github.io/2022/05/21/Python%E8%AF%BB%E5%86%99excel%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="Python读写Excel文件"><a href="#Python读写Excel文件" class="headerlink" title="Python读写Excel文件"></a>Python读写Excel文件</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>要使用Python的pandas库对excel进行读写，具体内容是将一张汇总的表格中的数据，按学院分类统计到不同的Sheet中，前后效果图如下。</p><p><img src="C:\Users\湖心亭\AppData\Roaming\Typora\typora-user-images\image-20220521151745267.png" alt="image-20220521151745267"></p><p><img src="C:\Users\湖心亭\AppData\Roaming\Typora\typora-user-images\image-20220521151932125.png" alt="image-20220521151932125"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Python的pandas库可以很方便地对excel表格进行读写操作。由于涉及多张Sheet表的读写，这里引入几个很重要的函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pdfp <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_excel<span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span> <span class="token comment"># 读取之后，fp将保存excel的二维表</span>fp<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>values <span class="token comment"># 可以获取fp中第index行的数据，列表形式</span>writer <span class="token operator">=</span> fp<span class="token punctuation">.</span>ExcelWriter<span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span> <span class="token comment"># 方便读写一个Excel文件的多个Sheet</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>事先创建好一个字典（列表也可），键名为各个学院名，值为空列表；</p><p>逐行读取汇总表，获取到每一行的学院，将当前行信息加入到学院所属的列表之中，待行遍历结束后，统一调用<code>pd.DataFrame(data, &#39;...&#39;)</code>创建新的Sheet表或者向已有的Sheet中追加数据。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pandas as pdimport numpy as np# 创建分院统计表并打开，方便写多个Sheetfresult &#x3D; pd.DataFrame()fresult.to_excel(&#39;.&#x2F;test.xlsx&#39;)fdata &#x3D; pd.ExcelWriter(&#39;.&#x2F;test.xlsx&#39;)path &#x3D; &#39;...&#39;fp &#x3D; pd.read_excel(path, sheet_name&#x3D;0)dicts &#x3D; &#123;    &#39;计算机科学与技术学院&#39;: [],    &#39;材料科学与工程学院&#39;: [],    &#39;信息科学与工程学院&#39;: [],    &#39;理学院&#39;: [],    &#39;新能源学院&#39;: [],    &#39;经济管理学院&#39;: [],    &#39;船舶与海洋工程学院&#39;: [],    &#39;语言文学学院&#39;: [],    &#39;汽车工程学院&#39;: [],    &#39;海洋科学与技术学院&#39;: [],&#125;# 逐行读取汇总表，分类加入数组for i in range(1, fp.shape[0]):    print(fp.iloc[i].values)    data &#x3D; fp.iloc[i].values    data[1] &#x3D; str(data[1])    department &#x3D; data[2] # 获取到学生学院    dicts[department].append(np.array(data))# 写入分好类的excel表格for key in dicts.keys():    data &#x3D; np.array(dicts[key])    write &#x3D; pd.DataFrame(data, columns&#x3D;[&#39;姓名&#39;, &#39;学号&#39;, &#39;学院&#39;])    write.to_excel(fdata, sheet_name&#x3D;key)fdata.save()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 玩转Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练之动态规划</title>
      <link href="/mid-lake-pavilion.github.io/2022/04/08/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A-%E8%B4%AA%E5%BF%83/"/>
      <url>/mid-lake-pavilion.github.io/2022/04/08/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>第一题</p><script type="math/tex; mode=display">\begin{flalign}& quicksort(F,p,r):\\&If\ p < r\\& \qquad q = partition(F,p,r);\\& \qquad quicksort(F,p,q-1);\\& \qquad quicksort(F,p+1,r);\\& \\& partition(F,p,r):\\& x = F[r].length\\& i = p-1\\& for j = p\ to\ r-1\\& \qquad If\ F[j].length<= x\\& \qquad \qquad i++;\\& \qquad \qquad exchange(F[i],F[j]);\\& exchange(F[i+1], F[r]);\\& return\ i+1;\end{flalign}</script><p>第二题</p><script type="math/tex; mode=display">\begin{flalign}& 算法: W为原始任务序列，T为耗费时间序列，E为截止时间序列\\& S为截止时间升序排列的优先队列;\\& currentTime = 0;\\& While\ W != null\ Do \\& \qquad item = Min(T); \\& \qquad currentTime = t(item);\\& \qquad S.push(i); \\& \qquad For\ ele \ in \ W \\& \qquad \qquad If\ E(ele) < currentTime\\& \qquad \qquad \qquad W.remove(w(item));\\& \qquad \qquad Else \\& \qquad \qquad \qquad currentTime = currentTime + t(ele);\\&Return \ S;\end{flalign}</script><p>实验一</p><h2 id="Divide"><a href="#Divide" class="headerlink" title="Divide"></a>Divide</h2><p>每次将数组A[s:t]尽可能平均地分成两个子数组$A[s:\lfloor \frac{s+t}{2} \rfloor], A[\lfloor \frac{s+t}{2} \rfloor+1: t]$ 。</p><h2 id="Conquer"><a href="#Conquer" class="headerlink" title="Conquer"></a>Conquer</h2><p>递归地在每一个子数组中计算反序的个数，如果当前数组长度小于等于2时，递归结束，如果左边的元素大于右边的元素，返回该最小长度数组中反序的个数1。</p><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>在两个数组已经计算出来各自反序个数的前提下，两个数组合并后的总反序数=各自的反序数+两者合并新增的反序数。在待处理的两个子数组已经排好序的前提下，不需要按照普通的暴力比较算法逐个遍历了，只需将左边元素和右边排好序的数组进行比较，找到一个反序数，即可退出当前元素的处理了。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><script type="math/tex; mode=display">\begin{flalign}& MergeAndSort(begin,\ end):\\& if\ begin >= end\\& \qquad Return;\\& len = end - begin;\\& nums = [];\\& mid = (begin + end) / 2;\\& counter = MergeAndSort(begin, \ mid) + MergeAndSort(mid+1, \ end);\\& p_1 = begin,\ p_2 = mid+1;\\ & while \ p_1 <= mid\ and\ p_2 <= end\\& \qquad 数组A[begin:mid]与数组A[mid+1:end]逐个排序,填入新数组nums, 指针p_1、p_2不断后移,在排序过程中记录反序数counter;\\& while \ p_1 <= mid\\& \qquad 将剩下的数组中的元素填充至nums[];\\& while \ p_2 <= mid\\& \qquad 将剩下的数组中的元素填充至nums[];\\& 用新的排好序数组元素替换掉原数组对应部分的元素\end{flalign}</script>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言程序设计</title>
      <link href="/mid-lake-pavilion.github.io/2022/04/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2022/04/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>在开始之前，我们约定一种写法，（reg）表示寄存器reg中的内容。</p><h1 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h1><h2 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h2><p>在程序末尾添加返回程序段的代码为：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax, 4c00Hint 21H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的<code>int 21H</code>表示21号中断，并不是整型变量的意思。</p><p>几个表示结束的（伪）指令：</p><ul><li>通知编译器一个段结束：<code>段名 ends</code></li><li>通知编译器程序结束：<code>end</code></li><li>程序返回：见上汇编指令</li></ul><h2 id="程序执行过程的跟踪"><a href="#程序执行过程的跟踪" class="headerlink" title="程序执行过程的跟踪"></a>程序执行过程的跟踪</h2><p>Debug可以用来监视程序的执行。</p><h3 id="使用R命令查看各个寄存器的内容"><a href="#使用R命令查看各个寄存器的内容" class="headerlink" title="使用R命令查看各个寄存器的内容"></a>使用R命令查看各个寄存器的内容</h3><blockquote><p>Debug命令可以将汇编程序装入内存，就R命令而言，它为我们查看指定内存中的内容提供了机会；但是，我们应该查看哪里的内容？要回答这个问题，我们需要明白程序究竟被装入了内存的哪个地方。</p></blockquote><p>使用-r命令后，我们会发现DS（数据段）与CS（代码段）指向的地址并不相同。更准确地说，CS总是比DS大了16（比如DS=075C，CS=076C），下面简单说一下原因：</p><ol><li>程序被装入内存，内存中会有一段起始地址为SA:0000（起始地址的偏移地址为0）的容量足够的空闲内存区；</li><li>在这段内存区的前256个字节中，会创建一个PSP的数据区，此处不需要深入理解；</li><li>从这段内存区的256字节处开始（即PSP数据区后面）装入程序，<strong>程序的地址被设为SA+10H: 0</strong>。</li><li>将该内存区的段地址存入DS中（操作系统将程序作为数据加载到内存中），初始化其他相关寄存器，设置CS: IP指向程序的入口。</li></ol><h3 id="使用T命令单步执行程序中的每一条指令并观察执行结果"><a href="#使用T命令单步执行程序中的每一条指令并观察执行结果" class="headerlink" title="使用T命令单步执行程序中的每一条指令并观察执行结果"></a>使用T命令单步执行程序中的每一条指令并观察执行结果</h3><p>当到了结束指令<code>int 21</code>时，改用P命令执行。</p><h1 id="BX-与Loop指令"><a href="#BX-与Loop指令" class="headerlink" title="[BX]与Loop指令"></a>[BX]与Loop指令</h1><h2 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h2><p>[bx]是内存单元。要完整地描述一个内存单元，需要两种信息：</p><ul><li>内存单元的地址</li><li>内存单元的长度</li></ul><p>比如，我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在<strong>ds（数据段）</strong>中，单元长度可以由具体指令中的其他操作对象（如前面的寄存器）指出。</p><pre class="line-numbers language-ass" data-language="ass"><code class="language-ass">mov ax, [2]; 将以DS为基地址，2为偏移地址中的内容移送给寄存器axmov [2], ax; 将ax中的内容移送到以DS为基地址，2为偏移地址之中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是在指令<code>mov ax [0]</code>中，编译器并不是将0偏移地址单元传入ax，而是将0传入ax；如果要实现前者效果，应该先将偏移量传入bx，再将[bx]传入：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movbx, 0mov ax, [bx]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的bx中存放的数据作为一个偏移地址EA，段地址SA默认在DS中，将SA: EA处存放的数据移送到寄存器ax中。</p><p>在MASM编译器中，对比以下指令：</p><ul><li><code>mov al, [0]</code>表示将0移送到al</li><li><code>mov al, ds: [0]</code>表示将DS段中，偏移地址为0的内容移送到al</li><li><code>mov al, [bx]</code>表示将DS段中，偏移地址为bx的内容移送到al中</li><li><code>mov al, ds: [bx]</code>和上一个一致</li></ul><h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p>再次回到指令<code>mov ax, [bx]</code>，内存单元的偏移地址由bx给出，而段地址默认在ds（数据段寄存器）中。</p><p>此外，我们也可以在访问内存单元的指令中，显式地给出内存单元的段地址所在的段寄存器，比如我们要访问内存单元，显式地指明内存单元的段地址“ds”、“cs”、“ss”、“es”，这些在汇编语言中被称为<strong>段前缀</strong>。</p><h2 id="循环Loop指令"><a href="#循环Loop指令" class="headerlink" title="循环Loop指令"></a>循环Loop指令</h2><p>loop指令有两个注意点：</p><ol><li>循环次数存放在寄存器cx中，<strong>注意尽量让该操作靠近循环程序段，否则很有可能不小心改变了cx中的内容</strong>；</li><li>loop指令后面跟的标号所标识的地址要在loop指令之前</li></ol><p>循环程序框架为：</p><pre class="line-numbers language-ass" data-language="ass"><code class="language-ass">mov cx, 循环次数s:循环执行的程序段loop s; 循环执行程序段s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>_例题_ 计算ffff: 0006单元中的数，将其乘以3，结果存放在dx中，编程计算。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume CS: codecode SEGMENT    start:         mov ax, 0ffffH        mov ds, ax        mov bx, 0006H        mov al, [bx]        mov ah, 0        mov dx, 0; dx要事先清零        mov cx, 2    s:  add dx, ax        loop s        mov ax, 4100H        int 21H    code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序简析：ffff: 0006单元中，ffff为基地址，0006为偏移地址，前者送入数据段寄存器DS，后者送入BX；[bx]即表示以DS为基地址、bx为偏移地址处的内容。另外注意dx事先要清零。</p><h2 id="相关debug命令"><a href="#相关debug命令" class="headerlink" title="相关debug命令"></a>相关debug命令</h2><p>之前我们已经学习过，使用r命令查看当前各个寄存器的内容、使用d命令查看指定内存中的内容（格式：<code>-d 段基址:偏移地址</code>），以及使用t命令单步执行汇编语句。</p><p>那么，现在学过了循环指令loop之后，更多时候使用t命令似乎不太现实了，毕竟循环语句的单步执行意义不大。对此，我们需要掌握另外两个重要的debug命令：</p><ul><li>-u命令：查看当前每一条代码的存放地址，以及其内容</li><li>-g命令：跳转到指定的地址，执行代码，格式：<code>-g 段基址:偏移地址</code>，需要说明都是，<strong>往往先使用-u命令查看当前所有代码语句的所在地址，然后使用-g跳转到目标地址，直接执行那个地方存放的代码。</strong></li></ul><h2 id="两者结合使用的栗子"><a href="#两者结合使用的栗子" class="headerlink" title="两者结合使用的栗子"></a>两者结合使用的栗子</h2><p>_例题_ 计算ffff:0 ~ ffff:b单元中的数据之和，并将结果存储在dx中。</p><p>分析：将内存单元中的8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界。思路如下(X是偏移地址量)：</p><pre class="line-numbers language-none"><code class="language-none">(al) &#x3D; ((ds)*16 + X)(ah) &#x3D; 0(dx) &#x3D; (dx) + (ax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际编程中，经常会遇到，用同一种方法处理地址连续的内存单元中的数据的问题。此时，就需要用到循环来解决这类问题，同时，设置一些变量，以便于循环变化。</p><h1 id="多个段的使用"><a href="#多个段的使用" class="headerlink" title="多个段的使用"></a>多个段的使用</h1><h2 id="使用代码段"><a href="#使用代码段" class="headerlink" title="使用代码段"></a>使用代码段</h2><p>求给定的一组数据的和，将结果存放在ax中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">assume cs: codesgcodesg SEGMENT    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H; 定义若干数据，它们被存放在代码段中，由于在起始位置，故偏移地址为0    mov bx, 0    mov ax, 0    mov cx, 8s:  add ax, cs: [bx]    add bx, 2    loop s        mov ax, 4c00H    int 21Hcodesg endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用堆栈段"><a href="#使用堆栈段" class="headerlink" title="使用堆栈段"></a>使用堆栈段</h2><p>利用栈，将一组数据逆序存放（假设给定的数据已经按顺序存放在了代码段CS中）。首先我们需要大致明白堆栈段以及堆栈段寄存器。</p><ul><li>堆栈段位于内存中，在此处可以利用为栈结构；</li><li>堆栈段寄存器SS存储的是堆栈段的<strong>段基址</strong>；</li><li>此外，还有堆栈指针寄存器SP，它用来指向此时欲操作的堆栈段地址（实际上是偏移地址，配合SS就可以在内存中完全锁定地址）</li></ul><p>这样一来，我们就可以让代码段中的原始数据先入栈、再出栈，代码段中就可以得到逆序的数据了。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">~~~## 数据、代码、栈的分开管理在这一部分，我们将之前的程序进行优化：将数据、代码、栈放入不同的段，实现简单的封装。~~~ assemblyASSUME CS: codesg, DS: datasg, SS: stacksgdatasg SEGMENT; 表示声明一片数据段    dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987Hdatasg endsstacksg SEGMENT; 表示声明一片堆栈段    dw 0, 0, 0, 0, 0, 0, 0, 0stacksg endscodesg SEGMENT; 表示声明一片代码段start:  mov ax, stacksg        mov ss, ax; 将我们自己定义的“堆栈段”的地址作为堆栈寄存器SS的指向（段基址）        mov sp, 16; 将堆栈指针寄存器指向偏移地址为16处（配合SS），即栈底        mov ax, datasg        mov ds, ax; 将我们自己定义的“数据段”的地址作为数据寄存器DS的指向（段基址）        mov bx, 0; 数据段的偏移地址，初始化为0        mov cx, 8; 设置循环次数    s:  push [bx]; 入栈操作，DS: [BX]处的内容进入栈底，以此类推        add bx, 2; 偏移地址自增2        loop s        mov bx, 0        mov cx, 8    s1: pop [bx]        add bx, 2        loop s1        mov ax, 4100H        int 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="更灵活的定位内存地址"><a href="#更灵活的定位内存地址" class="headerlink" title="更灵活的定位内存地址"></a>更灵活的定位内存地址</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><ul><li><p>and指令：逻辑与，按位与运算</p><p><strong>通过and指令，可以将操作对象的相应位设为0，而其他位不变。</strong>比如，将al的第六位设为0，可以使用<code>and al, 10111111B</code>。</p></li><li><p>or指令：逻辑或，按位或运算</p><p><strong>通过or指令，可以将操作对象的相应位设为1，而其他位不变。</strong></p></li></ul><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>通过一套共用的规则，将字符与（8位）二进制数建立一一对应。</p><p>比如，<code>mov al, &#39;a&#39;</code>相当于把‘a’的ASCII码值61H送入寄存器al。</p><h2 id="大小写字母转换"><a href="#大小写字母转换" class="headerlink" title="大小写字母转换"></a>大小写字母转换</h2><p>将给定的一个全部由字母组成的字符串全部转换为小写或者大写形式。</p><h2 id="进一步讨论内存的定位"><a href="#进一步讨论内存的定位" class="headerlink" title="进一步讨论内存的定位"></a>进一步讨论内存的定位</h2><h3 id="数组的寻址"><a href="#数组的寻址" class="headerlink" title="数组的寻址"></a>数组的寻址</h3><p>有如下命令：</p><ul><li><p><code>mov ax, [bx+200]</code>，表示将段基址（段地址）为（ds）、偏移地址为（bx）+200这个内存单元中的数据送入ax，即：</p><p>（ax）=（（ds）*16+（bx）+20）</p></li></ul><p>这种内存定位方式给予了我们更多的思考。就形式[bx+offset]而言，如果offset是一个可以改变的变量，bx固定指向一个地址，那么我们就可以轻而易举地访问一段连续的地址了——这就是访问数组的有效方法。</p><h3 id="SI与DI"><a href="#SI与DI" class="headerlink" title="SI与DI"></a>SI与DI</h3><p>SI（源地址寄存器）、DI（目的变址寄存器）和BX（基址寄存器）都是通用寄存器，功能相近。它们最大的区别是：</p><p>SI、DI不可以分成两个8位寄存器来使用，事实上，<strong>它们只能按16位进行存取操作</strong>；</p><blockquote><p>之所以在BX之外设置SI、DI，很大程度上是因为就寻址而言，仅仅一个BX不够用。</p></blockquote><p>以下操作实现的效果一致：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov bx, 0mov ax, [bx]mov si, 0mov ax, [si]mov di, 0mov ax, [di]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寄存器寻址总结"><a href="#寄存器寻址总结" class="headerlink" title="寄存器寻址总结"></a>寄存器寻址总结</h3><blockquote><p>在8086CPU中，只有BX、BP、SI、DI这四个寄存器可以用在方括号[]中进行内存单元的寻址。</p></blockquote><p>对于寄存器BP，只要用到[BP]这种寻址，那么指令默认段地址在堆栈段寄存器SS中。</p><p>那么，机器指令在处理数据时，数据所在位置有哪些呢？</p><ul><li>CPU内部，比如<code>mov bx, ax</code>（把通用寄存器AX中的值送入BX）、<code>mov bx, 1</code>（1是一个立即数，它事先存放在指令缓冲器中）</li><li>内存中，比如<code>mov bx, [0]</code></li><li>端口中</li></ul><h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><p>在8086中，CPU的转移指令可以分为：</p><ul><li>无条件转移指令</li><li>条件转移指令</li><li>循环指令</li><li>子过程</li><li>中断</li></ul><h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>伪指令offset用于在汇编语言中<strong>取标号的偏移地址</strong>。</p><p>这里的标号，其实就是指示某一片地址的符号，比如</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">codesg segmentstart:...codesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的start就是一个标号。<code>offset start</code>即表示取出start这一行指令所在的偏移地址（比如后续可以将其存入基址寄存器BX等，配合代码段寄存器CS，定位内存）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">datasg segmentarraydb 1, 2, 3, 4, 5db 9, 8, 7, 6, 5datasg ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这其中的array也是一个标号。<code>offset array</code>即表示取出array这一行的第一个变量的偏移地址。</p><h2 id="JMP-指令"><a href="#JMP-指令" class="headerlink" title="JMP 指令"></a>JMP 指令</h2><p>无条件转移指令。</p><h3 id="段间转移"><a href="#段间转移" class="headerlink" title="段间转移"></a>段间转移</h3><p><code>jmp far ptr 标号</code></p><h2 id="有条件跳转指令"><a href="#有条件跳转指令" class="headerlink" title="有条件跳转指令"></a>有条件跳转指令</h2><p>有条件转移指令都是短转移指令。</p><ol><li><p>jcxz指令</p><p>格式：<code>jcxz 标号</code>    如果（CX）=0，则转移到标号处执行。</p></li></ol><h1 id="call-和ret指令"><a href="#call-和ret指令" class="headerlink" title="call 和ret指令"></a>call 和ret指令</h1><h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><p>必须有一个保存“断点”的操作，将CALL指令的下一条指令的段基址CS和偏移地址IP进栈保存（当然，若为段内调用，只需保存IP的值）</p><h2 id="RET指令"><a href="#RET指令" class="headerlink" title="RET指令"></a>RET指令</h2><p>返回断点。</p><ul><li>RET段内返回指令，将SP+1、SP中的值赋值给IP（指令指针，保存的是偏移地址），然后SP自增2；</li><li>RETF段间返回指令，先将SP+1、SP中的值赋值给IP，同时SP自增2，再将SP+1、SP中的值赋值给CS（代码段基址寄存器）</li></ul><h2 id="子程序设计（模块化程序设计）"><a href="#子程序设计（模块化程序设计）" class="headerlink" title="子程序设计（模块化程序设计）"></a>子程序设计（模块化程序设计）</h2><p>call和ret配合使用，可以实现子程序的执行：把call指令后面的指令地址存储在栈中，所以可以在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处执行。</p><p>对于模块化程序设计，就需要根据实际问题，将原始问题拆分为多个子问题，从而用子程序分别实现。</p><p>那么，首先就会有一个问题：参数传递和结果传递问题。即，主程序的数据如何传递给子程序？子程序运行的结果又如何传递给主程序？</p><p>第一个方法，就是使用寄存器来存储参数，这也是最常使用的方法：调用者（比如主程序）将参数送入（参数）寄存器，从（结果）寄存器中取到返回值；而子程序从（参数）寄存器中取到参数，将返回值送入结果寄存器。</p><p>第一种方法的缺陷很明显。如果参数比较多的时候，不可能将它们都存入寄存器。第二种方法，就是使用内存传递参数。</p><p>第三种方法，也是最合适的方法，就是使用栈。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法模型</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/31/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/31/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>李华想要去旅游。他有三个意向去处：苏杭、桂林、北戴河。该如何选择呢？</p></blockquote><h1 id="一个简单的栗子"><a href="#一个简单的栗子" class="headerlink" title="一个简单的栗子"></a>一个简单的栗子</h1><p>我们从这个很简洁的栗子看起。为了比较这三个旅游景点哪个对于李华而言最好，肯定就需要确定该比较哪几个方面。一般对于这类评价型问题，我们需要查阅资料、广泛讨论，综合多方面的说法，选取几个有代表性的指标作为比较项。比如，我们就选择五个指标进行比较：</p><p>景色、花费、居住、饮食、交通。</p><h2 id="权重的产生"><a href="#权重的产生" class="headerlink" title="权重的产生"></a>权重的产生</h2><h3 id="得到判断矩阵"><a href="#得到判断矩阵" class="headerlink" title="得到判断矩阵"></a>得到判断矩阵</h3><p>对于问题中给出的不同指标在评价者心中的“重要性”，我们需要给出它们的权重。首先，需要将这种定性的“重要性”进一步量化成不同的“标度”：</p><div class="table-container"><table><thead><tr><th>标度</th><th>含义</th></tr></thead><tbody><tr><td>1,3,5,7,9</td><td>表示两个因素相比，一个因素比另一个同等/稍微/明显/强烈/极端重要</td></tr><tr><td>2,4,6,8</td><td>上述标度的中值</td></tr><tr><td>倒数</td><td>互逆的说法</td></tr><tr><td></td></tr></tbody></table></div><p>以一个栗子进行说明各个量化指标：</p><div class="table-container"><table><thead><tr><th></th><th>景色</th><th>花费</th><th>居住</th><th>饮食</th><th>交通</th></tr></thead><tbody><tr><td>景色</td><td>1</td><td>1/2</td><td>4</td><td>3</td><td>3</td></tr><tr><td>花费</td><td></td><td>1</td><td>7</td><td>5</td><td>5</td></tr><tr><td>居住</td><td></td><td></td><td>1</td><td>1/2</td><td>1/3</td></tr><tr><td>饮食</td><td></td><td></td><td></td><td>1</td><td>1</td></tr><tr><td>交通</td><td></td><td></td><td></td><td></td><td>1</td></tr></tbody></table></div><p>为了进一步规范讨论，我们称上面这张表为一个矩阵，它就是层次分析法中的<strong>判断矩阵</strong>；记该矩阵为A，每一个位置上对应的元素为$a_{ij}$，有如下简单的性质：</p><ul><li>$a_{ij}表示，指标i与指标j相比，i的重要程度$；</li><li>当i=j时，两个指标相同，同等重要；</li><li>对于所有的元素$a_{ij}$，满足$a_{ij} &gt; 0且a_{ji}×a_{ij}=1$，这样的矩阵为<strong>正互反矩阵</strong>。</li></ul><h3 id="权重的计算"><a href="#权重的计算" class="headerlink" title="权重的计算"></a>权重的计算</h3><p>也就是说，在得到判断矩阵之后，我们就可以计算出权重了。</p><h2 id="各项得分的产生"><a href="#各项得分的产生" class="headerlink" title="各项得分的产生"></a>各项得分的产生</h2><h4 id="打分表"><a href="#打分表" class="headerlink" title="打分表"></a>打分表</h4><p>接下来，需要对各个旅游景点，在选定的五个指标上给予定量的评定——打分。打分表形状如下：</p><div class="table-container"><table><thead><tr><th>指标</th><th>权重</th><th>北戴河</th><th>苏杭</th><th>桂林</th></tr></thead><tbody><tr><td>景色</td><td></td><td></td><td></td><td></td></tr><tr><td>花费</td><td></td><td></td><td></td><td></td></tr><tr><td>居住</td><td></td><td></td><td></td><td></td></tr><tr><td>饮食</td><td></td><td></td><td></td><td></td></tr><tr><td>交通</td><td></td><td></td><td></td></tr></tbody></table></div><p>对于各项的得分，我们可以使用和权重的产生同样的方法——两两比较得出判断矩阵：</p><div class="table-container"><table><thead><tr><th>景色</th><th>苏杭</th><th>北戴河</th><th>桂林</th></tr></thead><tbody><tr><td>苏杭</td><td></td><td></td><td></td></tr><tr><td>北戴河</td><td></td><td></td><td></td></tr><tr><td>桂林</td><td></td><td></td></tr></tbody></table></div><p>通过问答形式，我们可以将判断矩阵填充完毕。</p><p>注意：在填写上面的判断矩阵时，有一个易忽视的易错点：对于判断矩阵中的元素$a_{ij}=\frac{第i项的重要程度}{第j项的重要程度}$, $a_{jk}=\frac{第j项的重要程度}{第k项的重要程度}$,因此我们一定有$a_{ik}=\frac{第i项的重要程度}{第k项的重要程度}=a_{ij}×a_{jk}$。满足这个条件的矩阵，称为<strong>一致矩阵</strong>。</p><p>（表）矩阵是一致矩阵，当且仅当：</p><ol><li>$\forall a_{ij}, a_{ij}&gt;0$</li><li>对角线上的每一个元素都为1</li><li>各行（或者各列）之间成比例</li></ol><blockquote><p>一致矩阵的性质：由线性代数知识可得，由于一致矩阵A各行（各列）成比例，r(A)=1，A有一个特征值为n，其余均为0，且特征值n对应的特征向量为$k(\frac{1}{a_{11}}, \frac{1}{a_{12}}, …, \frac{1}{a_{1n}})^T$（k不为零）。</p></blockquote><h4 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h4><p>注意，使用判断矩阵求权重之前，必须对其进行<strong>一致性检验</strong>。我们从特征值角度给出一个检验标准。</p><blockquote><p><strong>引理</strong>：记n阶 正互反矩阵A的最大特征值为$\lambda _m$，则A为一致矩阵当且仅当$\lambda_m = n$；且如果A为非一致矩阵，必有$\lambda_m&gt;n$。</p></blockquote><p>换言之，通过比较待检验矩阵的特征值和n之间的距离，可以判定其一致性。步骤大体如下：</p><ol><li>计算一致性指标CI，$CI=\frac{\lambda_m-n}{n-1}$；</li><li>查找对应的平均随机一致性指标RI；</li><li>根据CI、RI得出一致性比例：$CR=\frac{CI}{RI}$；</li></ol><p>当CR&lt;0.1时，认为判断矩阵的一致性可以接受，否则需要纠正。</p><h4 id="量化得分的计算"><a href="#量化得分的计算" class="headerlink" title="量化得分的计算"></a>量化得分的计算</h4><p>这一部分主要是根据得到的一致矩阵，得出每一项的量化得分。</p><blockquote><p>注意，其实这里的“苏杭”“北戴河”“桂林”都是评价对象，在“景色”这一指标上的得分，也可以看作“权重”。为了和指标与指标间的权重以示区别，下面我们将评价对象在同一指标上的“权重”改称“得分”。</p></blockquote><div class="table-container"><table><thead><tr><th>景色</th><th>苏杭</th><th>北戴河</th><th>桂林</th></tr></thead><tbody><tr><td>苏杭</td><td>1</td><td>2</td><td>4</td></tr><tr><td>北戴河</td><td>1/2</td><td>1</td><td>2</td></tr><tr><td>桂林</td><td>1/4</td><td>1/2</td><td>1</td></tr></tbody></table></div><p>首先，需要对一致矩阵<strong>归一化处理</strong>。即计算每一个元素占当前<strong>列</strong>的所有元素之和的比例，去替换原来的元素。比如1/（1+0.5+0.25）替换$a_{11}$等。</p><p>接下来，我们来看看求权重的方法：</p><ol><li>算术平均法</li><li>几何平均法</li><li>特征值法</li></ol><p>算数平均法、几何平均法比较直观，都是首先归一化之后计算各自的平均值；下面介绍一下<strong>特征值法</strong>，它也是被广泛使用的权重求解方法。</p><p>实际建模过程中，我们得到的矩阵M很可能并不是一致矩阵，但是只要其一致性可以接受，我们就可以仿照一致矩阵权重的求法，来得到每一个评价对象的得分。</p><ul><li>求出矩阵M的最大特征值以及其对应的特征向量；</li><li>对求出的特征向量进行归一化处理，得到得分。</li></ul><p>具体的结果不再赘述。下面我们正式介绍层次分析法。</p><h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><p>我们直接来看看层次分析法的步骤：</p><ol><li><p>分析系统中各因素之间的关系，建立系统的递阶层次结构：</p><ul><li>目标层（选择哪个旅游景点）</li><li>准则层（找出了景色、花费等五个考量指标）</li><li>方案层（苏杭、北戴河、桂林三个选择方案）。</li></ul><p>这些层次结构图需要被放在论文中加以说明。</p></li><li><p>构造判断矩阵：</p><p>判断矩阵用于计算各个指标的权重。</p></li><li><p>构造评价对象关于各个评价指标的得分矩阵，并进行一致性检验</p></li><li><p>计算每一个评价对象的综合得分</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU Octave学习之高级功能</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/30/GNU-Octave%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/30/GNU-Octave%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><p>首先，也是很重要的一点，就是使用Octave进行图形绘制，包括各种函数图像、统计图等。</p><h2 id="绘制函数图像"><a href="#绘制函数图像" class="headerlink" title="绘制函数图像"></a>绘制函数图像</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>从一个比较基础的栗子看起。我们现在要画出如下多项式函数的图形：</p><p>$f(x) = 3x^4+2x^3+7x^2+2x+9$</p><p>我们的Octave代码如下</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">x &#x3D; [-10: 0.01: 10];y &#x3D; 3*x.^4 + 2*x.^3 + 7*x.^2 + 2*x + 9plot(x, y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>给x赋值为分量均匀的向量，其实是指定函数定义域；给出y用x表达的式子，其实是给出函数的对应关系（注意x是向量，运算符不要弄错了）；plot()接收自变量和函数值，绘制相应的函数曲线。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>绘制图形之后，还可以在图形上添加标题、标签、网格线和缩放等，通常使用如下命令：</p><ul><li>xlabel、ylabel，产生沿着x轴、y轴的标签</li><li>title，放置标题</li><li>grid on 允许添加网格线</li></ul><p>给图像设置颜色，可以将表示颜色的字符作为参数传入plot()：<code>plot(x, y, &#39;r&#39;)</code>，设置了红色线条。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>使用<code>subplot(m, n, p)</code>命令设置每一个子图的特征，其中m、n分别表示绘图数组的行数、列数，而p指定放置特定绘图的位置（<strong>默认地，子图从左至右、从上至下依次记为1、2…</strong>）。</p><h2 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h2><p>同样地，设置定义域（x轴变量）、每一个x轴的项的值（y轴变量），调用bar(x, y)命令即可绘制条形图。</p><pre class="line-numbers language-octave" data-language="octave"><code class="language-octave">x &#x3D; [1:10];y &#x3D; [75, 58, 90, 87, 50, 85, 92, 75, 60, 95];bar(x,y), xlabel(&#39;Student&#39;),ylabel(&#39;Score&#39;),title(&#39;First Sem:&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样地，也可以设置横轴信息、纵轴信息、标题等。</p><h1 id="代数与方程"><a href="#代数与方程" class="headerlink" title="代数与方程"></a>代数与方程</h1><h2 id="求解基本代数方程"><a href="#求解基本代数方程" class="headerlink" title="求解基本代数方程"></a>求解基本代数方程</h2><p><code>roots()</code>函数用于求解多项式代数方程，并返回代数方程的值。比如我们要求解方程$x - 5 = 0$，可以按照如下方式调用函数：</p><pre class="line-numbers language-octave" data-language="octave"><code class="language-octave">y &#x3D; roots([1, -5])% roots()求解方程的结果将赋值给y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再比如求解方程$x^3 + 2x^2-5x+9=0$：</p><pre class="line-numbers language-Octave" data-language="Octave"><code class="language-Octave">roots([1, 2, -5, 9])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当一个方程有多个解时，将以列向量方式返回结果。</p><h2 id="求解代数方程组"><a href="#求解代数方程组" class="headerlink" title="求解代数方程组"></a>求解代数方程组</h2><p>对于多元一次方程组，由学过的代数知识，它总可以表示成矩阵形式：</p><p>Ax = b，其中A是系数矩阵，b是包含线性方程右侧的列向量，x是解的列向量。我们先创建出A、b的矩阵（或者向量），然后使用A\b即可得到解的列向量。</p><h2 id="求解极限"><a href="#求解极限" class="headerlink" title="求解极限"></a>求解极限</h2><p>这里需要使用symbols符号包。</p>]]></content>
      
      
      <categories>
          
          <category> 高级程序设计语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU Octave学习之基本语法</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/29/GNU-Octave%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/29/GNU-Octave%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Octave简介"><a href="#Octave简介" class="headerlink" title="Octave简介"></a>Octave简介</h2><p>Octave是一门类似Matlab的轻量级高级程序语言，在数值计算、统计作图等领域也有着很强大的功能。鉴于某些不可忽视的客观因素，选择学习Octave作为数学建模的语言工具。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p>既然是用于数学领域的强大工具，首先就来了解了解这门语言对各种运算的支持。事实上，除了对数学中各种基本算术运算的支持（加减乘除，乘方，开方等），它还支持矩阵、数组运算。</p><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+、-、*</td><td>与数学中的运算无异，用于标量、矩阵</td></tr><tr><td>/</td><td>右除运算符，与数学中的除法运算无异，相当于“除以”</td></tr><tr><td>\</td><td>左除运算符，相当于“除”</td></tr><tr><td>^</td><td>标量、矩阵的求幂运算符</td></tr><tr><td>‘</td><td>矩阵转置</td></tr><tr><td>.*  ./  .\  .^  .’</td><td>用于数组的乘法、右除、左除、求幂、转置</td></tr><tr><td>;</td><td>分号，用于抑制显示（加上分号后的行不会显示结果到终端）</td></tr><tr><td>[]</td><td>数组声明</td></tr><tr><td>%</td><td>注释</td></tr></tbody></table></div><p>同时，还有一些特殊的变量、常量：</p><ul><li>ans，表示最近的计算结果</li><li>pi，表示π</li><li>NaN，非数字结果</li><li>Inf，表示无穷大</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>在Octave中，每一个变量都是一个数组或者矩阵。</strong></p><p>平凡地，对于形如<code>x = 3</code>之类的变量，它是一个1×1大小的矩阵。</p><p>变量的声明与使用与其他高级程序语言类似，此处不予赘述。</p><p>值得注意的是，可以使用who命令，显示已经使用过的所有变量名；whos命令将显示所有变量的更多信息。</p><h4 id="格式化命令"><a href="#格式化命令" class="headerlink" title="格式化命令"></a>格式化命令</h4><p>format命令用于提高浮点数精度。比如，</p><ul><li>format long命令在小数点后显示16位数字；</li><li>format short命令显示3位数字；</li><li>format bank命令将数字四舍五入到小数点后两位</li><li>format rat命令给出最接近计算结果的有理式。</li></ul><h4 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a>创建向量</h4><ul><li><p>行向量</p><p>将元素集括在方括号中，使用空格或者逗号作为定界符。实际上，类似数组写法。</p><p><code>n = [1, 2, 3, 4, 5]</code>创建五维行向量。</p></li><li><p>列向量</p><p>将元素集括在方括号中，使用分号作为定界符。</p><p><code>n = [1; 2; 3; 4; 5]</code>创建五维列向量。</p></li></ul><h4 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h4><p>将元素集括在方括号中，使用空格或者逗号作为行内元素之间的定界符，使用分号作为行与行之间的定界符：</p><p><code>m = [1 2 3; 4 5 6; 7 8 9]</code></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>这里记录的命令将用于管理会话框。</p><ul><li>clc，清除命令窗口</li><li>clear，从内存中删除变量</li><li>who/whos，列出当前所有存在的变量（详情）</li><li><strong>disp，显示数组或者字符串内容</strong></li><li>format，用于控制输出的数值格式</li><li>input，显示提示并且等待输入</li></ul><p>还有对向量、矩阵的命令，类似其他语言中相应数据结构的方法。</p><ul><li>cat，连接数组</li><li>find，查找非零元素的索引</li><li>max/min，返回最大元素/最小元素</li><li>sort，对每一列进行排序</li><li>eye，创建一个单位矩阵</li><li>rank，计算矩阵的秩</li><li>cross，计算矩阵叉积</li><li>dot，计算矩阵点积</li><li>inv，计算矩阵的逆</li></ul><p>此外还有一些绘图命令，如axis、plot、grid等。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>一共有15种数据类型，不过常用的就那些：int8、double、logical（类似布尔）、structure（类似结构体）、char。</p><p>既然存在数据类型，就还有数据类型转换、数据类型的识别。</p><ul><li>char</li><li>int2str</li><li>…</li><li>ischar</li><li>isfloat</li><li>isinteger</li><li>isvector</li></ul><p>以上的函数都接收参数使用。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>octave提供的运算符与其他高级语言基本一致，包括算术运算符、逻辑运算符、关系运算符、按位运算符；当然也有很多独有的运算符，如</p><p>集合运算符：</p><ul><li>inersect(A, B) 返回A和B的交集，A、B均为数组</li><li>setdiff(A, B) 返回A-B</li><li>union(A, B) 返回A和B的并集</li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵其实就是二维数组。它的创建已经提过了；下面重点记录一下矩阵元素的引用。</p><h4 id="矩阵元素的引用"><a href="#矩阵元素的引用" class="headerlink" title="矩阵元素的引用"></a>矩阵元素的引用</h4><ul><li><p>单个元素的引用</p><p><code>matrix(m, n)</code>引用矩阵matrix第m行、第n列的元素。</p></li><li><p>多个元素的引用</p><p><code>matrix(:, n)</code>引用矩阵matrix第n列的全部元素。</p><p><code>matrix(:, m:n)</code>引用矩阵第m列到第n列的全部元素。</p></li></ul><h4 id="删除矩阵中的行、列"><a href="#删除矩阵中的行、列" class="headerlink" title="删除矩阵中的行、列"></a>删除矩阵中的行、列</h4><p>为矩阵中的行、列分配一组空的方括号，这样可以删除矩阵的整个行或者列。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">:</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment">% 删除矩阵a第四行的全部元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>之前已经介绍过数组，这里再稍微详细地记录一下。数组在数学上表现为矩阵，一维数组就如同向量（1×n），二维数组就如同矩阵（m×n）。</p><h4 id="特殊数组"><a href="#特殊数组" class="headerlink" title="特殊数组"></a>特殊数组</h4><p>特殊的矩阵当然需要生成API，常用的如下：</p><ul><li>zeros(n), 生成n阶方阵</li><li>ones(n), 生成n阶全1方阵</li><li>eye(n), 生成n阶单位矩阵</li><li>rand(m, n), 生成m×n的随机数矩阵</li></ul><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><p>向已知的数组添加维度：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span> <span class="token operator">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token comment">% 表示为二维数组a添加第3维度的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>需要注意的是，与其他高级语言不同，Octave中数组下标通常从1开始，表示向量/矩阵的第一个分量。从数学角度来看，这似乎更加符合常理（通常不称第0个分量）。</strong></p><p>数组函数类似其他高级语言中对数组的各种处理方法，比如数组排序、变形、判空等。</p><h4 id="单元数组"><a href="#单元数组" class="headerlink" title="单元数组"></a>单元数组</h4><p>单元格数组是索引单元格的数组，每一个单元格都可以存储不同维度和数据类型的数组。</p><p><code>C = cell(dim1, ..., dimN)</code></p><p><code>C = cell(obj)</code></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">c <span class="token operator">=</span> <span class="token function">cell</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'R'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'Y'</span><span class="token punctuation">,</span> <span class="token string">'W'</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对单元数组的元素的访问与矩阵元素的引用几乎一致。</p><h4 id="冒号表示法"><a href="#冒号表示法" class="headerlink" title="冒号表示法"></a>冒号表示法</h4><p>冒号:，是Octave中最有用的运算符之一，常用于</p><ul><li><p>创建向量</p><p><code>begin: step: end</code>可以创建出以begin为首项、end为末项、step为步长（公差）的均匀元素组成的向量。step默认为1。</p></li><li><p>下标数组</p></li><li><p>指定迭代</p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>就像其他高级语言一样，Octave也支持函数，它是完成某一功能代码的集合体。而在Octave中，函数是在单独的文件中定义的，文件名和函数名应该相同。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token keyword">function</span> <span class="token punctuation">[</span>out1<span class="token punctuation">,</span> out2<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">funcName</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span class="token comment">% out1, out2, ...是函数的输出参数</span><span class="token comment">% n1, n2, ...是函数的输入参数</span><span class="token comment">% funcName是函数名</span><span class="token comment">% 函数以end作为结束符</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Octave中，任何一个函数文件都包含一个首先出现的必需主函数，除此之外，还可以在主函数之后定义任意数量的可选子函数，这些子函数可以互相调用。可以类比为C++中的main函数和其他自定义函数的关系。</p><p>另外，<strong>Octave支持函数的嵌套定义，即允许在一个函数体内部定义另一个函数。</strong></p><p>如果某一个变量需要被全局共享（类似C++中的全局变量），需要在所有函数中将变量声明为全局变量——在变量名前面加上global关键字。</p><p>起源上看，西方的民主来源于古希腊时期的城邦政治，但是是把妇女等排除在外的，并不是真正的民主；中国古代体现出的思想则更加民主，比如“孟子“民贵君轻”思想，在一定程度上体现了民主思想；</p><p>另外，就制度而言，中国的民主是社会主义民主，是人人当家做主的民主，是保证了人民的权利，比如我们的人民代表大会制度；而西方是资本主义的民主，是一种更加形式上的民主，资本家们当然享有民主，但是穷人就不一样了。</p>]]></content>
      
      
      <categories>
          
          <category> 高级程序设计语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码阅读之属性、条件渲染与列表渲染</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/28/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%B1%9E%E6%80%A7%E3%80%81%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/28/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%B1%9E%E6%80%A7%E3%80%81%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p>之前的代码解读中，为了简化代码，同时更加抓住主要内容——VNode，我们忽略了属性、条件渲染（v-if）、列表渲染（v-for）等。对属性的处理，其实在之前的笔记中有所提及；下面首先简单记录一下条件渲染。</p><h2 id="带着条件渲染看Vue渲染全过程"><a href="#带着条件渲染看Vue渲染全过程" class="headerlink" title="带着条件渲染看Vue渲染全过程"></a>带着条件渲染看Vue渲染全过程</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>Item 0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a > 0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b > 0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>Item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>Item 4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/raphealguo/how-to-learn-vue2-blob/raw/master/figure/2.2.1/ifelse.png">https://github.com/raphealguo/how-to-learn-vue2-blob/raw/master/figure/2.2.1/ifelse.png</a></p><h2 id="从parse-template-看带条件渲染的AST树的生成"><a href="#从parse-template-看带条件渲染的AST树的生成" class="headerlink" title="从parse(template)看带条件渲染的AST树的生成"></a>从parse(template)看带条件渲染的AST树的生成</h2><p><strong>在AST树中， if 、else-if 、else的多个token节点会合成一个节点</strong>——if节点里边包含 </p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>exp<span class="token operator">:</span>'if判断条件'<span class="token punctuation">,</span> block<span class="token operator">:</span>&lt;if的ast节点><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>exp<span class="token operator">:</span>'else-if判断条件'<span class="token punctuation">,</span> block<span class="token operator">:</span>&lt;else-if的ast节点><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>，<span class="token punctuation">&#123;</span>exp<span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>block<span class="token operator">:</span>&lt;else的ast节点><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在parse(template)函数中，有一个processIf(element)函数：</p><p><code>processIf(element)</code>，它用于处理element上的v-if指令（包含在属性键值对中，有待分离）；该函数体内部的getAndRemoveAttr()用于获取并移除指定的属性键值对。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function processIf (el) &#123;  &#x2F;**exp接收移除的v-if后面的值 *&#x2F;  const exp &#x3D; getAndRemoveAttr(el, &#39;v-if&#39;)  if (exp) &#123;    el.if &#x3D; exp    &#x2F;&#x2F; 为当前节点添加if条件    addIfCondition(el, &#123;      exp: exp,      block: el    &#125;)  &#125; else &#123;    &#x2F;&#x2F; 表示exp为空，处理v-else    if (getAndRemoveAttr(el, &#39;v-else&#39;) !&#x3D; null) &#123;      el.else &#x3D; true    &#125;    &#x2F;&#x2F; 继续处理v-else-if    const elseif &#x3D; getAndRemoveAttr(el, &#39;v-else-if&#39;)    if (elseif) &#123;      el.elseif &#x3D; elseif    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到，<strong>上述处理v-if条件渲染的代码中，还有一个addIfCondition()函数</strong>，它主要用于给element（即要生成的AST节点）添加ifConditions属性：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">ifAstElm.ifConditions &#x3D; [  &#123;exp: &#39;a &gt; 0&#39;, block: item1AstEl &#125;,  &#123;exp: &#39;b &gt; 0&#39;, block: item2AstEl &#125;,  &#123;exp: null,    block: item3AstEl &#125;,]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也再次印证，AST树中将多个v-if、v-else、v-else-if节点整合在了一起。</p><h2 id="生成VNode-render时对ifASTElement的处理"><a href="#生成VNode-render时对ifASTElement的处理" class="headerlink" title="生成VNode render时对ifASTElement的处理"></a>生成VNode render时对ifASTElement的处理</h2><p>ifAstElm中的条件控制语句会变成连续的三元运算操作，运算结果产生一个VNode——v-if、v-else-if、v-else结构只会产生一个VNode。</p><p>我们知道，生成AST结构的下一步，是生成VNode-render（渲染VNode树的代码），因此我们把目光转移到compiler/codegen/index.js中，在生成VNode-render的次外层函数genElement(el)中，就有对ifAstElm的处理——genIf(el)：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function genIf(el) &#123;  el.ifProcessed &#x3D; true &#x2F;&#x2F; 标记已经处理过当前这个if节点了，避免递归死循环    &#x2F;&#x2F; 将el.ifConditions的浅拷贝传递给函数  return genIfConditions(el.ifConditions.slice())&#125;function genIfConditions(conditions) &#123;  if (!conditions.length) &#123;    return &#39;_e()&#39;  &#125;  const condition &#x3D; conditions.shift() &#x2F;&#x2F; 因为我们并没有去真正删除 el.ifConditions 队列的元素，所以需要有el.ifProcessed &#x3D; true来结束递归  if (condition.exp) &#123;    return &#96;($&#123;condition.exp&#125;)?$&#123;genTernaryExp(condition.block)&#125;:$&#123;genIfConditions(conditions)&#125;&#96;  &#125; else &#123;    return &#96;$&#123;genTernaryExp(condition.block)&#125;&#96;  &#125;  function genTernaryExp(el) &#123;    return genElement(el)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码段中，我们看到生成VNode-render的三元表达式：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">if (condition.exp) &#123;    return &#96;($&#123;condition.exp&#125;)?$&#123;genTernaryExp(condition.block)&#125;:$&#123;genIfConditions(conditions)&#125;&#96;  &#125; else &#123;    return &#96;$&#123;genTernaryExp(condition.block)&#125;&#96;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个分支，condition.exp是分支条件，condition.block是分支对应的AST节点（准确来说，condition对象来自前一步生成的AST树节点），采取递归方式，可以得到一个嵌套的三元表达式结构：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">_c(&#39;div&#39;, &#123;&#125;, [ &#x2F;* 留意children数组只有3个元素 *&#x2F;  _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 0&quot;) ]),  &#x2F;* 下边这个表达式只会产生一个 VNode 节点 *&#x2F;  (a &gt; 0) ?  &#x2F;&#x2F; if    _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 1&quot;) ]) :  (b &gt; 0) ?  &#x2F;&#x2F; elseif    _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 2&quot;) ]) :         &#x2F;&#x2F; else    _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 3&quot;) ]),  &#x2F;* 上边这个表达式只会产生一个 VNode 节点 *&#x2F;  _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 4&quot;) ])])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个分支，表示当前condition.exp为null，即无条件了，对应v-else，为v-if系列中的最后一个分支。</p><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>上面已经得到了带有v-if的VNode-render表达式，后续就需要保证其运行正确，即可生成VNode树了。由VNode树到真实DOM树的过程与v-if无关了。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 得到的VNode render代码示例：（renderCode）var render &#x3D; function () &#123;    with (this) &#123;        _c(&#39;div&#39;, &#123;&#125;, [          _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 0&quot;) ]),          (a &gt; 0) ?  &#x2F;&#x2F; if            _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 1&quot;) ]) :          (b &gt; 0) ?  &#x2F;&#x2F; elseif            _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 2&quot;) ]) :                 &#x2F;&#x2F; else            _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 3&quot;) ]),          _c(&#39;div&#39;, &#123;&#125;, [ _v(&quot;Item 4&quot;) ])        ])    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="流程总览"><a href="#流程总览" class="headerlink" title="流程总览"></a>流程总览</h2><p>以如下代码为例，简单看看整体流程示意图：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(item, index) in items<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; item &#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/raphealguo/how-to-learn-vue2-blob/raw/master/figure/2.2.2/for.png">https://github.com/raphealguo/how-to-learn-vue2-blob/raw/master/figure/2.2.2/for.png</a></p><h2 id="HTML到AST的列表渲染处理"><a href="#HTML到AST的列表渲染处理" class="headerlink" title="HTML到AST的列表渲染处理"></a>HTML到AST的列表渲染处理</h2><p>在生成AST节点时，需要提取出HTML模板中的v-for属性值。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function processFor (el) &#123;  let exp  if ((exp &#x3D; getAndRemoveAttr(el, &#39;v-for&#39;))) &#123;    &#x2F;&#x2F; 此时，exp已经保存到了v-for的值，下面需要提取出指定的内容    const inMatch &#x3D; exp.match(forAliasRE)    &#x2F;&#x2F; v-for&#x3D;&quot;item in list&quot;             &#x3D;&gt;     [&quot;item in list&quot;, &quot;item&quot;, &quot;list&quot;]    &#x2F;&#x2F; v-for&#x3D;&quot;(item, index) in list&quot;    &#x3D;&gt;     [&quot;(item, index) in list&quot;, &quot;(item, index)&quot;, &quot;list&quot;]    &#x2F;&#x2F; v-for&#x3D;&quot;(value, key, index) in object&quot;    &#x3D;&gt;     [&quot;(value, key, index) in object&quot;, &quot;(value, key, index)&quot;, &quot;object&quot;]    if (!inMatch) &#123; &#x2F;&#x2F; v-for语法有错误的时候，提示编译错误      warn(        &#96;Invalid v-for expression: $&#123;exp&#125;&#96;      )      return    &#125;    &#x2F;&#x2F; 注意，string.trim()将会从字符串两端删除空白字符    &#x2F;**el.for：string，保存的是v-for命令值中，in后面的内容（可迭代对象） *&#x2F;    el.for &#x3D; inMatch[2].trim()    const alias &#x3D; inMatch[1].trim()    const iteratorMatch &#x3D; alias.match(forIteratorRE)    if (iteratorMatch) &#123; &#x2F;&#x2F; v-for&#x3D;&quot;(item, index) in list&quot;  或者 &#x2F;&#x2F; v-for&#x3D;&quot;(value, key, index) in object&quot;      el.alias &#x3D; iteratorMatch[1].trim()      el.iterator1 &#x3D; iteratorMatch[2].trim()      if (iteratorMatch[3]) &#123;        el.iterator2 &#x3D; iteratorMatch[3].trim()      &#125;    &#125; else &#123;      el.alias &#x3D; alias &#x2F;&#x2F; alias &#x3D; &quot;item&quot;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看懂这段代码的关键之一是明白JavaScript的正则表达式。比如，forAliasRE、forIteratorRE都是匹配模式串。以上面的html模板字符串为例，inMatch、iteratorMatch的内容如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// inMatch: Array</span><span class="token punctuation">[</span>  '(item<span class="token punctuation">,</span> index) in list'<span class="token punctuation">,</span>  '(item<span class="token punctuation">,</span> index)'<span class="token punctuation">,</span>  'list'<span class="token punctuation">,</span>  index<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  input<span class="token operator">:</span> '(item<span class="token punctuation">,</span> index) in list'<span class="token punctuation">,</span>  groups<span class="token operator">:</span> undefined<span class="token punctuation">]</span><span class="token comment">// iteratorMatch: Array</span><span class="token punctuation">[</span>  '(item<span class="token punctuation">,</span> index)'<span class="token punctuation">,</span>  'item'<span class="token punctuation">,</span>  ' index'<span class="token punctuation">,</span>  undefined<span class="token punctuation">,</span>  index<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  input<span class="token operator">:</span> '(item<span class="token punctuation">,</span> index)'<span class="token punctuation">,</span>  groups<span class="token operator">:</span> undefined<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此，我们给出创建出来的AST节点el信息：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; v-for&#x3D;&quot;(item, index) in list&quot;el.for &#x3D; &#39;list&#39;&#x2F;&#x2F; inMatch[2]const alias &#x3D; &#39;(item, index)&#39;&#x2F;&#x2F; inMatch[1]el.alias &#x3D; &#39;item&#39;&#x2F;&#x2F; iterator[1]el.iterator1 &#x3D; &#39;index&#39;&#x2F;&#x2F; iterator[2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>alias，别名，此处用以表示在v-for循环中给可迭代对象的当前遍历项，即它的别名。</p></blockquote><h2 id="从AST到Vnode-render"><a href="#从AST到Vnode-render" class="headerlink" title="从AST到Vnode render"></a>从AST到Vnode render</h2><p>在次外层函数genElement()中，genFor()用以生成列表渲染部分的renderCode：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function genFor(el) &#123;  const exp &#x3D; el.for  const alias &#x3D; el.alias  const iterator1 &#x3D; el.iterator1 ? &#96;,$&#123;el.iterator1&#125;&#96; : &#39;&#39;  const iterator2 &#x3D; el.iterator2 ? &#96;,$&#123;el.iterator2&#125;&#96; : &#39;&#39;  if (!el.key) &#123; &#x2F;&#x2F; v-for 最好声明key属性    warn(      &#96;&lt;$&#123;el.tag&#125; v-for&#x3D;&quot;$&#123;alias&#125; in $&#123;exp&#125;&quot;&gt;: component lists rendered with &#96; +      &#96;v-for should have explicit keys. &#96; +      &#96;See https:&#x2F;&#x2F;vuejs.org&#x2F;guide&#x2F;list.html#key for more info.&#96;,      true &#x2F;* tip *&#x2F;    )  &#125;  &#x2F;&#x2F; v-for&#x3D;&quot;(item, index) in list&quot;  &#x2F;&#x2F; alias &#x3D; item, iterator1 &#x3D; index  &#x2F;&#x2F; v-for&#x3D;&quot;(value, key, index) in object&quot;  &#x2F;&#x2F; alias &#x3D; value, iterator1 &#x3D; key, iterator2 &#x3D; index  &#x2F;&#x2F; _l(val, render)  &#x2F;&#x2F; val &#x3D; list  &#x2F;&#x2F; render &#x3D; function (alias, iterator1, iterator2) &#123; return genElement(el) &#125;  el.forProcessed &#x3D; true &#x2F;&#x2F; avoid recursion  return &#96;_l(($&#123;exp&#125;),&#96; +    &#96;function($&#123;alias&#125;$&#123;iterator1&#125;$&#123;iterator2&#125;)&#123;&#96; +    &#96;return $&#123;genElement(el)&#125;&#96; +    &#39;&#125;)&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的renderCode即为：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">_l((items),function(item, index)&#123;    return _c(&#39;li&#39;, &#123;&#125;, [_v,( _s(item) )])&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="运行时的renderHelpersFunc中的渲染列表函数-l"><a href="#运行时的renderHelpersFunc中的渲染列表函数-l" class="headerlink" title="运行时的renderHelpersFunc中的渲染列表函数_l()"></a>运行时的renderHelpersFunc中的渲染列表函数_l()</h2><p>上面已经得到了带有列表渲染的renderCode，接下来就需要分析renderCode中的渲染函数_l()了——它是渲染出一个完整VNode列表的关键。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; core&#x2F;instance&#x2F;render-helpers&#x2F;render-list.jsexport function renderList (val, render) &#123;  let ret, i, l, keys, key  if (Array.isArray(val) || typeof val &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;    ret &#x3D; new Array(val.length)    for (i &#x3D; 0, l &#x3D; val.length; i &lt; l; i++) &#123;      ret[i] &#x3D; render(val[i], i)    &#125;  &#125; else if (typeof val &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123; &#x2F;&#x2F; 支持 v-for&#x3D;&quot;n in 10&quot;    ret &#x3D; new Array(val)    for (i &#x3D; 0; i &lt; val; i++) &#123;      ret[i] &#x3D; render(i + 1, i)    &#125;  &#125; else if (isObject(val)) &#123;    keys &#x3D; Object.keys(val)    ret &#x3D; new Array(keys.length)    for (i &#x3D; 0, l &#x3D; keys.length; i &lt; l; i++) &#123;      key &#x3D; keys[i]      ret[i] &#x3D; render(val[key], key, i)    &#125;  &#125;  return ret&#125;&#x2F;&#x2F; core&#x2F;instance&#x2F;render.jsVue.prototype._l &#x3D; renderList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先看看最熟悉的renderCode情况：items是一个可迭代数组，那么函数内部将会创建一个ret数组，ret数组中的每一个元素都是可迭代数组中对应元素被渲染后的结果（单个VNode节点）：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">_l((items),function(item, index)&#123;    return _c(&#39;li&#39;, &#123;&#125;, [_v,( _s(item) )])&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>items就是renderList(val, render)函数的第一个参数；</li><li>function(item, index){…}是第二个参数render，注意它返回_c(…)的结果，而_c()用于创建VNode并返回之，因此此时的render返回值为单个VNode。</li></ul><p>另外，除了可迭代数组，数字、字符串和对象均可以作为v-for的迭代对象。这里说明一下对象作为迭代对象时，首先取出对象的所有键组成的数组keys，建立与之对应的ret[]，ret数组中的每一个元素都是keys中每一个键、对应的值的渲染（render）结果。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法训练之动态规划</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/28/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/28/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>是一种依赖子问题、希望通过求解子问题得到原问题的解的思维方法。</p><p>但是，并不是所有的问题分解成子问题之后，都可以取出每一个子问题的最优解，从而得到原问题的全局最优解的。那些分解成子问题后、通过求解每一个子问题的最优解、从而可以正确得到全局最优解的问题具有的这一特点，叫做优化子结构。</p><p>我们介绍一些栗子，顺便记录一下做动态规划题的心得。</p>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计课后习题</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="合并数字的最大代价"><a href="#合并数字的最大代价" class="headerlink" title="合并数字的最大代价"></a>合并数字的最大代价</h2><script type="math/tex; mode=display">\begin{flalign}&MAXMERGE():\\&for\ i=1 \ to \ n-1\\&\qquad C[i, i]  = 0\\&for\ i=1 \ to \ n\\&\qquad for\ j=i+1 \ to \ n\\&\qquad \qquad C[j, j+i] = -\infty \\&\qquad \qquad for\ r=j \ to \ j+i-1\\&\qquad \qquad \qquad t = C[j, r]+C[r+1,j+i]+\Sigma_{k=j}^{j+i}k\\&\qquad \qquad \qquad if\ t>C[j, j+i]\\&\qquad \qquad \qquad \quad C[j, j+i]=t\end{flalign}</script><h2 id="最长增长子序列问题"><a href="#最长增长子序列问题" class="headerlink" title="最长增长子序列问题"></a>最长增长子序列问题</h2><script type="math/tex; mode=display">\begin{flalign}&MaxLengthSub():\\&n = S.length\\&for\ i=1\ to \ n\\&\qquad dp[i]=1\\&for\ i=1\ to \ n\\&\qquad pre[i]=\infty \\&\qquad for \ k=1 \ to \ i\\&\qquad \qquad if\ a_k<a_i\ \&\& \ dp[i]<=dp[k]+1 \\&\qquad \qquad \qquad dp[i]=dp[k]+1\\&\qquad \qquad \qquad pre[i]=k\\&\qquad \qquad \qquad if\ pre[i]>k   \\&\qquad \qquad \qquad \qquad pre[i]=k \\&maxLength = -\infty, lastIndex=0\\&for\ i=1 \ to\ n\\&\qquad if\ maxLength<dp[i]\\&\qquad \qquad maxLength=dp[i], lastIndex=i\\& k=lastIndex\\&while\ pre[k]\\&\qquad path.unshift(pre[a_k])\\&Print(path)\end{flalign}</script>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库逻辑设计之函数依赖</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p><strong>以下均默认R为具有属性集合U的一个关系模式。</strong></p><h2 id="关系的码与键"><a href="#关系的码与键" class="headerlink" title="关系的码与键"></a>关系的码与键</h2><p>这一部分概念很杂，稍有不慎容易混淆，特此记录。</p><ul><li><p>超码：$K\subseteq U, 若K \to U, 则称K是R的一个超码——超码可以唯一地识别关系的元组。$</p></li><li><p>候选码：$已知K是R的一个超码, 且不存在K的真子集Z, 使得Z \to U, 我们称K是R的一个候选码。$</p><p>如此看来，同一个关系模式下，候选码可能有多个。</p></li><li><p>主码：在同一个关系模式下的诸多候选码中，指定其中的一个，它就是识别关系的元组的主码（取代表）。</p></li><li><p>键属性：包含在<strong>任意候选码</strong>中的属性，称为键属性。</p></li><li><p>非键属性：与键属性相对，不包含在任意候选码中的属性，称为非键属性。</p><p>最简单的情况下，候选码只包含一个属性；</p><p>最复杂的情况下，候选码包含全部属性。</p></li></ul><p>举出一个小栗子：</p><p>下面是某一个政务系统管理数据表。</p><div class="table-container"><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th><th>性别</th><th>户籍号</th><th>部门</th></tr></thead><tbody><tr><td>01</td><td>小明</td><td>32</td><td>男</td><td>011</td><td>内阁</td></tr><tr><td>02</td><td>小红</td><td>24</td><td>女</td><td>022</td><td>工部</td></tr><tr><td>03</td><td>小勇</td><td>33</td><td>男</td><td>021</td><td>吏部</td></tr><tr><td>04</td><td>小南</td><td>32</td><td>女</td><td>092</td><td>礼部</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ul><li>对于超码，注意到超码是属性的<strong>集合</strong>，因此对超码的选取很任意：{学号，姓名}，{学号，姓名，年龄}…它们都是。</li><li>对于候选码，首先它的实质是属性的<strong>集合</strong>；其次它比较有“临界”意义，因为它可以说是唯一识别关系的元组的<strong>最小阶数</strong>的属性集合，比如上表中，“编号”“户籍号”都可以唯一地识别一个元组，它们都是候选码。</li><li>包含在所有的候选码之中的属性，即“编号”“户籍号”，它们都是键属性，其他的都是非键属性。</li></ul><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><script type="math/tex; mode=display">\begin{flalign}&设关系模式R，U为R的所有属性集合, P为模式下所有元组组成的集合,X、Y也为属性集合, 且X\subseteq U, Y\subseteq U;\\&若\forall s, t \in P, s[X]=t[X], 有s[Y]=t[Y], 那么我们就称Y函数依赖于X, 或者X函数地确定Y, 即X\to Y.\end{flalign}</script><p>一般来说，X是某种具有“唯一”语义性的属性（集），此时任何属性集都是函数依赖于X的。比如，X=“身份证号”（当然这里集合X仅有一个元素，就直接简化了），对于一个实体——公民的关系模式，几乎可以函数地确定其他所有属性了。</p><p>再比如，我们考虑“姓名”$\to$“年龄”这样一个待确定的函数依赖，发现对于同名的两个公民，他们的年龄很有可能不同（事实上这种情况很常见），因此这个函数依赖不成立。</p><script type="math/tex; mode=display">\begin{flalign}&如果X\to Y, 并且Y\nsubseteq X, 我们就称这种依赖是非平凡函数依赖。\\&否则，若Y\subseteq X,我们就称这种函数依赖是平凡函数依赖。\end{flalign}</script><p>很显然，非平凡函数依赖更值得我们研究：平凡函数依赖是很显然的，它是一种父集合到子集合的函数依赖。</p><p>还需要介绍几个概念：</p><ul><li><p>完全函数依赖</p></li><li><p>传递地函数依赖</p><script type="math/tex; mode=display">\begin{flalign}&设X\subseteq U, Y\subseteq U, Z\subseteq U, Y\to X不成立, 且Z-X, Z-Y与Y-X不空;\\&如果X \to Y, Y\to Z, 则称Z传递地函数依赖于X.\end{flalign}</script><p>要注意传递地函数依赖满足的条件。集合之差不空，也就是说集合之间没有父子包含关系（否则就成了平凡函数依赖）。</p></li></ul><h2 id="快速求候选码"><a href="#快速求候选码" class="headerlink" title="快速求候选码"></a>快速求候选码</h2><p>我们给出如下有用的定理，在此之前，我们约定R为给定的关系模式，F是其函数依赖集。</p><ul><li><strong>定理1</strong> 对于R、F，若X是L类属性，那么X必为R的任一候选键的成员。</li><li><strong>定理2</strong> 如果X是R类属性，那么X不在任何候选键中。</li><li><strong>定理3</strong> 如果X是R的N类属性，那么X必包含在R的任一候选键中。</li><li>推论：如果X是R的N类和L类组成的属性集，且$X_F^+$包含了R的全部属性，那么X是R的唯一候选键。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/26/hello-world/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 帮助文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 帮助 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念结构设计</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/26/%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/26/%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="实体联系模型"><a href="#实体联系模型" class="headerlink" title="实体联系模型"></a>实体联系模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>实体：ER模型的基本对象，可以是物理存在的事物，也可以是抽象的概念。<ul><li>实体集：相同类型的实体集合</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的正则表达式</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/24/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/24/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是一个很强大的工具，在Python中被广泛使用，一般我在Python中也用的多一点，最近在JavaScript编程中也经常遇见，这里做一下简单的记录。</p><h3 id="JavaScript正则表达式简介"><a href="#JavaScript正则表达式简介" class="headerlink" title="JavaScript正则表达式简介"></a>JavaScript正则表达式简介</h3><p>与Python中的正则表达式类似，JavaScript的正则表达式中，关键有两部分</p><ul><li>匹配模式串<ul><li>元字符</li><li>匹配标志</li></ul></li><li>匹配方法（正则方法）</li></ul><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>匹配模式串的核心部分。</p><div class="table-container"><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>查找单个字符，除了换行和行结束符</td></tr><tr><td>\w</td><td>查找单词字符</td></tr><tr><td>\W</td><td>查找非单词字符</td></tr><tr><td>\d</td><td>查找数字</td></tr><tr><td>\D</td><td>查找非数字字符</td></tr><tr><td>\s</td><td>查找空白字符</td></tr><tr><td>\S</td><td>查找非空白字符</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr><tr><td>\0</td><td>查找 NUL字符</td></tr><tr><td>\n</td><td>查找换行符</td></tr><tr><td>\f</td><td>查找换页符</td></tr><tr><td>\r</td><td>查找回车符</td></tr><tr><td>\t</td><td>查找制表符</td></tr><tr><td>\v</td><td>查找垂直制表符</td></tr><tr><td>\xxx</td><td>查找以八进制数 xxxx 规定的字符</td></tr><tr><td>\xdd</td><td>查找以十六进制数 dd 规定的字符</td></tr><tr><td>\uxxxx</td><td>查找以十六进制 xxxx规定的 Unicode 字符</td></tr></tbody></table></div><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><div class="table-container"><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>指定了重复匹配字符的确数或者约数。下面展示一些量词搭配元字符的使用：</p><div class="table-container"><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个 n 的字符串</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个 n 的字符串</td></tr><tr><td>n?</td><td>匹配任何包含零个或一个 n 的字符串</td></tr><tr><td>n{x}</td><td>匹配包含 x 个 n 的序列的字符串</td></tr><tr><td>n{x,y}</td><td>匹配包含最少 x 个、最多 y 个 n 的序列的字符串</td></tr><tr><td>n{x,}</td><td>匹配包含至少 x 个 n 的序列的字符串</td></tr></tbody></table></div><p>n可以是前面的元字符。</p><h4 id="匹配标志"><a href="#匹配标志" class="headerlink" title="匹配标志"></a>匹配标志</h4><p>在默认情况下，正则的匹配最多只会匹配到一个结果。但是可以在正则匹配模式串后面添加标记：</p><ul><li>/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。</li><li>/i 表示匹配的时候不区分大小写。</li><li>/m 表示多行匹配——匹配换行符两端的潜在匹配。影响正则中的^$符号。</li></ul><h4 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h4><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a></td><td style="text-align:left">一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a></td><td style="text-align:left">一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a></td><td style="text-align:left">一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a></td><td style="text-align:left">一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a></td><td style="text-align:left">一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a></td><td style="text-align:left">一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td style="text-align:left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a></td><td style="text-align:left">一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td></tr></tbody></table></div><ul><li>test方法仅仅返回一个布尔值，表示是否匹配成功；</li><li>exec方法会返回关于匹配结果的详情，一般包括：<ol><li>匹配的全部字符串</li><li>匹配模式串中括号的分组捕获</li><li>index：匹配到的字符位于原始字符串中的索引值（基于0）</li><li>input：原始字符串</li></ol></li><li>match方法也会返回一个比较详细的匹配结果。</li></ul><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a>插入语</h2><p>插入语即在模式串中使用括号，将希望被记忆的片段保存下来，以便后续程序中使用。</p><p>比如这个模式串<code>const reStr = /.*-q\s*(.*)-p\s*(.*)/</code>，用于匹配的栗子如下：</p><pre class="line-numbers language-none"><code class="language-none">输入命令吧?company_query -q 3 -p Static Department, 3000输入为 company_query -q 3 -p Static Department, 3000[  &#39;company_query -q 3 -p Static Department, 3000&#39;,  &#39;3 &#39;,  &#39;Static Department, 3000&#39;,  index: 0,  input: &#39;company_query -q 3 -p Static Department, 3000&#39;,  groups: undefined]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 高级程序设计语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>主教练工作表（主教练ID，主教练姓名，开始执教年份，队名）</p><p>球队表（队名，所在城市，成立年份）</p><p>球员雇佣表（球员ID，球员姓名，出生日期，队名）</p><p>主队（主队名，主队得分）</p><p>客队（客队名，客队得分）</p><p>足球赛表（主队名，客队名，比赛时间，比赛地点）</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/19/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/19/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要记录一下课程中学习到的基本指令。</p><h2 id="数据传送类指令"><a href="#数据传送类指令" class="headerlink" title="数据传送类指令"></a>数据传送类指令</h2><p>功能：把数据、地址或者立即数传送到寄存器或者存储单元中。</p><h3 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h3><p>语法：MOV    reg/mem/seg（目的操作数）, reg/mem/seg/imm（源操作数）</p><ul><li>reg：通用寄存器</li><li>mem：内存单元，形如[EA] （EA为有效地址，即偏移地址）</li><li>seg：段寄存器</li><li>imm：立即数</li></ul><p>将源操作数src复制到目的操作数dst中，结果是<strong>目的操作数的内容等于源操作数的内容</strong>，源操作数的内容不变。</p><p>重要说明：</p><ul><li>双操作数不能同时为段寄存器或者内存</li><li>代码段寄存器CS和立即数不能作为目的操作数，立即数不能直接传送到段寄存器中</li><li>dest与src必须类型匹配（位数一致）</li></ul><h3 id="XCHG指令"><a href="#XCHG指令" class="headerlink" title="XCHG指令"></a>XCHG指令</h3><p>语法：XCHG    reg/mem（dest）, reg/mem（src）</p><p>交换dest和src中的内容。</p><h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><ol><li><p>进栈指令</p><p>格式：PUSH    reg/mem/seg（src）</p><p>将把src中的内容存入SP指向的内存（地址对应）</p><p>隐藏了目的操作数SP+1与SP（双字）。</p></li><li><p>出栈指令</p><p>格式：POP    reg/mem/seg（src）</p><p>与上面的进栈指令相逆。</p></li></ol><h3 id="标志处理指令"><a href="#标志处理指令" class="headerlink" title="标志处理指令"></a>标志处理指令</h3><p>除了有一些指令影响标志位外，80x86还提供了一组设置或清除标志位指令，它们只影响本指令指定的标志，而不影响其他标志位。如</p><ul><li>CLD    方向标志置0指令</li><li>CLI     中断标志置0指令</li></ul><h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p>LEA    reg16，mem</p><p>主存按源地址的寻址方式计算偏移地址，将偏移地址送入指定的寄存器。</p><p>注意：<strong>LEA与MOV指令相比，最大的区别在于LEA是将偏移地址送入寄存器，而MOV是将存储单元中的内容送入寄存器（或其他）</strong>。</p><h3 id="段寄存器装入指令"><a href="#段寄存器装入指令" class="headerlink" title="段寄存器装入指令"></a>段寄存器装入指令</h3><p>LDS/LES    REG, SRC</p><p>LDS指定的段寄存器是DS，LES指定的段寄存器是ES；其中的SRC只能使用存储器寻址方式，目的寄存器不允许使用段寄存器。</p><h3 id="累加器专用传送指令"><a href="#累加器专用传送指令" class="headerlink" title="累加器专用传送指令"></a>累加器专用传送指令</h3><p>IN    AL, PORT(字节)</p><p>IN    AX, PORT(字)</p><p>OUT    PORT, AL</p><p>OUT    PORT, AX</p><h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><ul><li><p>ADD    dest，src</p><p>将dest和src相加，并将和保留在目的操作数中。</p><p>会改变标志位。</p></li><li><p>ADC     dest，src</p><p>带进位的加法指令，会加上进位CF。</p></li><li><p>INC     opr</p></li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>CBW    字节转换为字指令：AL的内容符号扩展到AH，形成AX中的字。</p><p>CWD    字转换为双字指令：AX的内容符号扩展到DX，形成DX，AX中的双字。</p><h2 id="位操作指令"><a href="#位操作指令" class="headerlink" title="位操作指令"></a>位操作指令</h2><h3 id="逻辑与、逻辑或、逻辑异或"><a href="#逻辑与、逻辑或、逻辑异或" class="headerlink" title="逻辑与、逻辑或、逻辑异或"></a>逻辑与、逻辑或、逻辑异或</h3><h3 id="逻辑非指令：操作数按位取反"><a href="#逻辑非指令：操作数按位取反" class="headerlink" title="逻辑非指令：操作数按位取反"></a>逻辑非指令：操作数按位取反</h3><p>NOT    reg/mem</p><h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>分为逻辑左移（SHL）、逻辑右移，算术左移（SAL）、算术右移，循环左移（ROL）、循环右移，带CF位的循环左移（RCL）和循环右移。</p><p>语法格式：移位指令    dest, Count</p><p><strong>当移位次数大于1时，必须将移位次数提前送至CL寄存器，再执行移位指令</strong>。</p><ul><li>逻辑移位：不考虑符号位（每次移位后补零）</li><li>算术移位：考虑符号位（左移补零，右移补符号位）</li></ul><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="无条件转移指令：JMP"><a href="#无条件转移指令：JMP" class="headerlink" title="无条件转移指令：JMP"></a>无条件转移指令：JMP</h3><ul><li><p>段内直接转移</p><p>JMP    SHORT    OPR</p></li><li><p>段内间接近转移</p><p>JMP    WORD    PTR    OPR</p></li><li><p>段间直接远转移</p></li><li><p>段间间接远转移</p><p>JMP    DWORD    PTR    OPR</p><p>EA内容送入IP，EA+2内容送入CS。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的安全性和完整性</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的安全性"><a href="#数据库的安全性" class="headerlink" title="数据库的安全性"></a>数据库的安全性</h1><h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><h3 id="用户标识和鉴定"><a href="#用户标识和鉴定" class="headerlink" title="用户标识和鉴定"></a>用户标识和鉴定</h3><p>这是系统提供的最外层的安全保护措施，常用方法包括：</p><ul><li><p>静态口令鉴别</p><p>静态不变的口令，由用户自己设定，比如自己设置的密码。</p></li><li><p>动态口令鉴别</p><p>动态可变的口令，每次访问数据库时都不同，比如短信密码、动态令牌。</p></li><li><p>生物特征鉴别</p></li><li><p>智能卡鉴别</p></li></ul><h3 id="存取控制机制"><a href="#存取控制机制" class="headerlink" title="存取控制机制"></a>存取控制机制</h3><p>数据库安全最重要的一点，是确保只授权给有资格的用户访问数据库的权限，同时令未被授权的人员无法接近数据。</p><h4 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h4><p>这里面涉及了一个很重要的概念——用户权限，它包括两个要素：</p><ul><li>数据库对象</li><li>操作类型</li></ul><h4 id="授权——权限授予：GRANT"><a href="#授权——权限授予：GRANT" class="headerlink" title="授权——权限授予：GRANT"></a>授权——权限授予：GRANT</h4><p>语法格式如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>权限<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> 权限<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">ON</span> <span class="token operator">&lt;</span>对象类型<span class="token operator">></span><span class="token operator">&lt;</span>对象名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>对象类型<span class="token operator">></span><span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token punctuation">]</span><span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> 用户<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>它表示向用户授予操纵数据库对象的权限；</li><li>如果指定了WITH GRANT OPTION，表示被授权的用户还可以继续把这种权限授予他人，否则只能使用权限，不能传播权限。</li></ul><h4 id="授权——权限收回：REVOKE"><a href="#授权——权限收回：REVOKE" class="headerlink" title="授权——权限收回：REVOKE"></a>授权——权限收回：REVOKE</h4><p>语法格式如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token operator">&lt;</span> 权限<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> 权限<span class="token punctuation">]</span> …<span class="token keyword">ON</span> <span class="token operator">&lt;</span> 对象类型<span class="token operator">></span> <span class="token operator">&lt;</span> 对象名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span> 对象类型<span class="token operator">></span> <span class="token operator">&lt;</span> 对象名<span class="token operator">></span><span class="token punctuation">]</span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span> 用户<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> 用户<span class="token punctuation">]</span> … <span class="token punctuation">[</span><span class="token keyword">CASCADE</span> <span class="token operator">|</span> <span class="token keyword">RESTRICT</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>CASCADE: 级联回收，该“被回收权限的用户”传播的权限也被回收</p><p>注意级联的对象的权限可能来自多个用户。</p></li><li><p>RESTRICT: 存在级联回收时拒绝执行权限回收</p></li></ul><p>比如收回Bob修改Course表中课程号的权限：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token keyword">UPDATE</span><span class="token punctuation">(</span>Cno<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> Course<span class="token keyword">FROM</span> Bob<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="模式的授权"><a href="#模式的授权" class="headerlink" title="模式的授权"></a>模式的授权</h4><ul><li><p>允许用户创建关系时声明外码</p><p>GRANT    REFERENCES（被参照属性）</p><p>ON    被参照关系</p><p>TO    用户;</p></li><li><p>创建数据库模式的权限</p><p>对创建数据库模式一类的数据库对象的授权，由管理员创建用户时实现：</p><p>CREATE    USER</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">WITH</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>DBA<span class="token operator">|</span>RESOURCE<span class="token operator">|</span>CONNECCT<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h4><p>分为角色的创建、授权、授予其他用户：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> ROLE <span class="token operator">&lt;</span>角色名<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>权限<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span>权限<span class="token punctuation">]</span><span class="token keyword">ON</span> <span class="token operator">&lt;</span>对象类型<span class="token operator">></span><span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token keyword">TO</span> <span class="token operator">&lt;</span>角色<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> 角色<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>角色<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span>角色<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">TO</span> <span class="token operator">&lt;</span>目标角色<span class="token operator">|</span>用户<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">WITH</span> ADMIN <span class="token keyword">OPTION</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似地，也有角色权限的收回、角色的收回（均用到REVOKE）。</p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>审计，启用一个专用的审计日志，系统自动将用户对数据库的所有操作记录在上面</p><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><p>完整性约束通常包括：</p><ul><li>域完整性</li><li>实体完整性</li><li>关联完整性</li><li>用户定义完整性</li></ul><p>其中，域完整性、实体完整性和关联完整性，是关系模型必须满足的完整性约束条件。</p><h2 id="域完整性"><a href="#域完整性" class="headerlink" title="域完整性"></a>域完整性</h2><p>保证关系表属性取值的合理性，例如：</p><ul><li>属性值应该是域中的值</li><li>一个属性能否为NULL，列值是否唯一</li></ul><p>在创建表时可以定义</p><ul><li>列值非空</li><li>列值唯一</li><li>检查列值是否满足一个布尔表达式</li><li>设置属性默认值</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> DEPT<span class="token punctuation">(</span>Deptno <span class="token keyword">NUMERIC</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     Dname <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span><span class="token comment">/*要求Dname列值唯一*/</span>     Location <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">'哈尔滨'</span><span class="token punctuation">,</span><span class="token comment">/*设置了Location的默认值为“哈尔滨”*/</span>     <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Deptno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/*部门编号Deptno列为主码*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><p><strong>指关系的主码不能重复也不能去空值</strong>。</p><p>在CREATE TABLE中使用 PRIMARY KEY来定义主码。</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>与外键有紧密联系。</p><p>在CREATE TABLE 中使用FOREIGN KEY短语定义哪些列为外码，用REFERENCES 短语指明这些外码参照哪些表的主码。</p><p>关系SC 中一个元组表示一个学生选修的某门课程的成<br>绩，（Sno ，Cno ）是主码。Sno ，Cno 分别参照引用<br>Student 表的主码和Course 表的主码：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/*［例3］ ］ 定义SC 中的参照完整性 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SC<span class="token punctuation">(</span>Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>Grade <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Sno<span class="token punctuation">,</span> Cno<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">/* 在表级定义实体完整性*/</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">/* 在表级定义参照完整性*/</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Cno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token comment">/* 在表级定义参照完整性*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><h3 id="属性上的约束条件"><a href="#属性上的约束条件" class="headerlink" title="属性上的约束条件"></a>属性上的约束条件</h3><h3 id="元组上的约束条件"><a href="#元组上的约束条件" class="headerlink" title="元组上的约束条件"></a>元组上的约束条件</h3><p>CHECK子句可以设置不同属性之间的取值的相互约束条件。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> ASSERTION <span class="token operator">&lt;</span>断言名<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">Check</span>子句<span class="token operator">></span><span class="token keyword">DROP</span> ASSERTION <span class="token operator">&lt;</span>断言名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，声明一个断言，用于限制每一门课程最多选课学生数量为60：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> ASSERTION ASSE_SC_CNUM1<span class="token keyword">CHECK</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">>=</span> <span class="token keyword">ALL</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>                   <span class="token keyword">FROM</span> SC                   <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cno<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ul><li>触发器是由用户定义在关系表上的一类由事件驱动的特殊过程。基本语法如下：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> <span class="token operator">&lt;</span>触发器名<span class="token operator">></span>&#123;BEFORE <span class="token operator">|</span> <span class="token keyword">AFTER</span>&#125; <span class="token operator">&lt;</span>触发事件<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>REFERENCING NEW<span class="token operator">|</span>OLD <span class="token keyword">ROW</span><span class="token operator">|</span><span class="token keyword">TABLE</span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span>变量<span class="token operator">></span><span class="token keyword">FOR</span> EACH &#123;<span class="token keyword">ROW</span> <span class="token operator">|</span> STATEMENT&#125;<span class="token punctuation">[</span><span class="token keyword">WHEN</span> <span class="token operator">&lt;</span>触发条件<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>触发动作体<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>触发器又称“事件-条件-动作”规则。</p><ul><li>触发事件，包括INSERT, DELETE, UPDATE等</li><li>BEFORE表示触发事件操作执行之前激活触发器，AFTER表示触发事件操作执行之后激活触发器</li><li>FOR EACH后面的标识指定的是行级触发器还是语句级触发器</li><li>WHEN 表示触发条件，当触发器被激活时，只有当触发条件为真时，触发动作体才执行，如果省略，触发器激活后触发动作体立即执行</li><li>行级触发器中，可以使用NEW ROW和OLD ROW 来引用UPDATE / INSERTION之后的新值和之前的旧值，语句级触发器则使用NEW TABLE和OLD TABLE引用包含所有被影响的行的临时表。</li></ul><pre class="line-numbers language-none"><code class="language-none">\begin&#123;flalign&#125;\end&#123;flalign&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\begin{flalign}&Partition(begin, end, nums[], standard):\\&If\ begin >= end \quad Then\ Return\ begin;\\&i \gets begin;\\&for\ j \gets end \ to \ begin\\&\qquad do\ If\ nums[j] <= nums[standard]\\&\qquad \qquad i \gets i+1;\\&\qquad \qquad nums[i] \leftrightarrow nums[j];\\&nums[i+1] \leftrightarrow nums[standard]\\& Return\ i+1\end{flalign}</script><script type="math/tex; mode=display">\begin{flalign}&Solution(cups[], covers[], begin, end):\\&If\ begin >= end \quad Then \quad Return;\\&std \gets Partition(begin, end, cups, end);\\&Partition(begin, end, covers, std);\\&Solution(cups, covers, begin, std-1);\\&Solution(cups, covers, std+1, end);\end{flalign}</script><script type="math/tex; mode=display">5</script><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1.</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Student<span class="token punctuation">(</span>Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span> Sname <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span> Ssex <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Sage <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span> Sdept <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Course<span class="token punctuation">(</span>Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>Cname <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>Cpno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Ccredit <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Cpno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SC<span class="token punctuation">(</span>Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Grade <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Sno<span class="token punctuation">,</span> Cno<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEYS</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEYS</span><span class="token punctuation">(</span>Cno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2.</span> <span class="token number">2.1</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Employee<span class="token punctuation">,</span> Works<span class="token keyword">WHERE</span> company_name<span class="token operator">=</span><span class="token string">'Baidu Corporation'</span> <span class="token operator">AND</span> salary<span class="token operator">></span><span class="token number">100</span><span class="token punctuation">;</span><span class="token number">2.2</span><span class="token keyword">SELECT</span> manager_name<span class="token keyword">FROM</span> Manages<span class="token number">2.3</span><span class="token keyword">SELECT</span> person_name<span class="token keyword">FROM</span> Manages<span class="token keyword">WHERE</span> manager_name<span class="token operator">=</span><span class="token string">'Hans Write'</span><span class="token number">2.4</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token keyword">FROM</span> Works<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> company_name<span class="token punctuation">;</span><span class="token number">2.5</span><span class="token keyword">SELECT</span> company_name<span class="token keyword">FROM</span> Employee<span class="token punctuation">,</span> Works<span class="token keyword">WHERE</span> street<span class="token operator">=</span><span class="token string">'Wenhua West Road'</span> <span class="token operator">AND</span> city<span class="token operator">=</span><span class="token string">'威海市'</span><span class="token punctuation">;</span><span class="token number">2.6</span><span class="token keyword">SELECT</span> person_name<span class="token keyword">FROM</span> Manages<span class="token punctuation">,</span> Employee Employee1<span class="token punctuation">,</span> Employee Employee2<span class="token keyword">WHERE</span> Manages<span class="token punctuation">.</span>person_name<span class="token operator">=</span>Employee1<span class="token punctuation">.</span>person_name <span class="token operator">AND</span>Manages<span class="token punctuation">.</span>manager_name<span class="token operator">=</span>Employee2<span class="token punctuation">.</span>person_name <span class="token operator">AND</span>Employee1<span class="token punctuation">.</span>city<span class="token operator">=</span>Employee2<span class="token punctuation">.</span>city <span class="token operator">AND</span>Employee1<span class="token punctuation">.</span>street<span class="token operator">=</span>Employee2<span class="token punctuation">.</span>street<span class="token punctuation">;</span><span class="token number">2.7</span><span class="token keyword">SELECT</span> person_name<span class="token keyword">FROM</span> Works<span class="token keyword">WHERE</span> company_name<span class="token operator">!=</span><span class="token string">'Baidu Corporation'</span><span class="token number">3.</span><span class="token number">3.1</span><span class="token keyword">SELECT</span> Grade<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC<span class="token punctuation">,</span> Course<span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">AND</span> Cname<span class="token operator">=</span><span class="token string">'数据库'</span><span class="token punctuation">;</span><span class="token number">3.2</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span><span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC<span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">AND</span> Ssex<span class="token operator">=</span><span class="token string">'女'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sname<span class="token punctuation">;</span><span class="token number">3.3</span><span class="token keyword">WITH</span> <span class="token keyword">Temp</span> <span class="token keyword">AS</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno    <span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC    <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span>    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sname    <span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">85</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token keyword">FROM</span> <span class="token keyword">Temp</span><span class="token keyword">WHERE</span> Grade<span class="token operator">></span><span class="token number">90</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript编程练习题</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/14/JavaScript%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/14/JavaScript%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><h4 id="Once-upon-a-time-on-a-way-through-the-old-wild-mountainous-west-…"><a href="#Once-upon-a-time-on-a-way-through-the-old-wild-mountainous-west-…" class="headerlink" title="Once upon a time, on a way through the old wild mountainous west,…"></a>Once upon a time, on a way through the old wild <em>mountainous</em> west,…</h4></li></ol><p>… a man was given directions to go from one point to another. The directions were “NORTH”, “SOUTH”, “WEST”, “EAST”. Clearly “NORTH” and “SOUTH” are opposite, “WEST” and “EAST” too.</p><p>Going to one direction and coming back the opposite direction <em>right away</em> is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it’s important to save yourself some energy, otherwise you might die of thirst!</p><h4 id="How-I-crossed-a-mountainous-desert-the-smart-way"><a href="#How-I-crossed-a-mountainous-desert-the-smart-way" class="headerlink" title="How I crossed a mountainous desert the smart way."></a>How I crossed a <em>mountainous</em> desert the smart way.</h4><p>The directions given to the man are, for example, the following (depending on the language):</p><pre class="line-numbers language-none"><code class="language-none">[&quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;, &quot;NORTH&quot;, &quot;WEST&quot;].or&#123; &quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;, &quot;NORTH&quot;, &quot;WEST&quot; &#125;;or[North, South, South, East, West, North, West]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>You can immediatly see that going “NORTH” and <em>immediately</em> “SOUTH” is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply:</p><pre class="line-numbers language-none"><code class="language-none">[&quot;WEST&quot;]or&#123; &quot;WEST&quot; &#125;or[West]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Other-examples"><a href="#Other-examples" class="headerlink" title="Other examples:"></a>Other examples:</h4><p>In <code>[&quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;]</code>, the direction <code>&quot;NORTH&quot; + &quot;SOUTH&quot;</code> is going north and coming back <em>right away</em>.</p><p>The path becomes <code>[&quot;EAST&quot;, &quot;WEST&quot;]</code>, now <code>&quot;EAST&quot;</code> and <code>&quot;WEST&quot;</code> annihilate each other, therefore, the final result is <code>[]</code> (nil in Clojure).</p><p>In [“NORTH”, “EAST”, “WEST”, “SOUTH”, “WEST”, “WEST”], “NORTH” and “SOUTH” are <em>not</em> directly opposite but they become directly opposite after the reduction of “EAST” and “WEST” so the whole path is reducible to [“WEST”, “WEST”].</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 高级程序设计语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript精简代码</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/11/JavaScript%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/11/JavaScript%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="数组快速前缀和"><a href="#数组快速前缀和" class="headerlink" title="数组快速前缀和"></a>数组快速前缀和</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const accumulate &#x3D; (...nums) &#x3D;&gt;  nums.reduce((acc, n) &#x3D;&gt; [...acc, n + (acc.slice(-1)[0] || 0)], [])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce函数，这个函数作用于一个数组，最大的特点就是数组中的每一个元素都会被作为接收的函数的参数调用一次：</p><p><code>reduce((accumulate, current) =&gt; &#123;...&#125;, initial)</code></p><p>接收两个参数：</p><ul><li>第一个是一个函数，它的第一个参数accumulate是累加器，代表当前处理值，第二个参数是数组当前的处理值；</li><li>第二个是accumulate的初始值，默认为数组的第一个元素。</li></ul><h4 id="使用到reduce-函数的场景"><a href="#使用到reduce-函数的场景" class="headerlink" title="使用到reduce()函数的场景"></a>使用到reduce()函数的场景</h4><p>reduce()专用于Array，功能强大，有时候会发挥巧妙的作用，这就要求我们对reduce()有足够的掌握能力了。但是一般说来，如果对于某一个数组，我们需要遍历其每一个元素进行处理，并且还需要先前的处理结果时，此时可能适合使用reduce()。<strong>另外，有些问题可能并不是以数组形式出现，需要首先将其转化为数组（Object.keys()等方法）</strong>。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote><p>Pete likes to bake some cakes. He has some recipes and ingredients. Unfortunately he is not good in maths. Can you help him to find out, how many cakes he could bake considering his recipes?</p><p>Write a function <code>cakes()</code>, which takes the recipe (object) and the available ingredients (also an object) and returns the maximum number of cakes Pete can bake (integer). For simplicity there are no units for the amounts (e.g. 1 lb of flour or 200 g of sugar are simply 1 or 200). Ingredients that are not present in the objects, can be considered as 0.</p><p>Examples:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// must return 2</span><span class="token function">cakes</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">flour</span><span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token literal-property property">sugar</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token literal-property property">eggs</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">flour</span><span class="token operator">:</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token literal-property property">sugar</span><span class="token operator">:</span> <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token literal-property property">eggs</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token literal-property property">milk</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// must return 0</span><span class="token function">cakes</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">apples</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">flour</span><span class="token operator">:</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token literal-property property">sugar</span><span class="token operator">:</span> <span class="token number">150</span><span class="token punctuation">,</span> <span class="token literal-property property">milk</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">oil</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">sugar</span><span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token literal-property property">flour</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token literal-property property">milk</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>分享一个很简洁的代码思路：</p><p>首先肯定要遍历配料对象的每一个属性，然后在原料对象中查询之，两者作整数除法，取出最小值即为答案了。这其实符合了reduce()函数的使用场景：每一个元素都需要被处理；还需要比较先前的处理结果（取最小值）。</p><p>于是，对于reduce的接收的回调函数的累加器参数，我们设置为min{当前原料与配料量之比，之前的值}（也即回调函数的返回值），第二个参数设为Infinity，表示无穷大。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function cakes(recipe, available) &#123;    return Object.keys(recipe).reduce((pre, ingre) &#x3D;&gt; &#123;        return Math.min(Math.floor(available[ingre] &#x2F; recipe[ingre]), pre)    &#125;, Infinity)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>Array.slice()，用于JavaScript的数组切片操作。此处，acc.slice(-1)表示取出acc的最后一个元素（返回数组）。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>审视这段代码，[]是初始值，也就是第一次调用回调函数时，acc累加器是[]，参数n是首元素，箭头函数返回值是一个数组，acc是数组类型，经扩展运算符，与当前值和累加器的最后一个元素相加组合成新数组。</li><li>这样一来，数组就是前缀和形式。</li></ul><h2 id="快速修改ISO格式日期"><a href="#快速修改ISO格式日期" class="headerlink" title="快速修改ISO格式日期"></a>快速修改ISO格式日期</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const addDaysToDate &#x3D; (date, n) &#x3D;&gt; &#123;  const d &#x3D; new Date(date);  d.setDate(d.getDate() + n);  return d.toISOString().split(&#39;T&#39;)[0];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="toISOString"><a href="#toISOString" class="headerlink" title="toISOString()"></a>toISOString()</h3><p>Date.toISOString()，可以将一个Date类型的数据转化为ISO格式的字符串。ISO格式，形如<code>*2022-10-15T00:00:00.000Z*</code></p><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>调用Date类型数据d的setDate()方法，设置其天数，在当前天数（getDate()）基础上加n，重新转为ISO类型字符串。</p><h2 id="数组快速分割"><a href="#数组快速分割" class="headerlink" title="数组快速分割"></a>数组快速分割</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const aperture &#x3D; (n, arr) &#x3D;&gt;&#x2F;&#x2F; map((currentValue, currentIndex) &#x3D;&gt; &#123;&#125;)  n &gt; arr.length    ? []    : arr.slice(n - 1).map((v, i) &#x3D;&gt; arr.slice(i, i + n));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>Array.map((currentValue, currentIndex) =&gt; {…})</p><p>这个函数的特点也是会对数组中的每一个元素都使用一次回调函数参数。</p><h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>对于最外层的aperture函数，参数n是步长，arr是原数组；先从原数组的第n个元素开始取，对取出的子数组的每一个元素都使用map()函数（共arr.length-n+1次），每一次调用map函数都会得到一个新的子数组。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">aperture(2, [1, 2, 3, 4]); &#x2F;&#x2F; [[1, 2], [2, 3], [3, 4]]aperture(3, [1, 2, 3, 4]); &#x2F;&#x2F; [[1, 2, 3], [2, 3, 4]]aperture(5, [1, 2, 3, 4]); &#x2F;&#x2F; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="算术迭代"><a href="#算术迭代" class="headerlink" title="算术迭代"></a>算术迭代</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arithmeticProgression &#x3D; (n, lim) &#x3D;&gt;    Array.from(&#123;        length: Math.ceil(lim &#x2F; n)    &#125;, (_, i) &#x3D;&gt; (i + 1) * n)let re &#x3D; arithmeticProgression(5, 25)console.log(re);&#x2F;&#x2F; [ 5, 10, 15, 20, 25 ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h3><p>Array.from(obj, mapFn(currentValue, currentIndex) =&gt; {…}, thisArg)</p><p>其中，obj是一个可迭代对象（具有length属性），它将被转化为一个数组；而mapFn相当于map函数，它会在obj转化时对其进一步转化（联系map函数特点，每一个元素都会被处理一次）。</p><h3 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h3><p>此处的from函数，第一个参数是一个对象，length属性用于迭代生成数组，第二个参数是mapFn，它接收了两个参数，第一个是占位符，第二个是下标，表示数组中的每一个元素的得到方式：下标加1再乘以n。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote><p>The goal of this exercise is to convert a string to a new string where each character in the new string is <code>&quot;(&quot;</code> if that character appears only once in the original string, or <code>&quot;)&quot;</code> if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><pre class="line-numbers language-none"><code class="language-none">&quot;din&quot;      &#x3D;&gt;  &quot;(((&quot;&quot;recede&quot;   &#x3D;&gt;  &quot;()()()&quot;&quot;Success&quot;  &#x3D;&gt;  &quot;)())())&quot;&quot;(( @&quot;     &#x3D;&gt;  &quot;))((&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>参考代码如下，思路是将字符串转化为数组，同时利用from函数的第二个参数——处理函数，对结果进行二次处理，最后重新拼接成满足条件的字符串。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function duplicateEncode(word)&#123;    word &#x3D; word.toUpperCase()    return Array.from(word, (v, i) &#x3D;&gt; word.indexOf(v)&#x3D;&#x3D;&#x3D;word.lastIndexOf(v) ? &#39;(&#39; : &#39;)&#39;).join(&#39;&#39;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Write a function, <code>persistence</code>, that takes in a positive parameter <code>num</code> and returns its multiplicative persistence, which is the number of times you must multiply the digits in <code>num</code> until you reach a single digit.</p><p>For example <strong>(Input —&gt; Output)</strong>:</p><pre class="line-numbers language-none"><code class="language-none">39 --&gt; 3 (because 3*9 &#x3D; 27, 2*7 &#x3D; 14, 1*4 &#x3D; 4 and 4 has only one digit)999 --&gt; 4 (because 9*9*9 &#x3D; 729, 7*2*9 &#x3D; 126, 1*2*6 &#x3D; 12, and finally 1*2 &#x3D; 2)4 --&gt; 0 (because 4 is already a one-digit number)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">persistence</span><span class="token punctuation">(</span><span class="token parameter">num<span class="token punctuation">,</span> time<span class="token operator">=</span><span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> num <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">?</span> time <span class="token operator">:</span> <span class="token function">persistence</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> acc <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>time<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="多维数组求最大值"><a href="#多维数组求最大值" class="headerlink" title="多维数组求最大值"></a>多维数组求最大值</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const ary &#x3D; (fn, n) &#x3D;&gt; (...args) &#x3D;&gt; fn(...args.slice(0, n));const firstTwoMax &#x3D; ary(Math.max, 2);[    [2, 6, &#39;a&#39;],    [6, 4, 8],    [10]].map(x &#x3D;&gt; firstTwoMax(...x)); &#x2F;&#x2F; [6, 6, 10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h3><p>此处的ary函数的写法有些奇怪。其实，这是箭头函数简略写法的嵌套，有点类似闭包——也就是说，ary的返回结果是一个函数对象，这个函数对象接收一个数组，并取其子数组作为参数调用fn函数。</p><p>firstTwoMax()得到一个求前两个元素较大值的函数对象，经map函数作用于每一个子数组，得到新值。</p><h2 id="对象是否包含指定键"><a href="#对象是否包含指定键" class="headerlink" title="对象是否包含指定键"></a>对象是否包含指定键</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const assertValidKeys &#x3D; (obj, keys) &#x3D;&gt;  Object.keys(obj).every(key &#x3D;&gt; keys.includes(key));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>这个方法是Object对象上的，它接收一个object实例对象作为参数，返回其所有的键（数组形式）。</p><h3 id="Array-every-callback"><a href="#Array-every-callback" class="headerlink" title="Array.every(callback)"></a>Array.every(callback)</h3><p>对数组的每一个元素检查，是否满足回调函数 callback 中提供的条件。</p><h2 id="数组元素分组"><a href="#数组元素分组" class="headerlink" title="数组元素分组"></a>数组元素分组</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">bifurcate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> filter</span><span class="token punctuation">)</span> <span class="token operator">=></span>  arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>acc<span class="token punctuation">[</span>filter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里关键就是reduce函数的使用：对于arr中的每一个元素，都需要经过处理，累加器acc是一个二维数组，通过判断在filter数组中的值来确定加入acc中的哪一个子数组。</p><h2 id="绑定对象的键"><a href="#绑定对象的键" class="headerlink" title="绑定对象的键"></a>绑定对象的键</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const bindKey &#x3D; (context, fn, ...boundArgs) &#x3D;&gt; (...args) &#x3D;&gt;  context[fn].apply(context, [...boundArgs, ...args]);const freddy &#x3D; &#123;  user: &#39;fred&#39;,  greet: function(greeting, punctuation) &#123;    return greeting + &#39; &#39; + this.user + punctuation;  &#125;&#125;;const freddyBound &#x3D; bindKey(freddy, &#39;greet&#39;);console.log(freddyBound(&#39;hi&#39;, &#39;!&#39;)); &#x2F;&#x2F; &#39;hi fred!&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p><p>这个bind()函数将会创建一个新的函数，同时指定该函数的this参数thisArg，以及传递给function的参数arg1等。</p><h3 id="解释-5"><a href="#解释-5" class="headerlink" title="解释"></a>解释</h3><p>此处的bindKey()将返回一个函数对象：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// freddyBound变量的内容：</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>boundArgs<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数中，context为freddy对象，fn为键名greet，freddyBound()再接收的参数（即…args），会被作为apply方法的第二个参数：</p><p><code>freddyBound(&#39;hi&#39;, &#39;!&#39;)</code>，args即为’hi’, ‘!’，它们将作为greeting、punction出现在freddy.greet的参数中。</p><h2 id="bottomVisible判定页面底部是否可见"><a href="#bottomVisible判定页面底部是否可见" class="headerlink" title="bottomVisible判定页面底部是否可见"></a>bottomVisible判定页面底部是否可见</h2><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const bottomVisible &#x3D; () &#x3D;&gt;    document.documentElement.clientHeight + window.scrollY &gt;&#x3D;    (document.documentElement.scrollHeight ||        document.documentElement.clientHeight);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三大易混属性"><a href="#三大易混属性" class="headerlink" title="三大易混属性"></a>三大易混属性</h3><ul><li>element.clientHeight</li><li>window.scrollX / window.scrollY</li></ul><h4 id="clientHeight-clientWidth"><a href="#clientHeight-clientWidth" class="headerlink" title="clientHeight/clientWidth"></a>clientHeight/clientWidth</h4><p>这是HTMLElement的一个只读属性。比如clientHeight，它是<strong>元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距</strong>。</p><p><code>HTMLElement&#39;clientHeight = CSS&#39;height + CSS&#39;padding - scroll&#39;height</code></p><p>使用语法一般就是</p><p><code>var h = element.clientHeight;</code></p><p>其中，element是一个HTML元素，它会返回一个整数（单位px像素）。</p><h4 id="offsetHeight-offsetWidth"><a href="#offsetHeight-offsetWidth" class="headerlink" title="offsetHeight/offsetWidth"></a>offsetHeight/offsetWidth</h4><p>这也是HTMLElement的一个只读属性。比如元素的offsetHeight是一种元素CSS高度的衡量标准，包括<strong>元素的边框、内边距和元素的水平滚动条</strong>。</p><h4 id="scrollX-scrollY"><a href="#scrollX-scrollY" class="headerlink" title="scrollX/scrollY"></a>scrollX/scrollY</h4><p>返回<strong>文档/页面水平方向滚动的像素值</strong>。</p><p>使用语法一般就是</p><p><code>var x = window.scrollX;</code></p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.demo</span> <span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span>207<span class="token punctuation">,</span> 114<span class="token punctuation">,</span> 114<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 宽度和高度都属于盒子的内容区，offset和client都包含 */</span>            <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>            <span class="token comment">/* border属于边框，offset包含，client不包含 */</span>            <span class="token property">border</span><span class="token punctuation">:</span> 10px #bfc solid<span class="token punctuation">;</span>            <span class="token comment">/* margin属于外边距，offset、client都不包含 */</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>            <span class="token comment">/* padding属于内边距，offset、client都包含 */</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>            <span class="token comment">/* 滚动条的宽度，offset包含，client不包含 */</span>            <span class="token property">overflow</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        中和癸卯春三月，洛阳城外花如雪。        东西南北路人绝，绿杨悄悄香尘灭。        路旁忽见如花人，独向绿杨阴下歇。        凤侧鸾欹鬓脚斜，红攒黛敛眉心折。        借问女郎何处来？含颦欲语声先咽。        回头敛袂谢行人，丧乱漂沦何堪说！        三年陷贼留秦地，依稀记得秦中事。        君能为妾解金鞍，妾亦与君停玉趾。        前年庚子腊月五，正闭金笼教鹦鹉。        斜开鸾镜懒梳头，闲凭雕栏慵不语。        忽看门外起红尘，已见街中擂金鼓。        居人走出半仓惶，朝士归来尚疑误。        是时西面官军入，拟向潼关为警急。        皆言博野自相持，尽道贼军来未及。        须臾主父乘奔至，下马入门痴似醉。        适逢紫盖去蒙尘，已见白旗来匝地。        扶羸携幼竞相呼，上屋缘墙不知次。        南邻走入北邻藏，东邻走向西邻避。        北邻诸妇咸相凑，户外崩腾如走兽。        轰轰昆昆乾坤动，万马雷声从地涌。        火迸金星上九天，十二官街烟烘烔。        日轮西下寒光白，上帝无言空脉脉。        阴云晕气若重围，宦者流星如血色。        紫气潜随帝座移，妖光暗射台星拆。        ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> <span class="token function-variable function">bottomVisible</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>        document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">+</span> window<span class="token punctuation">.</span>scrollY <span class="token operator">>=</span>        <span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollHeight <span class="token operator">||</span>            document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.demo'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clientHeight'</span><span class="token punctuation">,</span> el<span class="token punctuation">.</span>clientHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clientWidth'</span><span class="token punctuation">,</span> el<span class="token punctuation">.</span>clientWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'offsetHeight'</span><span class="token punctuation">,</span> el<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'offsetWidth'</span><span class="token punctuation">,</span> el<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>scrollY<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--以下是浏览器控制台输出结果--></span>clientHeight 61309-bottomVisible.html:206 clientWidth 41409-bottomVisible.html:207 offsetHeight 65009-bottomVisible.html:208 offsetWidth 45009-bottomVisible.html:209 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是获取各种浏览器可见窗口大小的函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页可见区域宽："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页可见区域高："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页可见区域宽："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetWidth <span class="token operator">+</span> <span class="token string">" (包括边线和滚动条的宽)"</span><span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页可见区域高："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetHeight <span class="token operator">+</span> <span class="token string">" (包括边线的宽)"</span><span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页正文全文宽："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollWidth<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页正文全文高："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页被卷去的高(ff)："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页被卷去的高(ie)："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页被卷去的左："</span><span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollLeft<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页正文部分上："</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screenTop<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 网页正文部分左："</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screenLeft<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 屏幕分辨率的高："</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>height<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 屏幕分辨率的宽："</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>width<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 屏幕可用工作区高度："</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>availHeight<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 屏幕可用工作区宽度："</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>availWidth<span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 你的屏幕设置是 "</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>colorDepth <span class="token operator">+</span><span class="token string">" 位彩色"</span><span class="token punctuation">;</span>        s <span class="token operator">+=</span> <span class="token string">" 你的屏幕设置 "</span><span class="token operator">+</span> window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>deviceXDPI <span class="token operator">+</span><span class="token string">" 像素/英寸"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组元素判定相同"><a href="#数组元素判定相同" class="headerlink" title="数组元素判定相同"></a>数组元素判定相同</h2><blockquote><p>Given two arrays <code>a</code> and <code>b</code> write a function <code>comp(a, b)</code> (or<code>compSame(a, b)</code>) that checks whether the two arrays have the “same” elements, with the same <em>multiplicities</em> (the multiplicity of a member is the number of times it appears). “Same” means, here, that the elements in <code>b</code> are the elements in <code>a</code> squared, regardless of the order.</p><h4 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h4><h5 id="Valid-arrays"><a href="#Valid-arrays" class="headerlink" title="Valid arrays"></a>Valid arrays</h5><pre class="line-numbers language-none"><code class="language-none">a &#x3D; [121, 144, 19, 161, 19, 144, 19, 11]  b &#x3D; [121, 14641, 20736, 361, 25921, 361, 20736, 361]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>comp(a, b)</code> returns true because in <code>b</code> 121 is the square of 11, 14641 is the square of 121, 20736 the square of 144, 361 the square of 19, 25921 the square of 161, and so on. It gets obvious if we write <code>b</code>‘s elements in terms of squares:</p><pre class="line-numbers language-none"><code class="language-none">a &#x3D; [121, 144, 19, 161, 19, 144, 19, 11] b &#x3D; [11*11, 121*121, 144*144, 19*19, 161*161, 19*19, 144*144, 19*19]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function comp(array1, array2) &#123;    return array1 !&#x3D; null &amp;&amp; array2 !&#x3D; null &amp;&amp; array1.sort((a, b) &#x3D;&gt; b - a).map(v &#x3D;&gt; v * v).join() &#x3D;&#x3D; array2.sort((a, b) &#x3D;&gt; b - a).join()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="解释-6"><a href="#解释-6" class="headerlink" title="解释"></a>解释</h3><p>题目要求的是当a数组中元素的平方都在b数组中时（注意a、b元素个数相同），称a与b“相同”，正常的思路是对a数组使用<code>Array.every()</code>，every()函数中接收参数为对a中每一个元素，它的平方是否在b中出现：<code>b.indexOf(ele*ele) !== -1</code>。</p><p>而新颖的思路是，既然两个数组元素数量一致，那么如果a、b相同，将a中元素均平方，得到的新数组和b就会完全一致，只是顺序可能有差异。既然顺序不同，我们可以sort排序将它们顺序转为一致，然后使用<code>Array.join()</code>方法转为字符串，进而直接进行<code>==</code>判定。</p><h2 id="单词首字母大写"><a href="#单词首字母大写" class="headerlink" title="单词首字母大写"></a>单词首字母大写</h2><blockquote><p>Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized <strong>only</strong> if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case).</p><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><pre class="line-numbers language-none"><code class="language-none">&quot;the-stealth-warrior&quot;&#96; gets converted to &#96;&quot;theStealthWarrior&quot;&#96;&#96;&quot;The_Stealth_Warrior&quot;&#96; gets converted to &#96;&quot;TheStealthWarrior&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h3 id="resolution"><a href="#resolution" class="headerlink" title="resolution"></a>resolution</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">toCamelCase</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[-_](.)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token operator">=></span> c<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="String-replace-方法"><a href="#String-replace-方法" class="headerlink" title="String.replace()方法"></a>String.replace()方法</h3><p><code>str.replace(substr | regexp, newSubStr | function)</code></p><ul><li>subStr，是str的子串内容</li><li>regexp，是正则表达式，对str按照该正则进行匹配</li><li>newSubStr，是要替换的新内容</li><li>function，</li></ul><h2 id="判断幂的个位数字"><a href="#判断幂的个位数字" class="headerlink" title="判断幂的个位数字"></a>判断幂的个位数字</h2><blockquote><p>给定两个参数str1，str2，要求出str1^str2的个位数字。</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var lastDigit &#x3D; function(str1, str2) &#123;    return +str2 &#x3D;&#x3D;&#x3D; 0 ? 1 : (+str1.slice(-1))**(+str2.slice(-2) % 4 + 4) % 10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在敲代码编程之前，我们先动笔算算0~9这十个数字的幂的情况，期望从中找出幂的个位数的规律。</p><p>经过简单的计算之后，我们会发现其实0~9每一个数字的幂以4为周期（事实上，0、1、5、6以1为周期，4、8以2为周期），所以取最小公倍数统一处理。此处需要指出：string.slice()方法用于截取字符串，slice(-1)截取最后一个字符，slice(-2)截取最后两个字符，以此类推。</p><h2 id="大数相加问题"><a href="#大数相加问题" class="headerlink" title="大数相加问题"></a>大数相加问题</h2><blockquote><p>传统的a plus b问题，要求它们的和。其中，a、b以字符串给出，返回的结果亦为字符串类型。</p></blockquote><p>The code as below is like an art.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token string">''</span><span class="token comment">// res存储运算结果，以字符串形式；c存储每一位的进位</span>    a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token comment">// 字符串分割，转为数组</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">||</span> b<span class="token punctuation">.</span>length <span class="token operator">||</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">+=</span> <span class="token operator">~</span><span class="token operator">~</span>a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">~</span><span class="token operator">~</span>b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 二次取反，专门用于处理数组长度为0时取值undefined，而~~undefined值为0</span>        res <span class="token operator">=</span> c <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> res<span class="token comment">// 结果拼接</span>        c <span class="token operator">=</span> c <span class="token operator">></span> <span class="token number">9</span><span class="token comment">// 考虑进位</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单词首字母大写-1"><a href="#单词首字母大写-1" class="headerlink" title="单词首字母大写"></a>单词首字母大写</h2><blockquote><p>const capitalize = ([first, …rest], lowerRest = false) =&gt; first.toUpperCase() + (lowerRest ? rest.join(‘’).toLowerCase() : rest.join(‘’))</p></blockquote><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值是ES6新推出的语法，有着强大的功能。</p><p>在上面的代码示例中，我们调用<code>capitalize(&#39;helloWorld&#39;, true);</code>‘helloWorld’会传入参数作为第一个参数，而函数第一个参数是以解构赋值形式接收的：</p><ul><li>first保存的是字符串的首字符，即h；</li><li>…rest保存的是从第二个字符开始的全部子字符串的数组形式，即[‘e’, ‘l’, ‘l’, ‘o’, ‘W’, ‘o’, ‘r’, ‘l’, ‘d’]</li></ul><h3 id="解释-7"><a href="#解释-7" class="headerlink" title="解释"></a>解释</h3><p>运用解构赋值、toUppercase()、toLowerCase()等，可以很方便地实现这种功能。</p>]]></content>
      
      
      <categories>
          
          <category> 高级程序设计语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL查询语言</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/07/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/07/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>简单，易学。</p><h2 id="定义模式、表"><a href="#定义模式、表" class="headerlink" title="定义模式、表"></a>定义模式、表</h2><ul><li>建立关系模式</li><li>修改关系模式</li><li>删除关系模式</li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span><span class="token operator">|</span><span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>查询仅涉及一个表，是一种最简单的查询操作。</p><h4 id="选择列"><a href="#选择列" class="headerlink" title="选择列"></a>选择列</h4><p>即不用WHERE子句，仅使用SELECT，FROM子句。</p><ul><li><p>一般情况下，用于查询指定列</p></li><li><p>还可以查询全部的列</p></li><li><p>可以查询经过计算的指</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span> <span class="token number">2022</span><span class="token operator">-</span>Sage<span class="token keyword">FROM</span> Student<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即可查询出姓名属性、以及2022减去年龄属性的值</p></li><li><p>可以通过DISTINCT或者ALL来选择是否去除相同的列</p></li><li><p>可以实现列的重命名（列别名）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sname NAME<span class="token punctuation">,</span> <span class="token number">2022</span><span class="token operator">-</span>Sage BIRTHDAY<span class="token punctuation">,</span> LOWER<span class="token punctuation">(</span>Sdept<span class="token punctuation">)</span><span class="token keyword">FROM</span> Student<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="WHERE：查询元组"><a href="#WHERE：查询元组" class="headerlink" title="WHERE：查询元组"></a>WHERE：查询元组</h4><p>WHERE子句常用的是条件表达式，涉及的谓词很多，常见的是比较、确定集合等。</p><ul><li>比较：=，&gt;, &lt;, &gt;=, &lt;=, &lt;&gt;</li><li>确定集合：IN, NOT IN</li><li>多重条件：AND, OR</li><li>字符匹配：LIKE, NOT LIKE</li></ul><p>下面给出几个实例对where子句的基本使用进行说明：</p><ul><li><p>DISTINCT短语的作用范围是所有目标列</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Cno<span class="token punctuation">,</span> Grade <span class="token keyword">FROM</span> SC<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而下面的写法是错误的:</p><p><code>SELECT DISTINCT Cno, DISTINCT Grade FROM SC;</code></p></li><li><p>between的使用</p><p>筛选出Student关系中年龄在19到21之间的同学的姓名和性别</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span> Ssex<span class="token keyword">FROM</span> Student<span class="token keyword">Where</span> sage <span class="token operator">between</span> <span class="token number">19</span> <span class="token operator">and</span> <span class="token number">21</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>like的使用</p><p>查询姓“东方”的学生：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token keyword">WHERE</span> Sname <span class="token operator">like</span> <span class="token string">'东方%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通配符：</p><ul><li>%：代替零个或者多个字符</li><li>_：仅代替一个字符</li></ul><p>当要查询的字符串本身就含有%或者_时，需要使用ESCAPE短语进行转义。</p></li><li><p>in的使用</p><p>查询数学系和计算机系的学生：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token keyword">WHERE</span> Sdept <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'MA'</span><span class="token punctuation">,</span> <span class="token string">'CS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="ORDER-BY：对查询结果进行排序"><a href="#ORDER-BY：对查询结果进行排序" class="headerlink" title="ORDER BY：对查询结果进行排序"></a>ORDER BY：对查询结果进行排序</h4><p>ASC：升序，排序列为空值的元组最后显示</p><p>DESC：降序（默认），排序列为空值的元组最先显示</p><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><ul><li>COUNT(*) 统计元组个数</li><li>SUM([DISTINCT | ALL] &lt; 列名 &gt;) 计算一列值的总和</li><li>AVG… 计算平均值</li></ul><h4 id="GROUP-BY：对结果进行分组"><a href="#GROUP-BY：对结果进行分组" class="headerlink" title="GROUP BY：对结果进行分组"></a>GROUP BY：对结果进行分组</h4><p>按指定的一列或者多列值分组，值相等的分为一组。</p><p>注意，使用了GROUP BY子句之后，SELECT子句的列名列表中只能出现分组属性和聚集函数。</p><p>当然，有时还会使用HAVING短语筛选最终输出结果，如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> dept_name<span class="token punctuation">,</span> <span class="token function">Max</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token keyword">FROM</span> Employee<span class="token keyword">WHERE</span> age<span class="token operator">>=</span><span class="token number">23</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> dept_name<span class="token keyword">HAVING</span> <span class="token function">Max</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">80000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HAVING短语和WHERE子句都有筛选功能，但是两者有很大的区别——在作用对象上。</p><ul><li>HAVING短语筛选的作用对象是分组后的中间表，从中选择满足条件的<strong>分组</strong>；</li><li>WHERE子句筛选的作用对象是基表，从中选择满足条件的<strong>元组</strong>。</li></ul><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询，即多表查询情况，待查询的表不只一张。</p><p>用来连接两个表的条件称为连接条件或者连接谓词。</p><ul><li><p>θ-连接</p><p>使用SELECT-FROM-WHERE表示，WHERE子句中包括连接多个表的条件，即连接条件：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用JOIN ON表示方法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student <span class="token keyword">JOIN</span> SC<span class="token keyword">ON</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno<span class="token keyword">WHERE</span> Sage <span class="token operator">&lt;</span> <span class="token number">21</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自然连接，使用natural join关键字：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span> Sage<span class="token punctuation">,</span> Sdept<span class="token punctuation">,</span> Cno<span class="token punctuation">,</span> Grade<span class="token keyword">FROM</span> Student <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> SC<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自连接，一般需要给表起别名，以示区别。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> FIRST1<span class="token punctuation">.</span>Cno<span class="token punctuation">,</span> SECOND1<span class="token punctuation">.</span>Cpno<span class="token keyword">FROM</span> Course FIRSE1<span class="token punctuation">,</span> Course SECOND1<span class="token keyword">WHERE</span> FIRST1<span class="token punctuation">.</span>Cpno <span class="token operator">=</span> SECOND1<span class="token punctuation">.</span>Cno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>利用集合操作，对查询结果进行集合运算：</p><ul><li>并 UNION</li><li>交 INTERSECT</li><li>差 EXCEPT</li></ul><p>对于并、交集合查询，其思想与集合运算一致：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">OR</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token keyword">UNION</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> Student<span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>格式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token keyword">INTO</span> 表名<span class="token punctuation">(</span>属性<span class="token number">1</span><span class="token punctuation">,</span> 属性<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span> 元组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将元组插入表中，如果列名列表省略不写，则默认是插入全部属性，否则按照声明的列名属性插入元组，其他没有在INTO属性中出现的属性列，取空值。</p><p>Student表如下：</p><div class="table-container"><table><thead><tr><th>学号 Sno</th><th>姓名 Sname</th><th>性别 Ssex</th><th>年龄 Sage</th><th>所在系 Sdept</th></tr></thead><tbody><tr><td>20220900112</td><td>孙承宗</td><td>男</td><td>29</td><td>翰林</td></tr><tr><td>20229180938</td><td>徐阶</td><td>男</td><td>49</td><td>内阁</td></tr><tr><td>20221920709</td><td>袁崇焕</td><td>男</td><td>39</td><td>兵部</td></tr><tr><td>20221102123</td><td>张居正</td><td>男</td><td>48</td><td>内阁</td></tr></tbody></table></div><p>SC表如下：</p><div class="table-container"><table><thead><tr><th>学号Sno</th><th>课程号Cno</th><th>成绩Grade</th></tr></thead><tbody><tr><td>20220900112</td><td>1</td><td>98</td></tr><tr><td>20220900112</td><td>2</td><td>92</td></tr><tr><td>20221102123</td><td>1</td><td>90</td></tr></tbody></table></div><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token keyword">INTO</span> Student<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'20201110227'</span><span class="token punctuation">,</span> <span class="token string">'张江陵'</span><span class="token punctuation">,</span> <span class="token string">'男'</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">'内阁'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 向Student表格中添加一行数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token keyword">INTO</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span> Sdept<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'20222900767'</span><span class="token punctuation">,</span> <span class="token string">'徐文长'</span><span class="token punctuation">,</span> <span class="token string">'师爷'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="DBMS会检查所插入元组是否破坏已定义的完整性约束"><a href="#DBMS会检查所插入元组是否破坏已定义的完整性约束" class="headerlink" title="DBMS会检查所插入元组是否破坏已定义的完整性约束"></a>DBMS会检查所插入元组是否破坏已定义的完整性约束</h3><ul><li>实体完整性：是否插入了主键相同的元组</li><li>参照完整性（关联完整性）：外键表插入新元组时，新元组的外键值是否在主键表中存在</li><li>用户定义的完整性：<ul><li>对于有NOT NULL约束的属性列，是否提供了非空值</li><li>对于有UNIQUE约束的属性列，是否提供了非重复值</li><li>对于有值域约束的属性列，所提供的属性值是否在值域范围内</li></ul></li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> 表名<span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>功能：修改指定表中满足where子句条件的元组</p><p>SET子句：指定修改方式</p><p>WHERE子句：指定要修改的元组</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 将上面的Student表中袁崇焕的所在系改为‘督师蓟辽’</span><span class="token keyword">UPDATE</span> Student<span class="token keyword">SET</span> Sdept<span class="token operator">=</span><span class="token string">'督师蓟辽'</span><span class="token keyword">WHERE</span> Sname<span class="token operator">=</span><span class="token string">'袁崇焕'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<strong>修改数据的同时DBMS会做完整性检查（比如涉及外键表时的参照完整性）</strong>。</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样的，DBMS在执行删除语句时，也会检查所删除的元组是否破坏表上已定义的完整性规则。</p><ul><li>删除单个元组的值</li><li>删除多个元组的值</li><li>带子查询的删除语句</li></ul><p>比如，删除上面的Student表格中“内阁”所有成员的选课记录（SC表格）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span><span class="token keyword">FROM</span> Student<span class="token keyword">WHERE</span> Sno <span class="token operator">IN</span>   <span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno    <span class="token keyword">FROM</span> Student    <span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sdept <span class="token operator">=</span> <span class="token string">'内阁'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="何为视图"><a href="#何为视图" class="headerlink" title="何为视图"></a>何为视图</h3><p>视图与基本表在形式上几乎没有区别，同样支持各种SQL操作。</p><p>视图可以理解为数据库的“窗口”。通过视图，不同的人可以观察到自己感兴趣的数据项，而不需要观察整个数据库表。</p><h3 id="基本语法格式"><a href="#基本语法格式" class="headerlink" title="基本语法格式"></a>基本语法格式</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">AS</span> <span class="token operator">&lt;</span>子查询<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>每一个视图都有名称，放在VIEW后面声明，还可以声明视图的属性列；</li><li>AS后面跟任意SELECT查询语句，表示视图中的数据来源；</li><li>WITH CHECK OPTION表示，通过视图进行各种操作时，不得违反视图定义中子查询的谓词条件（条件表达式）。</li></ul><h3 id="视图消解"><a href="#视图消解" class="headerlink" title="视图消解"></a>视图消解</h3><p>从数据字典中取出视图定义，把定义中的子查询和用户查询结合起来，转换成等价的对基表的查询，然后在基表上执行修改之后的查询，称为视图消解。</p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>由于视图本身并不具有数据存储功能，只是给用户提供展示数据，因此，对视图数据的更新，都是通过视图消解转为对基本表的更新。</p><p>但是，并不是所有的视图都可以被更新。</p><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP VIEW &lt;视图名&gt; [CASCADE];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要删除的视图还导出了其他视图，就需要指定CASCADE选项，表示级联删除。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系代数</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/07/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/07/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="元组关系演算"><a href="#元组关系演算" class="headerlink" title="元组关系演算"></a>元组关系演算</h2><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p><code>&#123;t | P(t)&#125;</code></p><p>也就是说，在上面的元组关系演算中，基本单元为元组t，P是谓词，所有使得该谓词为真的元组组成了这个集合。</p><h3 id="几个记号"><a href="#几个记号" class="headerlink" title="几个记号"></a>几个记号</h3><ul><li>t是元组变量，t[A]表示t在属性A上的值</li><li>t属于R，表示元组t属于关系R</li></ul><h2 id="域关系演算"><a href="#域关系演算" class="headerlink" title="域关系演算"></a>域关系演算</h2><p>域变量是表示域的变量。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3移动图书商城项目实战</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/04/Vue3%E7%A7%BB%E5%8A%A8%E5%9B%BE%E4%B9%A6%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/04/Vue3%E7%A7%BB%E5%8A%A8%E5%9B%BE%E4%B9%A6%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>src目录下建立了各个文件夹，便于分类存放各种文件：</p><ul><li>assets：静态资源文件夹，包括css、图片资源等；</li><li>components：通用组件文件夹，存放一些通用的、耦合性低的组件文件；</li><li>network：封装网络请求的文件夹，前端项目中不可避免地会调用后台接口，这个文件夹中存放此类文件，管理接口调用；</li><li>router：路由配置文件夹；</li><li>store：Vuex文件夹，一般会有多个文件，用于分模块共享数据；</li><li>utils：存放第三方库的文件；</li><li>views：页面级别的组件存放文件夹；</li></ul><h2 id="配置network接口文件夹"><a href="#配置network接口文件夹" class="headerlink" title="配置network接口文件夹"></a>配置network接口文件夹</h2><p>在network文件夹下建立三个文件：</p><ul><li>cart.js</li><li>home.js：包含获取首页所有数据的接口调用</li><li>request.js：管理所有的接口调用，比如请求拦截、响应拦截等</li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; request.jsimport axios from &#39;axios&#39;export function request(config) &#123;    const instance &#x3D; axios.create(&#123;        baseURL: &#39;http:&#x2F;&#x2F;api.shop.eduwork.cn&#39;,        timeout: 5000,    &#125;)    &#x2F;&#x2F; 请求拦截    instance.interceptors.request.use(config &#x3D;&gt; &#123;        &#x2F;&#x2F; 如果有一个接口需要认证才可以访问，就在这里统一设置        return config    &#125;, err &#x3D;&gt; &#123;    &#125;)    &#x2F;&#x2F; 响应拦截    instance.interceptors.response.use(res &#x3D;&gt; &#123;        return res    &#125;, err &#x3D;&gt; &#123;        &#x2F;&#x2F; 如果有需要授权才可以访问的接口，统一去login授权        &#x2F;&#x2F; 如果有错误，这里会进行处理    &#125;)    return instance(config)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们接下来第一个要实现的就是首页功能，因此，我们需要先配置好首页中接口调用函数，放在home.js文件中：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; home.jsimport &#123; request &#125; from &quot;.&#x2F;request&quot;;function getHomeAllData() &#123;    return request(&#123;        &#x2F;&#x2F; 拿到首页所有数据，无需任何参数，所以只提供url就可以        url: &#39;&#x2F;api&#x2F;index&#39;    &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小试牛刀：获取首页所有数据"><a href="#小试牛刀：获取首页所有数据" class="headerlink" title="小试牛刀：获取首页所有数据"></a>小试牛刀：获取首页所有数据</h2><p>我们在Home.vue组件中获取数据，在setup函数中调用onMounted生命周期钩子，希望在页面加载时就将拿到的数据显示到页面，故在该钩子中发起axios请求获取数据：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">setup() &#123;    const banner &#x3D; ref([])    onMounted(() &#x3D;&gt; &#123;      getHomeAllData()        .then((res) &#x3D;&gt; &#123;&#125;)        .catch((err) &#x3D;&gt; &#123;&#125;)    &#125;)    return &#123;      banner,    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>我们在views目录下创建所有页面级的文件夹，用于存放各个页面功能的组件：</p><ul><li>category：商品分类页面</li><li>detail：商品详情页面</li><li>home：主页</li><li>profile：个人中心页面</li><li>shopcart：购物车页面</li></ul><p>在配置路由之前，为了使得路由跳转效果明显，我们需要建立以上各个页面的组件文件，比如category文件夹下建立Category.vue文件，其中简单写几句：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;      &lt;h1&gt;商品分类&lt;&#x2F;h1&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;&#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们在router文件夹下的index.js文件中设置路由。</p><p>首先，为了实现懒加载，我们先导入各个组件文件：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const Home &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;home&#x2F;Home.vue&#39;)const Category &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;category&#x2F;Category.vue&#39;)const Detail &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;detail&#x2F;Detail.vue&#39;)const Profile &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;profile&#x2F;Profile.vue&#39;)const ShopCart &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;shopcart&#x2F;ShopCart.vue&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次，在routes数组中补充路由配置：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const routes &#x3D; [  &#123;    path: &#39;&#39;,    name: &#39;DefaultHome&#39;,    component: Home  &#125;,  &#123;    path: &#39;&#x2F;home&#39;,    name: &#39;Home&#39;,    component: Home  &#125;,  &#123;    path: &#39;&#x2F;category&#39;,    name: &#39;Category&#39;,    component: Category  &#125;,  &#123;    path: &#39;&#x2F;detail&#39;,    name: &#39;Detail&#39;,    component: Detail  &#125;,  &#123;    path: &#39;&#x2F;shopcart&#39;,    name: &#39;ShopCart&#39;,    component: ShopCart  &#125;,  &#123;    path: &#39;&#x2F;profile&#39;,    name: &#39;Profile&#39;,    component: Profile  &#125;,]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="制作导航栏"><a href="#制作导航栏" class="headerlink" title="制作导航栏"></a>制作导航栏</h2><p>该移动端移动图书商城的导航栏在最底层，分为四个选项“首页-分类-购物车-我的”，因此，我们直接在App.vue组件中实现。</p><p>在阿里下载好图标后，导入到页面中，由于路由跳转在上面已经实现，故接下来关键只剩两步了：</p><ul><li>使用flex布局使四个选项在同一行均匀显示，呈现分栏状；</li><li>使用fixed定位，将导航栏置于页面最底部。</li></ul><p>App.vue组件内容如下：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;router-view &#x2F;&gt;    &lt;div id&#x3D;&quot;nav&quot;&gt;      &lt;router-link class&#x3D;&quot;tab-bar-item&quot; to&#x3D;&quot;&#x2F;&quot;&gt;        &lt;div class&#x3D;&quot;icon&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-shouye&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;        &lt;div&gt;首页&lt;&#x2F;div&gt;      &lt;&#x2F;router-link&gt;      &lt;router-link class&#x3D;&quot;tab-bar-item&quot; to&#x3D;&quot;&#x2F;category&quot;&gt;        &lt;div class&#x3D;&quot;icon&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-fenlei&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;        &lt;div&gt;分类&lt;&#x2F;div&gt;      &lt;&#x2F;router-link&gt;      &lt;router-link class&#x3D;&quot;tab-bar-item&quot; to&#x3D;&quot;&#x2F;shopcart&quot;&gt;        &lt;div class&#x3D;&quot;icon&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-gouwuche&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;        &lt;div&gt;购物车&lt;&#x2F;div&gt;      &lt;&#x2F;router-link&gt;      &lt;router-link class&#x3D;&quot;tab-bar-item&quot; to&#x3D;&quot;&#x2F;profile&quot;&gt;        &lt;div class&#x3D;&quot;icon&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-xiazai&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;        &lt;div&gt;我的&lt;&#x2F;div&gt;      &lt;&#x2F;router-link&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style lang&#x3D;&quot;scss&quot;&gt;@import &#39;assets&#x2F;css&#x2F;base.css&#39;;@import &#39;assets&#x2F;css&#x2F;iconfont.css&#39;;#app &#123;  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;&#125;#nav &#123;  background-color: #f6f6f6;  display: flex;  position: fixed;  left: 0;  right: 0;  bottom: 0;  box-shadow: 0 -3px 1px rgba(100, 100, 100, 0.1);  a &#123;    color: var(--color-text);    &amp;.router-link-exact-active &#123;      color: #42b983;    &#125;  &#125;  .tab-bar-item &#123;    flex: 1;    text-align: center;    height: 50px;    font-size: var(--font-size);  &#125;  .tab-bar-item .icon &#123;    width: 24px;    height: 24px;    margin-top: 3px;    display: inline-block;    vertical-align: middle;  &#125;&#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="首页推荐商品组件的实现"><a href="#首页推荐商品组件的实现" class="headerlink" title="首页推荐商品组件的实现"></a>首页推荐商品组件的实现</h2><p>首页推荐商品组件，即四本横向排列的书籍，我们单独把这一部分作为一个组件（.vue）来实现。</p><p>在view文件夹的home/ChildComps文件夹下新建Recommend.vue文件，视图部分肯定要用到flex布局：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!--Recommend.vue--&gt;&lt;template&gt;  &lt;div class&#x3D;&quot;recommend&quot;&gt;      &lt;div class&#x3D;&quot;recommend-item&quot; v-for&#x3D;&quot;item in recommends.slice(0, 4)&quot; :key&#x3D;&quot;item.id&quot;&gt;          &lt;a href&#x3D;&quot;&quot; @click.prevent&#x3D;&quot;goD(item.id)&quot;&gt;              &lt;img src&#x3D;&quot;~assets&#x2F;images&#x2F;youshi1.png&quot; alt&#x3D;&quot;&quot;&gt;              &lt;div&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;div&gt;          &lt;&#x2F;a&gt;      &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;.recommend &#123;    display: flex;    width: 100%;    text-align: center;    padding: 15px 0 30px;    border-bottom: 8px solid #eee;    font-size: 12px;&#125;.recommend-item &#123;    flex: 1;    img &#123;        width: 70px;        height: 70px;        margin-bottom: 10px;    &#125;&#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据来自网络请求，也即获取首页数据，这网络请求的相关代码已经封装在了network/home.js中了；我们在Home组件中发起请求，获取首页中需要的全部信息，然后<strong>将推荐的书籍信息传递给Recommend子组件</strong>——使用props属性。</p><h3 id="props用法"><a href="#props用法" class="headerlink" title="props用法"></a>props用法</h3><p>在vue3中，父组件传递数据给子组件，需要用到props。而父组件传过来的数据，子组件的模板、setup函数中的引入方式略有不同。</p><h4 id="模板使用props"><a href="#模板使用props" class="headerlink" title="模板使用props"></a>模板使用props</h4><p>与setup同级使用props配置项即可。此时，也有两种常见的用法：</p><ul><li><p>字符串数组写法</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;export default &#123;    props: [&#39;title&#39;, &#39;author&#39;],    setup() &#123;...&#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的props配置项数组中，每一个字符串中的内容都是父组件传来的数据变量名（title，author）。</p></li><li><p>对象写法</p><p>对象写法允许我们在指定传来的属性名同时，指定它需要传递的类型，以及是否必需，默认值等等。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;export default &#123;    props: &#123;        title: &#123;            type: String,            required: true,        &#125;,        author: &#123;            type: String,            default() &#123;                return &#39;&#39;            &#125;        &#125;    &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="setup函数使用props"><a href="#setup函数使用props" class="headerlink" title="setup函数使用props"></a>setup函数使用props</h4><p>setup函数接收两个参数props，context，其中第一个参数就可以接收到父组件传来的数据，以供在setup函数中使用。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;export default &#123;    setup(props, context) &#123;        ...    &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="首页选项卡的实现"><a href="#首页选项卡的实现" class="headerlink" title="首页选项卡的实现"></a>首页选项卡的实现</h2><p>注意到首页的选项卡并不是首页独有的，而是出现在多个组件中的，因此可以作为公用组件出现在components目录下：在components/common下新建tabControl文件夹，在其中新建tabControl.vue文件，用于制作选项卡。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;tab-control&quot;&gt;    &lt;div      class&#x3D;&quot;tab-control-item&quot;      v-for&#x3D;&quot;(item, index) in titles&quot;      :key&#x3D;&quot;index&quot;      @click&#x3D;&quot;itemClick(index)&quot;      :class&#x3D;&quot;&#123; active: index&#x3D;&#x3D;currentIndex &#125;&quot;    &gt;      &lt;span&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; ref &#125; from &#39;vue&#39;export default &#123;  name: &#39;TabControl&#39;,  props: &#123;    titles: &#123;      type: Array,      default() &#123;        return []      &#125;,    &#125;,  &#125;,  setup() &#123;    let currentIndex &#x3D; ref(0)    &#x2F;&#x2F; 当点击某一个选项卡时，把active类赋给它    const itemClick &#x3D; (index) &#x3D;&gt; &#123;        currentIndex.value &#x3D; index    &#125;    return &#123;      currentIndex,      itemClick,    &#125;  &#125;,&#125;&lt;&#x2F;script&gt;&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;.tab-control &#123;  display: flex;  height: 40px;  line-height: 40px;  text-align: center;  font-size: 14px;  width: 100%;  .tab-control-item &#123;    flex: 1;    span &#123;      padding: 5px;    &#125;  &#125;  .active &#123;    color: var(--color-tint);    span &#123;      border-bottom: 3px solid var(--color-tint);    &#125;  &#125;&#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然首页中的选项卡只有三项，但是其他组件中的选项卡跟首页并不相同，因此使用组件传值的方式，用变量接收选项卡数据，同时使用v-for指令动态生成若干选项卡。</p><p>样式方面，对选项卡进行flex布局设置，另外，由于点击某一个选项卡会触发特殊样式，因此对样式使用属性绑定写法：</p><p><code>:class=&quot;&#123; active: index==currentIndex &#125;&quot;</code></p><p>而currentIndex是设置的标记变量，用于记录当前被点击的选项卡序号，index是每一个选项卡固有的序号属性，两者比对即可实现对样式是否触发的检验。</p><p>接下来，我们需要实现点击某一个选项卡后，显示该项下的内容。由于选项卡是子组件TabControl.vue实现的，但是该选项卡要展示的内容却是在Home组件中显示的，因此涉及了子组件向父组件传递数据。</p><h3 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h3><p>emit可以实现子组件与父组件的通信。emit（触发），当子组件中完成某个操作时，调用回调函数，触发（emit）一个自定义事件，该API可以携带多个需要传给父组件的参数：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 子组件中的JavaScript代码片段setup(props, &#123; emit &#125;) &#123;    let currentIndex &#x3D; ref(0)    &#x2F;&#x2F; 当点击某一个选项卡时，把active类赋给它，并触发tabClick事件    const itemClick &#x3D; (index) &#x3D;&gt; &#123;        currentIndex.value &#x3D; index        emit(&#39;tabClick&#39;, index)    &#125;    return &#123;      currentIndex,      itemClick,    &#125;  &#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来把目光转移到父组件：</p><p>在父组件中，我们需要自定义上述事件（即自定义事件），并给该自定义事件绑定一个回调函数，它可以以参数形式接收子组件传来的数据：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;      ...      &lt;TabControl @tabClick&#x3D;&quot;tabClick&quot; :titles&#x3D;&quot;[&#39;畅销&#39;, &#39;新书&#39;, &#39;精选&#39;]&quot;&gt;&lt;&#x2F;TabControl&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;...export default &#123;    name: &#39;Home&#39;,    components: &#123;        NavBar,        Recommend,        TabControl,    &#125;,    setup() &#123;        ...        const tabClick &#x3D; (index) &#x3D;&gt; &#123;            console.log(index);        &#125;        return &#123;            ...,            tabClick,        &#125;    &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.banners img &#123;    width: 100%;    height: auto;    margin-top: 45px;&#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="首页选项卡数据切换"><a href="#首页选项卡数据切换" class="headerlink" title="首页选项卡数据切换"></a>首页选项卡数据切换</h2><p>首页组件（Home.vue）中获取后台数据涉及了三个接口，于是在首页组件中定义一个goods对象，用它保存首页选项卡三个选项各自对应的数据（畅销、新书、精选），而上面已经实现了子组件将被点击的选项序号传递给父组件，故在父组件中，只需要实现将对应的数据再传给子组件即可。</p><p>分析父组件的JavaScript代码块：</p><p>首先，有一个变量保存当前点击的选项卡内容；</p><p><code>let currentType = ref(&#39;sales&#39;)</code></p><p>我们把目光再次回到之前定义过的tabClick回调函数（点击选项卡时触发）：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const tabClick &#x3D; (index) &#x3D;&gt; &#123;  console.log(index)  let types &#x3D; [&#39;sales&#39;, &#39;new&#39;, &#39;recommend&#39;]  currentType.value &#x3D; types[index]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，这个tabClick函数就是Home父组件中自定义事件tabClick绑定的回调函数。</p><p>获取三个选项卡需要的后台数据，也即发送三个网络请求，并保存结果，当然在此之前，需要在network文件夹下的home.js文件中封装好相关的网络请求函数。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; network&#x2F;home.js&#x2F;&#x2F; 获取首页三个选项卡涉及的所有商品数据export function getHomeGoods(type&#x3D;&#39;sales&#39;, page&#x3D;1) &#123;    return request(&#123;        url: &#39;&#x2F;api&#x2F;index?&#39;+type+&#39;&#x3D;1&amp;page&#x3D;&#39;+page    &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来就可以在Home组件中使用了。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; Home.vue中的JavaScript代码&#x2F;&#x2F; 商品列表数据模型const goods &#x3D; reactive(&#123;  sales: &#123;    page: 0,    list: [],  &#125;,  new: &#123;    page: 0,    list: [],  &#125;,  recommend: &#123;    page: 0,    list: [],  &#125;,&#125;)&#x2F;&#x2F; 用于记录当前点击的选项卡内容let currentType &#x3D; ref(&#39;sales&#39;)&#x2F;&#x2F; 展示当前点击的选项卡的数据，发送给子组件const showGoods &#x3D; computed(() &#x3D;&gt; &#123;  return goods[currentType.value].list&#125;)onMounted(() &#x3D;&gt; &#123;  getHomeAllData().then((res) &#x3D;&gt; &#123;    recommends.value &#x3D; res.goods.data  &#125;)  &#x2F;&#x2F; 按销量排行  getHomeGoods(&#39;sales&#39;).then((res) &#x3D;&gt; &#123;    goods.sales.list &#x3D; res.goods.data  &#125;)  &#x2F;&#x2F; 按推荐排行  getHomeGoods(&#39;recommend&#39;).then((res) &#x3D;&gt; &#123;    goods.recommend.list &#x3D; res.goods.data  &#125;)  &#x2F;&#x2F; 按新品排行  getHomeGoods(&#39;new&#39;).then((res) &#x3D;&gt; &#123;    goods.new.list &#x3D; res.goods.data  &#125;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="上拉加载更多数据"><a href="#上拉加载更多数据" class="headerlink" title="上拉加载更多数据"></a>上拉加载更多数据</h2><p>需要用到移动端滚动条的第三方库——BetterScroll。</p><p>在首页的选项卡中，由于是移动端，不可能像PC端点击分页器获取更多数据，而是通过往上滑动，加载更多数据，因此，需要对滑动事件进行优化、处理（绑定网络请求）。Home组件的JavaScript代码如下：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F;   创建BetterScroll对象bscroll &#x3D; new BScroll(document.querySelector(&#39;.wrapper&#39;), &#123;  probeType: 3, &#x2F;&#x2F; 只要在运动，就触发scroll事件  click: true, &#x2F;&#x2F; 是否允许点击  pullUpLoad: true, &#x2F;&#x2F; 是否上拉加载更多，true为是&#125;)&#x2F;&#x2F;   绑定滚动的回调函数bscroll.on(&#39;scroll&#39;, (position) &#x3D;&gt; &#123;&#125;)&#x2F;&#x2F;   上拉加载数据，触发pullingUpbscroll.on(&#39;pullingUp&#39;, () &#x3D;&gt; &#123;  console.log(&#39;加载更多&#39;)  bscroll.refresh()&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="上拉情况下的导航条固定"><a href="#上拉情况下的导航条固定" class="headerlink" title="上拉情况下的导航条固定"></a>上拉情况下的导航条固定</h2><p>由于首页的选项卡组件使用了固定定位，但是这是当往下滑动时候的布局样式（一直往下滑动获取新的书籍信息时，此时选项卡固定在页面最上方），对此，我们单独再复制一份选项卡组件，使用v-show指定控制它的显示与否；而显示条件需要我们获取到临界高度，一旦大于这个高度时，就让组件固定展示。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; Home.vue中的JavaScript代码片段&#x2F;&#x2F; 控制选项卡是否被固定let isTabFixed &#x3D; ref(false)&#x2F;&#x2F;   绑定滚动的回调函数bscroll.on(&#39;scroll&#39;, (position) &#x3D;&gt; &#123;  isTabFixed.value &#x3D; -position.y&gt;banref.value.offsetHeight&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3+TypeScript项目实战自练</title>
      <link href="/mid-lake-pavilion.github.io/2022/03/01/Vue3-TypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%87%AA%E7%BB%83/"/>
      <url>/mid-lake-pavilion.github.io/2022/03/01/Vue3-TypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%87%AA%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h2 id="项目开启"><a href="#项目开启" class="headerlink" title="项目开启"></a>项目开启</h2><p>技术栈：Vite，Vue，TypeScript，Element UI Plus</p><p>开发工具：VScode</p><p>在项目中新建router文件夹，其下新建目录index.ts文件，内容如下：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">import &#123; createRouter, createWebHistory, RouteRecordRaw &#125; from &quot;vue-router&quot;import Layout from &#39;@&#x2F;components&#x2F;HelloWorld.vue&#39;const routes: Array&lt;RouteRecordRaw&gt; &#x3D; [    &#123;        path: &#39;&#x2F;&#39;,        name: &#39;home&#39;,        component: Layout,    &#125;]&#x2F;&#x2F; 创建const router &#x3D; createRouter(&#123;    history: createWebHistory(),    routes&#125;)export default router<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整合store"><a href="#整合store" class="headerlink" title="整合store"></a>整合store</h2><p>npm安装好vuex后，我们新建store文件夹，在该目录下新建index.ts文件，放入官网代码，进行测试。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; store.tsimport &#123; InjectionKey &#125; from &#39;vue&#39;import &#123; createStore, useStore as baseUseStore, Store &#125; from &#39;vuex&#39;export interface State &#123;  count: number&#125;export const key: InjectionKey&lt;Store&lt;State&gt;&gt; &#x3D; Symbol()export const store &#x3D; createStore&lt;State&gt;(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;      setCount(state: State, count: number) &#123;          state.count &#x3D; count      &#125;  &#125;,  getters: &#123;      getCount(state: State) &#123;          return state.count      &#125;  &#125;&#125;)&#x2F;&#x2F; 定义自己的 &#96;useStore&#96; 组合式函数export function useStore () &#123;  return baseUseStore(key)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了检验vuex的导入情况，我们在HelloWorld.vue中进行测试：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;import &#123; ref, computed &#125; from &#39;vue&#39;import &#123; useStore &#125; from &#39;..&#x2F;store&#39;&#x2F;&#x2F; 接收storeconst store &#x3D; useStore()&#x2F;&#x2F; 通过计算属性得到store中的count属性const showCount &#x3D; computed(() &#x3D;&gt; &#123;  return store.getters[&#39;getCount&#39;]&#125;)const addBtn &#x3D; () &#x3D;&gt; &#123;  store.commit(&#39;setCount&#39;, ++count.value)&#125;const count &#x3D; ref(0)&lt;&#x2F;script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; showCount &#125;&#125;&lt;&#x2F;h1&gt;  &lt;button type&#x3D;&quot;button&quot; @click&#x3D;&quot;addBtn&quot;&gt;新增&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="导入Element-Plus第三方组件库"><a href="#导入Element-Plus第三方组件库" class="headerlink" title="导入Element Plus第三方组件库"></a>导入Element Plus第三方组件库</h2><p>进入Element UI Plus官网，按照要求将其导入到项目中。</p><h2 id="页面总布局"><a href="#页面总布局" class="headerlink" title="页面总布局"></a>页面总布局</h2><p>在正式开始编写代码之前，首先点出一个setup语法糖：</p><p><code>&lt;script setup lang=&#39;ts&#39;&gt;</code></p><p>此处script标签中标记了setup，也就是</p><ul><li>不需要再return模板中所需要的数据项（数据、方法）了</li><li>引入的组件可以直接使用，无需再通过components进行注册了</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script lang&#x3D;&#39;ts&#39;&gt;const n: number &#x3D; ref(0)let name: string &#x3D; ref(&#39;张九龄&#39;)const sayHello &#x3D; () &#x3D;&gt; &#123;    console.log(&#39;Hello Vue!&#39;)&#125;...&#x2F;&#x2F; 需要将模板中用到的数据项暴露出来（return）return &#123;    n,    name,    ...,    sayHello,&#125;&lt;&#x2F;script&gt;&lt;script setup lang&#x3D;&#39;ts&#39;&gt;&#x2F;&#x2F; 这个script标签中的写法和上面的等价const n: number &#x3D; ref(0)let name: string &#x3D; ref(&#39;张九龄&#39;)const sayHello &#x3D; () &#x3D;&gt; &#123;    console.log(&#39;Hello Vue!&#39;)&#125;...&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们新建立一个layout文件夹，用于存放布局组件，在其下建立Index.vue文件，选好的布局包括头部、主体、边栏三部分，在ElementPlus官网将相关的代码段直接复用过来：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- layou --&gt;&lt;el-container&gt;  &lt;el-aside width&#x3D;&quot;200px&quot;&gt;Aside&lt;&#x2F;el-aside&gt;  &lt;el-container&gt;    &lt;el-header&gt;Header&lt;&#x2F;el-header&gt;    &lt;el-main&gt;Main&lt;&#x2F;el-main&gt;  &lt;&#x2F;el-container&gt;&lt;&#x2F;el-container&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="头部栏、导航栏的抽离"><a href="#头部栏、导航栏的抽离" class="headerlink" title="头部栏、导航栏的抽离"></a>头部栏、导航栏的抽离</h2><p>我们对已有的layout文件夹进行重构。目前该目录下仅有Index.vue文件，我们再新建一个header和一个menu文件夹，其中分别新建Header.vue和MenuBar.vue文件，用于分离该页面布局。</p><p>以MenuBar.vue文件为例，我们实现左侧的导航栏：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;el-menu    active-text-color&#x3D;&quot;#ffd04b&quot;    background-color&#x3D;&quot;#545c64&quot;    class&#x3D;&quot;el-menu-vertical-demo&quot;    default-active&#x3D;&quot;2&quot;    text-color&#x3D;&quot;#fff&quot;    @open&#x3D;&quot;handleOpen&quot;    @close&#x3D;&quot;handleClose&quot;  &gt;    &lt;el-sub-menu index&#x3D;&quot;1&quot;&gt;      &lt;template #title&gt;        &lt;el-icon&gt;&lt;location &#x2F;&gt;&lt;&#x2F;el-icon&gt;        &lt;span&gt;Navigator One&lt;&#x2F;span&gt;      &lt;&#x2F;template&gt;      &lt;el-menu-item-group title&#x3D;&quot;Group One&quot;&gt;        &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;item one&lt;&#x2F;el-menu-item&gt;        &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;item one&lt;&#x2F;el-menu-item&gt;      &lt;&#x2F;el-menu-item-group&gt;      &lt;el-menu-item-group title&#x3D;&quot;Group Two&quot;&gt;        &lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;item three&lt;&#x2F;el-menu-item&gt;      &lt;&#x2F;el-menu-item-group&gt;      &lt;el-sub-menu index&#x3D;&quot;1-4&quot;&gt;        &lt;template #title&gt;item four&lt;&#x2F;template&gt;        &lt;el-menu-item index&#x3D;&quot;1-4-1&quot;&gt;item one&lt;&#x2F;el-menu-item&gt;      &lt;&#x2F;el-sub-menu&gt;    &lt;&#x2F;el-sub-menu&gt;    &lt;el-menu-item index&#x3D;&quot;2&quot;&gt;      &lt;el-icon&gt;&lt;icon-menu &#x2F;&gt;&lt;&#x2F;el-icon&gt;      &lt;span&gt;Navigator Two&lt;&#x2F;span&gt;    &lt;&#x2F;el-menu-item&gt;    &lt;el-menu-item index&#x3D;&quot;3&quot; disabled&gt;      &lt;el-icon&gt;&lt;document &#x2F;&gt;&lt;&#x2F;el-icon&gt;      &lt;span&gt;Navigator Three&lt;&#x2F;span&gt;    &lt;&#x2F;el-menu-item&gt;    &lt;el-menu-item index&#x3D;&quot;4&quot;&gt;      &lt;el-icon&gt;&lt;setting &#x2F;&gt;&lt;&#x2F;el-icon&gt;      &lt;span&gt;Navigator Four&lt;&#x2F;span&gt;    &lt;&#x2F;el-menu-item&gt;  &lt;&#x2F;el-menu&gt;&lt;&#x2F;template&gt;&lt;script setup lang&#x3D;&quot;ts&quot;&gt;import &#123;  Location,  Document,  Menu as IconMenu,  Setting,&#125; from &#39;@element-plus&#x2F;icons-vue&#39;const handleOpen &#x3D; (key: string, keyPath: string[]) &#x3D;&gt; &#123;  console.log(key, keyPath)&#125;const handleClose &#x3D; (key: string, keyPath: string[]) &#x3D;&gt; &#123;  console.log(key, keyPath)&#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码阅读之虚拟VNode节点</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/14/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E8%99%9A%E6%8B%9FVNode%E8%8A%82%E7%82%B9/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/14/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E8%99%9A%E6%8B%9FVNode%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>由于虚拟VNode节点部分某些关键地方涉及到了JavaScript正则表达式，在此再度简单记录正则表达式的JavaScript版本。</p><h2 id="JavaScript的正则表达式"><a href="#JavaScript的正则表达式" class="headerlink" title="JavaScript的正则表达式"></a>JavaScript的正则表达式</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>与Python中的元字符类似，JavaScript也有元字符，它们是正则表达式中最基础的部分，理解、掌握了它们，就相当于掌握了正则表达式的一半。</p><h3 id="重要匹配方法"><a href="#重要匹配方法" class="headerlink" title="重要匹配方法"></a>重要匹配方法</h3><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>在设置了 global 或 sticky 标志位的情况下（如 /foo/g or /foo/y），JavaScript RegExp 对象是有状态的。他们会将上次成功匹配后的位置记录在 lastIndex 属性中。使用此特性，exec() 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配）。</p><p>正则表达式的lastIndex属性：记录了匹配成功的第一个元素下标。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../vue/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>            &#123;&#123; title &#125;&#125;        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>&#123;&#123; author &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#main'</span><span class="token punctuation">,</span>        <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'三国演义'</span><span class="token punctuation">,</span>                <span class="token literal-property property">author</span><span class="token operator">:</span> <span class="token string">'罗贯中'</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> defaultTagRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>    <span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div id="main">&lt;p>&#123;&#123; title &#125;&#125;&lt;/p>&lt;span>&#123;&#123; author &#125;&#125;&lt;/span>&lt;/div></span><span class="token template-punctuation string">`</span></span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>match <span class="token operator">=</span> defaultTagRE<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>defaultTagRE<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 匹配结果，是一个特殊的数组</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用while循环语句以及exec()，可以匹配出全部满足条件的字符串；</li><li>defaultTagRE是正则表达式，它被设置为全局，具有状态，可以利用它的lastIndex属性，获取上一次匹配成功时的起始字符下标，比如这里第一个匹配成功的是“Vue源码阅读之虚拟VNode节点”，从原字符串text的第19个字符开始，故第一轮循环的打印结果就是19。</li></ul><p>上述代码的控制台输出结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token number">29</span>(<span class="token number">2</span>) <span class="token punctuation">[</span>'<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> title <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>'<span class="token punctuation">,</span> ' title '<span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> input<span class="token operator">:</span> '&lt;div id=<span class="token string">"main"</span>>&lt;p><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> title <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>&lt;/p>&lt;span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> author <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>&lt;/span>&lt;/div>'<span class="token punctuation">,</span> groups<span class="token operator">:</span> undefined<span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> title <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token number">51</span>(<span class="token number">2</span>) <span class="token punctuation">[</span>'<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> author <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>'<span class="token punctuation">,</span> ' author '<span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token number">39</span><span class="token punctuation">,</span> input<span class="token operator">:</span> '&lt;div id=<span class="token string">"main"</span>>&lt;p><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> title <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>&lt;/p>&lt;span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> author <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>&lt;/span>&lt;/div>'<span class="token punctuation">,</span> groups<span class="token operator">:</span> undefined<span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> author <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="从HTML到真实DOM的大体流程"><a href="#从HTML到真实DOM的大体流程" class="headerlink" title="从HTML到真实DOM的大体流程"></a>从HTML到真实DOM的大体流程</h1><h2 id="AST语法树"><a href="#AST语法树" class="headerlink" title="AST语法树"></a>AST语法树</h2><p>AST树，即abstract syntax tree树，意为抽象语法树。经过generage过程，得到render函数，将返回Vue的虚拟DOM节点（包含标签名、子节点、文本信息等）。<br>比如下面这一句html语言，定义了一个input标签，是一个html表单元素：<br><code>&lt;input class=&quot;warn&quot; value=&quot;default text&quot; :style=&quot;innerStyle&quot;&gt;</code><br>解析后的AST节点：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">inputAstElm = <span class="token punctuation">&#123;</span>  type<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  tag<span class="token operator">:</span> 'input'<span class="token punctuation">,</span>  attrs<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"class"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">"\"warn\""</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"style"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">"innerStyle"</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  props<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">"\"default text\""</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从手写函数开始建立节点"><a href="#从手写函数开始建立节点" class="headerlink" title="从手写函数开始建立节点"></a>从手写函数开始建立节点</h2><p>我们希望通过调用这样的函数就可以创建一棵虚拟节点树（VNode）。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var ul &#x3D;    c(&#39;ul&#39;, [      c(&#39;li&#39;, [ t(&quot;Item 1&quot;) ]),      c(&#39;li&#39;, [ t(&quot;Item 2&quot;) ]),      c(&#39;li&#39;, [ t(&quot;Item 3&quot;) ])    ])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这其中需要用到JavaScript的正则表达式提取相关内容。细节参见源码注释。</p><p>在建立虚拟节点VNode之后，我们就可以通过VNode来间接管理DOM了——要做到这一点，我们还需要在两者之间建立关联：</p><ul><li><p>将当前建立的VNode渲染到DOM树上；</p></li><li><p>当VNode有更新时，DOM树也要相应地作出变化。</p><p>这其中涉及到了Vue中的<strong>diff算法</strong>。源码中由patch()函数总体控制对新旧VNode的更改：<code>patch(oldVnode, newVnode)</code>。</p><p>而要实现新旧VNode节点的更新，首先要做的是判断两者标签是否一致：如果两者连标签都不一样了，那么就需要相对较为复杂的操作——</p><ul><li>找到oldVnode对应的DOM节点以及父节点；</li><li>将当前newVnode渲染到原来的父节点下；</li><li>将旧的DOM节点移除。</li></ul><p>如果两者标签一致，那么就需要比较它们的子节点（children）了。为此，我们设置四个指针oldStartVnode、oldEndVnode、newStartVnode、oldEndVnode，用于指向oldVnode和newVnode的子节点开始、结束的位置。</p><p>然后就是四种情况了。</p></li></ul><h2 id="Compile编译字符串"><a href="#Compile编译字符串" class="headerlink" title="Compile编译字符串"></a>Compile编译字符串</h2><h3 id="从字符串到HTMLElement-Token流"><a href="#从字符串到HTMLElement-Token流" class="headerlink" title="从字符串到HTMLElement Token流"></a>从字符串到HTMLElement Token流</h3><p>但是相对于上面的手动调用函数，我们更希望一个函数能够解析html字符串，就比如这里的compile：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var html &#x3D;    &#96;&lt;ul&gt;      &lt;li&gt;Item 1&lt;&#x2F;li&gt;      &lt;li&gt;Item 2&lt;&#x2F;li&gt;      &lt;li&gt;Item 3&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&#96;var ul &#x3D; compile(html)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们以Token流的形式记录每一个html标签转换后的内容，它是一个列表：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">interface Attr &#123;name: string,value: any,&#125;interface StartToken &#123;tagName: string,attrs: Attr[],&#125;&#x2F;&#x2F; Token流形状interface Tokens &#123;startToken: StartToken,charsToken: string,endToken: any,&#125;&#x2F;&#x2F; 也即：tokens: &#x3D; [StartToken: &#123;tagName: &#39;&#39;,attrs: [&#123;name: &#39;&#39;,value: &#39;&#39;,&#125;,...]&#125;,StartToken: &#123;&#125;,...,CharsToken: &#39;&#39;,...,endToken,...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>StartToken表示开始标签<br>EndToken表示结束标签<br>CharsToken表示文本节点</p><p>其中的解析（parse）过程就是一个类似括号匹配问题的栈的实际应用：</p><p>设置一个栈，用于管理字符串，当标签匹配的时候就把栈顶元素弹出，否则入栈；同时将解析出来的标签转化为Token计入Tokens流。</p><p><a href="https://github.com/raphealguo/how-to-learn-vue2-blob/raw/master/figure/1.2/str2tokens.png">https://github.com/raphealguo/how-to-learn-vue2-blob/raw/master/figure/1.2/str2tokens.png</a></p><h3 id="从HTMLElement-Token流到AST树"><a href="#从HTMLElement-Token流到AST树" class="headerlink" title="从HTMLElement Token流到AST树"></a>从HTMLElement Token流到AST树</h3><p>拿到tokens序列后，我们可以构建AST树节点。AST树节点形状大致如下：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">tagAstElement &#x3D; &#123;type: number,tag: string,attrsList,attrsMap,children,parent,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们构建一棵AST树，也需要一个栈stack，记录所有的父节点，同时定义一个指向栈顶的指针currentParent：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let stack &#x3D; []let currentParent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在源码中，处理Tokens流，得到AST树的函数parse()中，在其中的parseHTML()参数中定义了三个函数：</p><ul><li>start，处理开始标签流</li><li>end，处理结束标签流</li><li>chars，处理文本标签流</li></ul><p>在处理开始标签流时，需要将上面的Tokens中的数据项往AST树的数据项转化。另外，由于AST树包含了节点之间的父子关系，因此在处理开始标签流时，需要判断它是否是单标签，如果不是单标签，就表示该标签之间还可以嵌套其他的标签，该标签也可以作为父节点；因此，该标签需要入栈stack，并且currentParent指针指向栈顶元素——该标签：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">if (!unary) &#123;     &#x2F;&#x2F; 如果不是单标签，则当前节点记为父节点，并压入堆栈    currentParent &#x3D; element    stack.push(element)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在处理结束标签流时，同样的道理，需要弹栈：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 标签闭合，栈顶元素弹出，长度减一，当前父节点指针currentParent指向最新的栈顶元素stack.length -&#x3D; 1currentParent &#x3D; stack[stack.length - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="从AST树到VNode树"><a href="#从AST树到VNode树" class="headerlink" title="从AST树到VNode树"></a>从AST树到VNode树</h3><p>将已经生成的AST节点转化为VNode的方法如下：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">_c (tag, data, children) 创建一个非文本 VNode 节点_v (text) 创建一个文本VNode节点_s (exp) 把 exp 输出成字符串_e() 创建一个空的 VNode_l (list, render) 渲染一个 VNode 列表_k(eventKeyCode, key, builtInAlias) 判定当前事件的按键是否为预期按键值，builtInAlias &#x3D;&#x3D; eventKeyCode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>VNode节点形状如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">VNode <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span><span class="token comment">// 标签名</span><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 标签的属性</span>        <span class="token literal-property property">domProps</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"value"</span><span class="token operator">:</span> <span class="token string">"default text"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际的源码中，实现了逐步封装（见/compiler/codegen/index.js文件）</p><ul><li><p><code>generate: (ast: any) =&gt; obj</code>，这个函数是最外层的函数，接收传入的ast树，并将其挂载到当前的vm实例对象，用于生成一棵VNode树。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">export function generate(ast) &#123;  const code &#x3D; ast ? genElement(ast) : &#39;_c(&quot;div&quot;)&#39;  return &#123;    render: (&quot;with(this)&#123;return &quot; + code + &quot;&#125;&quot;)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>genElement: (el: any) =&gt; string</code>，接下来把目光转移到第二层函数，它用于生成具体执行的代码语句（字符串格式）。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function genElement(el) &#123;  if (el.for &amp;&amp; !el.forProcessed) &#123; &#x2F;&#x2F; 为了v-for和v-if的优先级： &lt;ul v-for&#x3D;&quot;(item, index) in list&quot; v-if&#x3D;&quot;index&#x3D;&#x3D;0&quot;&gt;，需要先处理for语句    return genFor(el)  &#125;  if (el.if &amp;&amp; !el.ifProcessed) &#123;    return genIf(el)  &#125; else &#123;    let code    const children &#x3D; genChildren(el) || &#39;[]&#39;    const data &#x3D; genData(el)    code &#x3D; &#96;_c(&#39;$&#123;el.tag&#125;&#39;$&#123;      children ? &#96;,$&#123;children&#125;&#96; : &#39;&#39; &#x2F;&#x2F; children    &#125;)&#96;    return code  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难发现，这一层函数其实也没做多少事，关键还得看genFor、genIf、genChildren、genData这几个打工人（它们生成了模板字符串中的模板变量，也就是el上缺省的属性值el.tag, el.children, el.data）。</p></li><li><p><code>genData: (el: any) =&gt; string</code>, 我们先来看看分量最重的data子选项。genData用于得到data，而data包含了el的很多属性，如el.key, el.attrs, el.props, el.event等，其中，el.attrs、el.props、el.events相对较复杂，因此又套了一层函数。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function genData(el) &#123;  let data &#x3D; &#39;&#123;&#39;  &#x2F;&#x2F; key  if (el.key) &#123;    data +&#x3D; &#96;key:$&#123;el.key&#125;,&#96;  &#125;  if (el.attrs) &#123;    data +&#x3D; &#96;attrs:&#123;$&#123;genProps(el.attrs)&#125;&#125;,&#96;  &#125;  &#x2F;&#x2F; DOM props  if (el.props) &#123;    data +&#x3D; &#96;domProps:&#123;$&#123;genProps(el.props)&#125;&#125;,&#96;  &#125;  &#x2F;&#x2F; event handlers  if (el.events) &#123;    data +&#x3D; &#96;$&#123;genHandlers(el.events)&#125;,&#96;  &#125;  &#x2F;&#x2F; class  if (el.staticClass) &#123;    data +&#x3D; &#96;staticClass:$&#123;el.staticClass&#125;,&#96;  &#125;  if (el.classBinding) &#123;    data +&#x3D; &#96;class:$&#123;el.classBinding&#125;,&#96;  &#125;  data &#x3D; data.replace(&#x2F;,$&#x2F;, &#39;&#39;) + &#39;&#125;&#39;  return data&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>genProps: (props: []) =&gt; string</code>, 这个函数用于将props配置项数组的每一项转为字符串键值对，然后全部拼接起来，并返回。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function genProps(props) &#123;  let res &#x3D; &#39;&#39;  for (let i &#x3D; 0; i &lt; props.length; i++) &#123;    const prop &#x3D; props[i]    res +&#x3D; &#96;&quot;$&#123;prop.name&#125;&quot;:$&#123;prop.value&#125;,&#96;  &#125;  return res.slice(0, -1) &#x2F;&#x2F; 去掉尾巴的逗号&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>_c()方法可以生成一个VNode，从而实现AST到VNode的过程。</p><h3 id="从VNode树到DOM树"><a href="#从VNode树到DOM树" class="headerlink" title="从VNode树到DOM树"></a>从VNode树到DOM树</h3><p>经历了patch(vnode)函数，此时在真实的DOM上处理UI渲染、事件监听等。</p><h2 id="用一个栗子做个总结"><a href="#用一个栗子做个总结" class="headerlink" title="用一个栗子做个总结"></a>用一个栗子做个总结</h2><ol><li><p>原始字符串如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>warn<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>default text<span class="token punctuation">"</span></span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>innerStyle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>对原始字符串进行解析，得到Token流</p></li><li><p>将Tokens流转为AST：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">inputAstElm &#x3D; &#123;    type: 1,&#x2F;&#x2F; 表示类型    tag: &#39;input&#39;,&#x2F;&#x2F; 表示html元素标签    attrs: [&#x2F;&#x2F; 表示属性        &#123;name: &#39;class&#39;, value: &quot;&#39;warn&#39;&quot;&#125;,        &#123;name: &#39;style&#39;, value: &quot;innerStyle&quot;&#125;    ],    props: [&#123; name: &quot;value&quot;, value: &quot;&#39;default text&#39;&quot; &#125;],&#x2F;&#x2F; 表示属性&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>经过上面提过的render函数得到VNode：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"class"</span><span class="token operator">:</span> <span class="token string">"warn"</span><span class="token punctuation">,</span> <span class="token string-property property">"style"</span><span class="token operator">:</span> innerStyle <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">domProps</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"value"</span><span class="token operator">:</span> <span class="token string">"default text"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">VNode <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">'input'</span><span class="token punctuation">,</span>    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"class"</span><span class="token operator">:</span> <span class="token string">"warn"</span><span class="token punctuation">,</span> <span class="token string-property property">"style"</span><span class="token operator">:</span> <span class="token string">"vm.innerStyle运行后的值"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token literal-property property">domProps</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token string-property property">"value"</span><span class="token operator">:</span> <span class="token string">"default text"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后一步，将虚拟VNode渲染到真实DOM</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">inputDom.setAttribute(&#39;class&#39;, &#39;warn&#39;)inputDom.setAttribute(&#39;style&#39;, &#39;vm.innerStyle运行后的值&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码阅读之数据响应式</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/12/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/12/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在Vue源码中，数据的响应式原理是一个重点。此外，vue使用了观察者模式，在源码中体现为</p><ul><li>Observer：发布者</li><li>Dep：依赖，联系发布者与订阅者的纽带</li><li>Watcher：订阅者</li></ul><p>其中，Observer是发布者，用于监视数据的读写对应的index.js文件中，实现了数据劫持。而数据劫持的关键，在于使用ES5的Object.defineProperty()重写属性的getter/setter:</p><ol><li>getter中实现依赖收集<br>所谓依赖，就是vue会在组件渲染的过程中把“接触”（也就是读取数据，触发其get函数）过的数据属性记录为依赖（此为依赖收集），方便后续组件的更新。</li></ol><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; index.jsget: function reactiveGetter() &#123;      const value &#x3D; getter ? getter.call(obj) : val      if (Dep.target) &#123;        &#x2F;&#x2F; getA发生的时候，Dep.target &#x3D;&#x3D; DepM        dep.depend() &#x2F;&#x2F; 这一句为关键        if (childOb) &#123;          childOb.dep.depend()        &#125;        if (Array.isArray(value)) &#123;          dependArray(value)        &#125;      &#125;      return val    &#125;,    &#x2F;&#x2F; dep.js  &#x2F;**   * Dep类中函数depend，调用Dep.target中存放的Watcher实例的addDep方法   *&#x2F;  depend () &#123;    if (Dep.target) &#123;      Dep.target.addDep(this)    &#125;  &#125;  &#x2F;&#x2F; watcher.js  &#x2F;**   * 添加依赖，即订阅Dep，同时让Dep知道该Watcher订阅着它   * @param &#123;Dep&#125; dep    *&#x2F;  addDep (dep) &#123;    const id &#x3D; dep.id    if (!this.newDepIds.has(id)) &#123;      this.newDepIds.add(id)      this.newDeps.push(dep) &#x2F;&#x2F; WatcherM.deps.push(DepA) &#x2F;&#x2F; WatcherM.deps &#x3D; [DepA, DepB]      if (!this.depIds.has(id)) &#123;        &#x2F;&#x2F; 收集订阅者Watcher        dep.addSub(this)  &#x2F;&#x2F;  DepA.subs.push(WatcherM) &#x2F;&#x2F; DepA.subs &#x3D; [WatcherM, WatcherN, WatcherX]      &#125;    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>setter中实现分发更新<br>当依赖项的setter触发时，会通知watcher，从而使它关联的组件重新渲染（此为分发更新）。</li></ol><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">set: function reactiveSetter(newVal) &#123;  const value &#x3D; val  if (newVal &#x3D;&#x3D;&#x3D; value) &#123;    return  &#125;  &#x2F;&#x2F; console.log(&quot;newVal &#x3D; &quot;, newVal)  val &#x3D; newVal  childOb &#x3D; observe(newVal)  &#x2F;&#x2F; 通过dep依赖告知更新  dep.notify()&#x2F;&#x2F; 这一句为关键  &#x2F;&#x2F; vm._update at core&#x2F;instance&#x2F;index.js&#125;&#x2F;&#x2F; dep.jsnotify () &#123;    &#x2F;&#x2F; 广播，当劫持到数据变更时，通知订阅者Watcher进行update    const subs &#x3D; this.subs.slice()    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;&#125;&#x2F;&#x2F; watcher.js  update () &#123;    if (this.lazy) &#123;      this.dirty &#x3D; true    &#125; else &#123;      this.run()    &#125;  &#125;  run () &#123;    if (this.active) &#123;      const value &#x3D; this.get()      if (        value !&#x3D;&#x3D; this.value ||        isObject(value)      ) &#123;        &#x2F;&#x2F; set new value        const oldValue &#x3D; this.value        this.value &#x3D; value        this.cb.call(this.vm, value, oldValue)      &#125;    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下为Observer/index.js中的代码，是Observer类的构造函数的一个代码片段：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">this.value &#x3D; valuethis.dep &#x3D; new Dep()&#x2F;&#x2F; 把当前Observer对象 绑定在value.__ob__上，作为该数据对象已经被Observer观察的标识&#x2F;&#x2F; this代指Observer类def(value, &#39;__ob__&#39;, this)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该Observer实例对象被绑定到了vue实例上，并作为属性‘<strong>ob</strong>‘，我们还可以发现，该Observer实例对象还有成员dep（依赖对象实例），因此我们再到dep.js文件中看看Dep类。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">constructor () &#123;this.id &#x3D; uid++&#x2F;**subs: Watcher[]，依赖列表，用于收集订阅者Watcher *&#x2F;this.subs &#x3D; []&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是Dep类的构造函数，由于依赖项需要通知Watcher更新组件，那么就需要记录与其绑定的Watcher，这里的成员id是该dep的唯一区分标识，而subs用于记录与其相关的订阅者Watcher。</p><p>我们自己简单地写一个数据响应式：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 订阅者Watcher类class Watcher &#123;    constructor(name) &#123;        this.name &#x3D; name    &#125;    &#x2F;&#x2F; 值变化时调用的方法    update(str) &#123;        console.log(&#96;$&#123;this.name&#125;发生了update.&#96;);        this.name &#x3D; str        console.log(this.name);    &#125;&#125;&#x2F;&#x2F; 发布者Dep类class Dep &#123;    constructor() &#123;        this.subs &#x3D; []    &#125;    &#x2F;&#x2F; 添加Watcher    addSub(watcher) &#123;        this.subs.push(watcher)    &#125;    &#x2F;&#x2F; 遍历订阅者列表中的所有订阅者    notify(str) &#123;        this.subs.forEach(item &#x3D;&gt; &#123;            &#x2F;&#x2F; item是订阅者Watcher            item.update(str)        &#125;)    &#125;&#125;const w1 &#x3D; new Watcher(&#39;张三&#39;)const w2 &#x3D; new Watcher(&#39;李四&#39;)const w3 &#x3D; new Watcher(&#39;王五&#39;)const dep &#x3D; new Dep()dep.addSub(w1)dep.addSub(w2)dep.addSub(w3)dep.notify(&#39;赵六&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在上面这个简单的栗子中，我们定义了三个订阅者w1, w2, w3，一个发布者dep</li><li>对于订阅者，我们订阅（监视）的是name属性</li><li>对于发布者Dep，我们可以向其订阅者列表中添加订阅者w1, w2, w3，dep.addSub()</li><li>一旦发布者有新内容要发布，就会通知（notify）其订阅者新内容（订阅对象）</li><li>上面的通知notify也就是遍历订阅者列表，调用每一个订阅者自身的update()更新方法</li></ul><p>上面的逻辑初步体现了vue中的数据响应式逻辑，但是还有很多细节，包括Dep何时调用notify()方法，还需要根据源码进一步分析。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES新特性2</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/11/ES%E6%96%B0%E7%89%B9%E6%80%A72/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/11/ES%E6%96%B0%E7%89%B9%E6%80%A72/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise的出现，是对异步处理的优化、也是对回调地狱的避免。</p><blockquote><p>虽然JavaScript本身是单线程的，但是有一些操作可以开启新线程，比如回调函数。换言之，JavaScript一方面从上往下按照语句顺序依次执行，一旦遇上回调函数，就会另外开启一个线程，这个线程中也开始从回调函数最上方往下依次执行，而另一边，并不会等待该回调函数执行完毕，而是直接往下执行JavaScript语句。</p></blockquote><p>有时候我们需要另外新开启的线程的返回数据，将其作为另一个线程的变量，进行处理，这样一来就需要异步操作，最原始的做法，就是编写回调函数，但是一旦异步操作变多，回调函数嵌套加深，就会带来一个很复杂的链式代码块——回调地狱，其代码逻辑可谓“乱花渐欲迷人眼”，debug起来也是自讨苦吃。</p><h3 id="Promise写法简介"><a href="#Promise写法简介" class="headerlink" title="Promise写法简介"></a>Promise写法简介</h3><p>Promise就是一种新写法：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;    resolve(&#39;Lairucy is awesome!&#39;)&#125;)p.then(data &#x3D;&gt; &#123;    console.log(data);&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个简洁的栗子中，Promise()构造函数可以接收一个回调函数作为参数，这个回调函数自身有俩参数，通常记作resolve、reject：</p><ul><li>resolve函数用于将Promise对象的状态变为“成功”</li><li>reject函数用于将Promise对象的状态变为“失败”</li></ul><h3 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then()"></a>Promise.then()</h3><p>Promise对象的then()方法是对回调函数的优化，是在Promise对象为成功状态下的进一步处理；换言之，上面的栗子中，再构造函数内部，resolve函数接收了字符串参数，就会将状态变成“成功”，而then()方法就会触发，并且data即为传入的字符串参数。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>proxy，代理，也就是给对象进行一番“修改”，一般用作改变对象原有的属性、逻辑，功能类似于拦截器、预处理。</p><p><code>const personProxy = new Proxy(target, handler)</code><br>target是原对象，handler是处理函数，在handler中，我们可以任意修改target对象上的属性。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const person &#x3D; &#123;    name: &#39;Huxinting&#39;,    age: 999&#125;const personProxy &#x3D; new Proxy(person, &#123;    &#x2F;&#x2F; get(),当原对象被读取时，自动调用    get(target, key) &#123;        console.log(&#39;someone ask for&#39;, target, key)        &#x2F;&#x2F; 返回读取的结果为属性值大写        return target[key].toUpperCase()    &#125;,    &#x2F;&#x2F; set(), 当原对象被写（修改）时，自动调用    set(target, key, value) &#123;        &#x2F;&#x2F; 表示如果要将target对象的key属性的value值修改为一个字符串，就会自动去除其中的空白符        if(typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;            target[key] &#x3D; value.trim()        &#125;    &#125;&#125;)personProxy.name &#x3D; &#39;Luqing     &#39;console.log(personProxy);&#x2F;**&#123; name: &#39;Luqing&#39;, age: 999 &#125; * Luqing后面的空白符全部去除 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="再谈JavaScript原型特性"><a href="#再谈JavaScript原型特性" class="headerlink" title="再谈JavaScript原型特性"></a>再谈JavaScript原型特性</h2><p>这并不是ES的新特性，只不过，这个知识点很重要，关联了很多其他的知识和新特性，不得不再次学习。</p><blockquote><p>为了学好JavaScript的原型，我们首先还是从熟悉的传统OOP讲起。在C++、Java等传统OOP语言中，都是先定义class（类），再根据类创建出实例对象，此时，class中定义的所有属性、方法就会被复制到实例对象中。然而，JavaScript中却并不是这样做的。</p></blockquote><p>在JavaScript中，对象实例创建时，它会和其创造器之间建立一个链接（也就是对象实例的<strong>proto</strong>属性，派生于构造函数的prototype）<br>也就是说——</p><ul><li>构造函数的prototype实际上就是对象实例的<strong>proto</strong>对象</li><li>构造函数的prototype存储的所有属性、方法，都可以被继承者使用</li><li>每一个实例对象都聪原型中继承了constructor属性，该属性指向了用于创建此实例对象的构造函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES新特性1</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/10/ES%E6%96%B0%E7%89%B9%E6%80%A71/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/10/ES%E6%96%B0%E7%89%B9%E6%80%A71/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>使用反引号的特殊字符串，用法较一般字符串更加方便、功能强大，支持变量替换、换行等等。</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><blockquote><ol><li>一般语法格式</li><li>let 关键字声明的变量的解构赋值需要提供括号</li><li>解构赋值可以嵌套</li><li>解构赋值中可以实现变量名的替换</li><li>回退机制</li></ol></blockquote><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><blockquote><ol><li>一般语法格式</li><li>缺省元素要空出</li><li>…others表示剩余全部</li><li>数组解构可以方便地用于变量值的交换</li></ol></blockquote><h2 id="四种循环遍历"><a href="#四种循环遍历" class="headerlink" title="四种循环遍历"></a>四种循环遍历</h2><ul><li>普通的for循环</li><li>数组的forEach</li><li>对象的for…in</li><li>数组的for…of</li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let fruits &#x3D; [&#39;apple&#39;, &#39;mongo&#39;, &#39;peach&#39;, &#39;banana&#39;, &#39;strawberry&#39;]console.log(&#39;普通for循环&#39;);for(let i&#x3D;0; i&lt;fruits.length; i++) &#123;    console.log(fruits[i]);&#125;&#x2F;&#x2F; forEach循环是遍历每一个元素，但是不支持break、continueconsole.log(&#39;forEach循环&#39;);fruits.forEach(fruit &#x3D;&gt; &#123;    console.log(fruit);&#125;)&#x2F;&#x2F; for in 循环获取的是数组的属性，并且是遍历数组对象的可枚举属性，通过下标获取可枚举属性值console.log(&#39;for in循环&#39;);for(let index in fruits) &#123;    console.log(fruits[index]);&#125;&#x2F;&#x2F; for of循环可以获取每一个元素，并且支持break、continueconsole.log(&#39;for of循环&#39;);for(let fruit of fruits) &#123;    console.log(fruit);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>for…of循环在可迭代对象上创建迭代循环，其中可迭代对象包括：<br>Array、String、Map（键值对）、Set（集合）等。</p><p>使用<br><code>for ele of obj.entries()</code>,<br>则ele是数组类型（类似map），第一个值为下标，第二个值为元素。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const celes &#x3D; [&#39;徐阶&#39;, &#39;陆炳&#39;, &#39;高拱&#39;]for(let ele of celes) &#123;    console.log(ele);&#125;&#x2F;*徐阶陆炳高拱*&#x2F;for(let ele of celes.entries()) &#123;    console.log(ele);&#125;&#x2F;*[ 0, &#39;徐阶&#39; ][ 1, &#39;陆炳&#39; ][ 2, &#39;高拱&#39; ]*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在后一种写法中，我们甚至可以使用解构赋值获取元素和其下标：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">for(let [index, person] of celes.entries()) &#123;    console.log(index, person);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>常用：</p><ul><li>接收函数参数作为数组</li><li>数组的解构赋值</li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 此处的...numbers就是剩余参数写法function sum(...numbers) &#123;    &#x2F;&#x2F; Array.reduce(callback(accumulator, currentValue[, index, array])[, initialValue])    &#x2F;&#x2F; accumulator: 累计器，上一次调用callback回调返回的累积值    &#x2F;&#x2F; currentValue: 数组中正在处理的元素    &#x2F;&#x2F; index: 数组中正在处理的元素的索引    &#x2F;&#x2F; array: 正在处理的数组    &#x2F;&#x2F; initialValue: 第一次调用callback回调时的第一个参数值，默认为array数组的第一个元素    return numbers.reduce((prev, curr) &#x3D;&gt; prev + curr)&#125;console.log(sum(1, 2, 3, 4, 5));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/10/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/10/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a>宏观视角下的浏览器</h2><p>浏览器最开始是美国网景公司开发的，自诞生之日起，地位一直只增不减。</p><blockquote><p>C/S    client、server，即客户端、服务端<br>B/S    browser、server，即浏览器、服务端</p></blockquote><h3 id="浏览器工作原理重要性"><a href="#浏览器工作原理重要性" class="headerlink" title="浏览器工作原理重要性"></a>浏览器工作原理重要性</h3><ol><li>了解浏览器如何工作，能够让我们更准确地决策是否可以采用Web来开发项目</li><li>站在更高的角度审视前端页面</li><li>在技术快速迭代的时代把握本质</li></ol><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程：就是内存中正在运行的应用程序，包括如下特点：</p><ul><li>进程在内存中独占一个内存空间</li><li>进程与进程之间是隔离的，比如手机玩王者荣耀（进程），如果王者荣耀崩溃了，这个进程就终止了，但是手机中的其他应用（比如微信）不会受到影响（进程之间隔离）</li></ul><p>线程：进程的最小执行单位。它也有一定的特点：</p><ul><li>一个进程是由多个线程组成的</li><li>每一个线程之间也是相互隔离的（比如微信可以和多个人聊天，也互不干扰）</li></ul><p>一个页面启动的时候，至少启动了4个进程：</p><ul><li>浏览器主进程</li><li>渲染进程</li><li>网络进程</li><li>GPU进程</li></ul><p>如果安装了插件，还会运行插件进程。<br>下面逐个简介这些进程：</p><ul><li>浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能；</li><li>渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中；</li><li>网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，现在已经独立成为单独一个进程；</li><li>GPU进程：GPU，即图像处理单元，其使用初衷是为了实现3D、CSS的效果，后来网页等界面都采用了GPU来绘制。</li><li>插件进程：主要负责插件运行，由于插件容易崩溃，于是该进程与其他进程隔离开来，防止插件的崩溃影响到浏览器和页面。</li></ul><h2 id="计算机网络的七层模型"><a href="#计算机网络的七层模型" class="headerlink" title="计算机网络的七层模型"></a>计算机网络的七层模型</h2><p>从下往上的顺序为：</p><ol><li>物理层：使用一定的物理介质来进行计算机之间的连接，以电信号0、1进行传输；</li><li>数据链路层：MAC地址，对物理层的0、1信号进行封装，封装成比特；</li><li>网络层：IP地址</li><li>传输层：涉及UDP（用户数据包协议）/TCP（传输控制协议）</li><li>会话层：断点续传</li><li>表示层：解决不同系统之间数据传输的问题</li><li>应用层：HTTP</li></ol><blockquote><p>UDP：只管发，不管收<br>TCP：具有重传机制、排序机制</p></blockquote><p>也可以表示为四层：</p><ul><li>物理层：物理层、数据链路层</li><li>网络层</li><li>传输层</li><li>应用层：会话层、表示层、应用层</li></ul><h2 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h2><p>浏览器发送HTTP请求的大致请求流程如下：</p><ol><li>构造请求行</li><li>查找缓存</li><li>准备IP地址和端口号</li><li>等待TCP队列，一个域名最多只能和建立6个TCP连接</li><li>建立TCP连接</li><li>发送HTTP请求</li></ol><p>服务器处理HTTP请求的流程：</p><ol><li>返回请求内容</li><li>断开连接</li></ol><h2 id="从进程角度看浏览器"><a href="#从进程角度看浏览器" class="headerlink" title="从进程角度看浏览器"></a>从进程角度看浏览器</h2><p>从用户在url地址栏到浏览器显示页面，这个过程中到底发生了什么。<br>主要涉及了浏览器主进程、网络进程、渲染进程。</p><ol><li>用户在浏览器主进程中输入url地址；</li><li>浏览器主进程将url请求派发给网络进程；</li><li>在网络进程中，发送url请求，获取响应头数据，解析响应头数据；</li><li>网络进程将解析出来的数据转发给浏览器主进程；</li><li>浏览器主进程接收到网络进程的响应数据，发送“提交文档”（HTML数据）消息给渲染进程；</li><li>在渲染进程中，接收到消息之后，准备接收HTML数据，接收数据的方式是直接和网络进程之间建立数据管道。</li><li>文档数据传输完毕，渲染进程将会返回“确认提交”消息给浏览器主进程。</li><li>在浏览器主进程中，收到渲染进程后“确认提交”消息后，便开始移除旧文档，更新浏览器进程状态。</li></ol><h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h2><p>以一个很简单的.html文件为例，进行说明：</p><ol><li>构建DOM树——使用html解析器（ParseHTML）将html页面转化为浏览器能够理解的DOM树；<br>因为浏览器无法直接理解和使用html，因此需要将html转化为浏览器能够理解的结构——DOM树。</li><li>将css解析成浏览器能够识别的CSS树</li><li>样式计算</li><li>由DOM树、CSS树得到布局树</li><li>根据布局树生成图层树（只有某些具有特殊属性的节点才会单独占据一个图层）</li><li>绘制</li><li>组合图层，生成最终的页面<blockquote><p>图层：在html页面中，虽然网页是二维的，但是实际上相当于一个“俯视图”，也就是说，实际上是存在“图层”的，以下html元素可以作为一个单独的图层：</p><ol><li>具有3d效果的元素</li><li>fixed固定定位的元素</li><li>视频播放元素video</li><li>绘图画板canvas</li><li>css动画节点</li></ol></blockquote></li></ol><p>浏览器每次最多可以接收64Kb资源。</p><h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><p>图层是在布局的基础上,为了进一步显示一些复杂的3D变换、页面滚动等效果，也产生的一种渲染结果。</p><h3 id="哪些节点会被渲染为新的层"><a href="#哪些节点会被渲染为新的层" class="headerlink" title="哪些节点会被渲染为新的层"></a>哪些节点会被渲染为新的层</h3><p>当然了，并不是布局树的每一个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。以下两种情况的节点会被单独提升为一个图层：</p><ol><li>拥有层叠上下文属性的元素<br>比如，fixed固定定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等。</li><li>需要剪裁（clip）的地方也会被创建为图层。</li></ol><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><h4 id="得到绘制列表"><a href="#得到绘制列表" class="headerlink" title="得到绘制列表"></a>得到绘制列表</h4><p>图层树构建完成后，渲染引擎会对图层树中的每一个图层进行绘制，大体步骤是把每一个图层的绘制拆分成很多个小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表，称为绘制列表。</p><blockquote><p>在浏览器开发者工具的Layers（图层）选项中，可以清楚地看到，当点击一个图层进行分析，会出现诸如drawRect、drawPaint等小绘制指令。</p></blockquote><p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，也就是说，接下来的工作将由合成线程完成。</p><h4 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h4><p>合成线程并不会一下子绘制出所有图层内容，因为这样花销太大。它转而会将图层划分为图块（tile，是栅格化执行的最小单位），并且按照视口附近的图块来优先生成位图。<br>所谓栅格化，就是将图块转换为位图，会在线程池内执行，该线程池称为栅格化线程池。</p><h4 id="合成、显示"><a href="#合成、显示" class="headerlink" title="合成、显示"></a>合成、显示</h4><p>上述提到的栅格化如果对所有图块都进行完毕，合成线程就会生成一个绘制图块的命令——DrawQuad，然后将该命令提交给浏览器进程，由其中的viz组件接收命令，将页面内容绘制到内存中，最后将内存显示在屏幕上。</p><h3 id="重排、重绘、合成"><a href="#重排、重绘、合成" class="headerlink" title="重排、重绘、合成"></a>重排、重绘、合成</h3><p>在厘清这三者之前，我们首先强调浏览器渲染流水线：</p><ol><li>DOM（生成浏览器可以识别的DOM树）</li><li>Style（生成CSS树、样式计算）</li><li>Layout（得到布局树）</li><li>Layer（得到图层树）</li><li>Paint（绘制）</li><li>合成操作</li></ol><p>上述1~5都是需要主线程参与的，而只有最后一步合成不需要主线程参与，需要非主线程（合成线程）参与。</p><h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>如果，我们通过JavaScript或者CSS修改元素几何位置属性，比如改变元素宽度、高度等，会引发浏览器重新布局——此之谓“重排”。<br>重排需要更新完整的渲染流水线，所以开销很大。</p><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>现在情况变了，我们通过JavaScript更改某些元素的背景颜色，很显然，由于几何位置不变，布局不会受到影响，因此渲染流水线中的Layout（布局）阶段不会重新进行，而是直接进入绘制（Paint）阶段，然后再执行其子阶段——此之谓“重绘”。<br>相较于重排，重绘省去了布局和分层阶段，所以执行效率会比重排操作更高一些。</p><h4 id="合成（直接合成）"><a href="#合成（直接合成）" class="headerlink" title="合成（直接合成）"></a>合成（直接合成）</h4><p>也即跳过了渲染流水线的布局、绘制，只执行后续合成操作——此之谓“合成”。<br>相比于重排、重绘，合成可以大大提高绘制效率，因为它根本没有占用主线程的资源。</p><h2 id="浏览器中JavaScript的执行"><a href="#浏览器中JavaScript的执行" class="headerlink" title="浏览器中JavaScript的执行"></a>浏览器中JavaScript的执行</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>首先我们需要明白的是，在JavaScript中何为声明，何为赋值。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var myName &#x3D; &#39;奇异博士&#39;&#x2F;&#x2F; 上面的语句等价于两句，声明、赋值分离开来写为var myNamemyName &#x3D; &#39;奇异博士&#39;&#x2F;&#x2F; 以下是一个完整的函数声明function foo() &#123;console.log(&#39;foo&#39;)&#125;&#x2F;&#x2F; 以下是一个变量声明、赋值，只不过赋值了一个函数var hello &#x3D; function () &#123;console.log(&#39;hello!&#39;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，我们可以得到变量提升的定义：<br>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p><h4 id="何为执行上下文"><a href="#何为执行上下文" class="headerlink" title="何为执行上下文"></a>何为执行上下文</h4><p>我们从如下一段JavaScript代码分析起：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">showName()console.log(myName)var myName &#x3D; &#39;朱由榔&#39;function showName() &#123;console.log(&#39;showName被调用!&#39;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在经过浏览器的JavaScript引擎的编译后，会生成两部分内容：</p><ul><li>执行上下文（Execution context）</li><li>可执行代码</li></ul><p>所谓执行上下文，是JavaScript执行一段代码时的运行环境，在执行上下文终存在一个变量环境的对象，它保存了变量提升的内容。</p><p>以上面的代码为例，逐句分析：</p><ul><li>第1、2句并不涉及变量声明，JavaScript引擎不作处理；</li><li>第3句，JavaScript引擎会在环境对象中创建一个名为myName的属性，并使用undefined对其初始化；</li><li>第4句，JavaScript将函数showName定义存储到堆（HEAP）中，并在环境对象中创建了一个showName属性，并用该属性值指向堆中函数的位置。</li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 执行上下文var myName &#x3D; undefinedfunction showName() &#123;console.log(&#39;showName被调用!&#39;)&#125;&#x2F;&#x2F; 可执行代码showName()console.log(myName)myName &#x3D; &#39;朱由榔&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，如果变量和函数名相同，那么在编译阶段，变量的声明会被忽略。换言之，函数提升优于变量提升，导致变量声明被忽略。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>调用栈，就是用来管理函数调用关系的一种数据结构。<br>通俗地说，每一个函数都对应一个函数上下文，在整个代码片段中，调用栈中保存的都是执行上下文，故又称执行上下文栈。</p><p>当然，调用栈也是有大小的，当入栈的执行上下文超过一定数目时，JavaScript引擎就会报错，这种错误就叫栈溢出。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在JavaScript中，有两种作用域是ES6之前支持的：</p><ul><li>全局作用域</li><li>函数作用域</li></ul><p>此外，ES6之前的JavaScript不支持块级作用域（即使用大括号包裹的区域单独形成一个作用域）。</p><h4 id="变量提升带来的副作用"><a href="#变量提升带来的副作用" class="headerlink" title="变量提升带来的副作用"></a>变量提升带来的副作用</h4><p>变量提升会带来一些让常人觉得匪夷所思的问题。我们从一个栗子看起。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var myname &#x3D; &quot; 极客时间 &quot;function showName()&#123;  console.log(myname);  if(0)&#123;   var myname &#x3D; &quot; 极客邦 &quot;  &#125;  console.log(myname);&#125;showName()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码的运行结果都是undefined。和其他语言（如C）不同，它们都有块级作用域，在此处的打印结果为“ 极客时间 ”。<br>原因就是变量提升以及调用栈。showName函数提升后，会创建执行上下文，即showName的函数执行上下文，它入调用栈，压在全局执行上下文上面。当执行showName函数时，就会在调用栈顶的函数执行上下文中寻找myname变量，它的初始值为undefined，于是打印undefined。</p><p>下面的一个栗子也可以说明问题：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function foo()&#123;  for (var i &#x3D; 0; i &lt; 7; i++) &#123;  &#125;  console.log(i); &#125;foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的运行结果为7，原因很简单，是因为在创建执行上下文时，变量i会提升，而for循环虽然结束，但是函数并未结束，变量i仍然存在（或者更准确地说，for循环本应该形成一个单独的块级作用域，但是在此处JavaScript并不支持块级作用域）。</p><h3 id="ES6的对块级作用域的优化"><a href="#ES6的对块级作用域的优化" class="headerlink" title="ES6的对块级作用域的优化"></a>ES6的对块级作用域的优化</h3><p>JavaScript通过执行上下文来创建作用域（函数执行上下文对应函数作用域、全局执行上下文对应全局作用域），为了进一步说明ES6对作用域的优化，我们进一步分析<strong>执行上下文的组成</strong>：</p><ul><li>变量环境</li><li>词法环境</li></ul><p>然后，我们给出如下结论：</p><ul><li>函数内部，通过var声明的变量，在编译阶段全都存放到变量环境中去了</li><li>通过let声明的变量，在编译阶段会被存放到词法环境中</li><li>在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中</li></ul><p>其实，在词法环境内部，也维护了一个小型栈结构，栈底是函数最外层的变量，每进入一个作用域块，就会将当前作用域块内部的变量压入栈顶；当作用域执行完毕，该作用域的信息就会从栈顶弹出。这就是词法环境。</p><p>最后总结一句话：<strong>JavaScript中的块级作用域就是通过词法环境的栈结构来实现的</strong>。</p><p>下面有一个思考题：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let myname&#x3D; &#39;极客时间&#39;&#123;  console.log(myname)   let myname&#x3D; &#39;极客邦&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：报错。<br>let声明的变量提升，并不是创建、初始化（声明）全部被提升，而是仅仅创建被提升，在初始化之前，会形成一个暂时性死区。</p><blockquote><p>与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。</p></blockquote><ul><li>var的创建和初始化被提升，赋值不会被提升。</li><li>let的创建被提升，初始化和赋值不会被提升。</li><li>function的创建、初始化和赋值均会被提升。</li></ul><h2 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a>浏览器中的页面循环系统</h2><h3 id="消息队列与页面循环"><a href="#消息队列与页面循环" class="headerlink" title="消息队列与页面循环"></a>消息队列与页面循环</h3><p>消息队列是一种数据结构，可以存放要执行的任务，符合队列“先进先出”的特点：在队列尾部添加新任务，在队列头部取出任务。</p><p>其实，页面线程所有执行的任务都来自于消息队列，鉴于其“先进先出”的属性，有如下两个问题需要解决：</p><ul><li>如何处理高优先级的任务——宏任务与微任务</li><li>如何解决单个任务执行时间过长的问题——JavaScript的回调功能</li></ul><h3 id="探究setTimeout"><a href="#探究setTimeout" class="headerlink" title="探究setTimeout"></a>探究setTimeout</h3><p>上面提到过，事件循环系统中存在一个消息队列，并按顺序执行消息队列中的任务，而setTimeout是一个定时器，需要延迟一定时间再执行任务，因此不能直接将要延迟执行的任务放入消息队列中。<br>事实上，在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟的任务列表，包括定时器。当定时器被创建时，渲染进程将定时器的回调任务添加到延迟队列中。</p><h4 id="定时器的注意事项"><a href="#定时器的注意事项" class="headerlink" title="定时器的注意事项"></a>定时器的注意事项</h4><ol><li>如果当前任务执行时间过久，会影响迟到期定时器任务的执行</li><li>如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒</li><li>未激活的页面，setTimeout执行最小间隔是1000毫秒</li><li>延时执行时间有最大值<br>如果setTimeout设置的延迟值大于2147483647毫秒（Chrome以32位来存储延迟值，最大为2^32-1</li><li>setTimeout设置的回调函数中的this指向问题<br>如果setTimeout推迟执行的回调函数是某一个对象的方法，那么<strong>该方法中的this指向全局环境window，而不是定义时方法所在的那个对象</strong>。</li></ol><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var name &#x3D; 1var MyObj &#x3D; &#123;    name: 2,    showName: function () &#123;        console.log(this.name);    &#125;&#125;setTimeout(MyObj.showName, 1000); &#x2F;&#x2F; 输出undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的栗子中，由于showName函数内部的this指向window，而window上并没有name属性，因此呢，控制台输出undefined。<br>对此，一般的解决方法有两种：</p><ul><li>将showName放到另一个匿名函数中执行（箭头或者ES5写法都行）</li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var name &#x3D; 1var MyObj &#x3D; &#123;    name: 2,    showName: function () &#123;        console.log(this.name);    &#125;&#125;setTimeout(() &#x3D;&gt; &#123;    MyObj.showName()&#125;, 1000);setTimeout( function() &#123;    MyObj.showName()&#125;, 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用bind方法，将showName绑定到MyObj对象上</li></ul><blockquote><p>bind()方法会创建一个新的函数，在bind()被调用时，这个新函数的this会被指定为bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p></blockquote><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var name &#x3D; 1var MyObj &#x3D; &#123;    name: 2,    showName: function () &#123;        console.log(this.name);    &#125;&#125;&#x2F;&#x2F; 调用MyObj对象的showName方法的bind()，将该函数中的this设置为MyObjsetTimeout(MyObj.showName.bind(MyObj), 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><ul><li>宏任务：页面中大部分任务（渲染事件、用户交互、网络请求完成等）都是在主线程上执行的，这些消息队列中的任务被称为宏任务。</li><li>微任务：<br>其实JavaScript在执行一段脚本的时候，V8引擎在创建全局执行上下文的同时创建一个微任务队列，用于存放微任务，这样每一个宏任务都会关联一个微任务队列。</li></ul><p>当宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是用来处理异步任务的，以XML网络请求为例，我们先来看看一般的异步操作写法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//makeRequest 用来构造 request 对象</span><span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token parameter">request_url</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'Get'</span><span class="token punctuation">,</span>        <span class="token literal-property property">url</span><span class="token operator">:</span> request_url<span class="token punctuation">,</span>        <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token literal-property property">body</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token literal-property property">credentials</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token literal-property property">sync</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token literal-property property">responseType</span><span class="token operator">:</span> <span class="token string">'text'</span><span class="token punctuation">,</span>        <span class="token literal-property property">referrer</span><span class="token operator">:</span> <span class="token string">''</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> request<span class="token punctuation">&#125;</span><span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org/?category'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>          <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org/column'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>                  <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org'</span><span class="token punctuation">)</span>                      <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>                      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>                      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>              <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>              <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码完成的大概是三次嵌套请求，混乱不堪，难以入目，总结起来问题有两个：</p><ul><li>嵌套调用，回调函数内部再次执行回调函数</li><li>任务具有不确定性，每一个请求任务都有两种可能的结果</li></ul><p>而Promise就解决了这两个问题。</p><p>Promise构造函数语法如下：</p><p><code>Promise(function(resolve, reject) &#123;&#125;)</code></p><p>其中，resolve是成功的回调函数，reject是失败的回调函数。使用Promise来对上述代码进行优化：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function XFetch(request) &#123;    function executor(resolve, reject) &#123;        let xhr &#x3D; new XMLHttpRequest()        xhr.open(&#39;GET&#39;, request.url, true)        xhr.ontimeout &#x3D; function (e) &#123;            reject(e)        &#125;        xhr.onerror &#x3D; function (e) &#123;            reject(e)        &#125;        xhr.onreadystatechange &#x3D; function () &#123;            if (this.readyState &#x3D;&#x3D;&#x3D; 4) &#123;                if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;                    resolve(this.responseText, this)                &#125; else &#123;                    let error &#x3D; &#123;                        code: this.status,                        response: this.response                    &#125;                    reject(error, this)                &#125;            &#125;        &#125;        xhr.send()    &#125;    return new Promise(executor)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，调用XFetch()函数会返回一个Promise对象，然后就可以使用Promise.then()方法继续发起请求了：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var x1 &#x3D; XFetch(makeRequest(&#39;https:&#x2F;&#x2F;time.geekbang.org&#x2F;?category&#39;))var x2 &#x3D; x1.then(value &#x3D;&gt; &#123;    console.log(value)    return XFetch(makeRequest(&#39;https:&#x2F;&#x2F;www.geekbang.org&#x2F;column&#39;))&#125;)var x3 &#x3D; x2.then(value &#x3D;&gt; &#123;    console.log(value)    return XFetch(makeRequest(&#39;https:&#x2F;&#x2F;time.geekbang.org&#39;))&#125;)x3.catch(error &#x3D;&gt; &#123;    console.log(error)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="深入Promise"><a href="#深入Promise" class="headerlink" title="深入Promise"></a>深入Promise</h4><p>Promise用法大致如下：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;    ...    resolve()    ...    reject()&#125;)p.then((value) &#x3D;&gt; &#123;    ...&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照Promise的语法，resolve()函数的调用会触发p.then()方法，因此，可以推测<strong>resolve函数内部调用了p.then()设置的回调函数</strong>，但是，如果真的是我们所猜测的这样，resolve()执行的时候，p.then()还没有绑定回调函数，这又应当作何解释呢？</p><p>答案就是<strong>Promise采用了回调函数延迟绑定技术</strong>，即在执行resolve函数时，由于回调函数还没有绑定到then()上，因此只能推迟回调函数的执行。</p><p>下面我们简单自己实现一个支持延时回调的类Promise对象（Bromise）：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Bromise(executor) &#123;    var onResolve_ &#x3D; null    var onReject_ &#x3D; null    &#x2F;&#x2F; 给Bromise对象绑定一个then方法，类似于Promise对象的then方法    this.then &#x3D; function(onResolve, onReject) &#123;        onResolve_ &#x3D; onResolve    &#125;    &#x2F;&#x2F; 在resolve内部必定要执行demo.then()绑定的onResolve()函数，因此让resolve中的onResolve_()函数延后执行    function resolve(value) &#123;        setTimeout(() &#x3D;&gt; &#123;            onResolve_(value)        &#125;, 0)        &#x2F;&#x2F; onResolve_(value)    &#125;    executor(resolve, null)&#125;function executor(resolve, reject) &#123;    resolve(100)&#125;let demo &#x3D; new Bromise(executor)function onResolve(value) &#123;    console.log(value);&#125;demo.then(onResolve)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，由于定时器的效率不是很高，因此Promise将这个定时器改造成了微任务，进一步提升了代码执行效率。</p><h3 id="async与await——同步代码书写异步操作"><a href="#async与await——同步代码书写异步操作" class="headerlink" title="async与await——同步代码书写异步操作"></a>async与await——同步代码书写异步操作</h3><p>先来看一段Promise异步操作代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">fetch(&#39;https:&#x2F;&#x2F;www.geekbang.org&#39;)      .then((response) &#x3D;&gt; &#123;          console.log(response)          return fetch(&#39;https:&#x2F;&#x2F;www.geekbang.org&#x2F;test&#39;)      &#125;).then((response) &#x3D;&gt; &#123;          console.log(response)      &#125;).catch((error) &#x3D;&gt; &#123;          console.log(error)      &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然和回调地狱相比，Promise已然改进了不少了，但是promise.then()方法的链式调用也显得代码有一点凌乱。因此，我们引入ES7的新语法特性——async/await——它支持我们在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function foo()&#123;  try&#123;    let response1 &#x3D; await fetch(&#39;https:&#x2F;&#x2F;www.geekbang.org&#39;)    console.log(&#39;response1&#39;)    console.log(response1)    let response2 &#x3D; await fetch(&#39;https:&#x2F;&#x2F;www.geekbang.org&#x2F;test&#39;)    console.log(&#39;response2&#39;)    console.log(response2)  &#125;catch(err) &#123;       console.error(err)  &#125;&#125;foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>在进一步学习async/await之前，我们需要先了解生成器函数。</p><blockquote><p>生成器函数：</p><ol><li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li><li>外部函数可以通过 next 方法恢复函数的执行。</li></ol><p>为了理解生成器函数的实现原理，这里简单介绍一个概念——协程。简单而言，协程是跑在线程上的任务，是一种比线程更加轻量级的存在。虽然一个线程上可以存在多个协程，但是同时只能执行一个协程。</p></blockquote><p>通过生成器配合Promise改造代码：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function* foo() &#123;    let response1 &#x3D; yield fetch(&#39;https:&#x2F;&#x2F;www.geekbang.org&#39;)    console.log(&#39;response1&#39;)    console.log(response1);    let response2 &#x3D; yield fetch(&#39;https:&#x2F;&#x2F;www.geekbang.org&#x2F;test&#39;)    console.log(&#39;response2&#39;);    console.log(response2);&#125;&#x2F;&#x2F; 执行foo函数的代码，创建gen协程let gen &#x3D; foo()&#x2F;&#x2F; 继续执行foo函数，将主线程控制权交给gen协程function getGenPromise(gen) &#123;    return gen.next().value&#125;getGenPromise(gen).then((response) &#x3D;&gt; &#123;    console.log(&#39;response1&#39;)    console.log(response);    return getGenPromise(gen)&#125;).then((response) &#x3D;&gt; &#123;    console.log(&#39;response2&#39;)    console.log(response)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，async、await的底层原理就是生成器与Promise。</p><h4 id="神奇的语法糖"><a href="#神奇的语法糖" class="headerlink" title="神奇的语法糖"></a>神奇的语法糖</h4><p>async、await两个关键字其实是语法糖，虽然看起来很简洁，实际上它们完成的工作量并不小。</p><ul><li>async：修饰函数，使之成为async函数，该函数通过异步执行并<strong>隐式返回Promise</strong>作为结果</li><li>await：顾名思义，它将“等待”一个Promise对象（或者其他值），如果是Promise对象，就返回其处理结果，如果是其他值，就返回其本身。<strong>await将会暂停当前async函数的执行，等待Promise的处理完成，此时主线程控制权转交给父协程，同时Promise也会进行处理</strong>。</li></ul><p>请看下面一个简单的示例。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function foo() &#123;    console.log(1)    let a &#x3D; await 100    console.log(a)    console.log(2)&#125;console.log(0)foo()console.log(3)&#x2F;*运行结果为：0131002*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主线程中，0首先被打印；程序进入foo()，打印1，let a = await 100，则当前async函数被停止，程序继续往下执行，即打印3，同时由于100并不是Promise对象，故a就是100本身，只不过会经过Promise处理，故在3打印后，100被打印，接着再继续执行foo，打印2。</p><h2 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a>浏览器中的页面</h2><h3 id="开发者工具——网络面板"><a href="#开发者工具——网络面板" class="headerlink" title="开发者工具——网络面板"></a>开发者工具——网络面板</h3><p>我们重点来了解一下网络面板的时间线面板（Timing）。</p><p>打开网络面板（Network），在详细列表中点击某一个任务，可以发现该项的详细信息（Headers、Preview、Response、Timing），打开Timing，我们会发现如下选项：</p><ul><li>Queueing：浏览器发起一个请求时，有多种原因导致其不能被立即执行而进入排队等待状态，比如<ul><li>页面中资源具有优先级，图片、视频等资源优先级就比较低；</li><li>浏览器为每一个域名最多维护6个TCP连接；</li><li>网络进程为数据分配磁盘空间时，新的HTTP请求需要短暂地等待磁盘分配结果</li></ul></li><li>Stalled：等待排队完成后、发起连接之前，可能有一些原因导致连接过程被推迟，这就是Stalled，停滞</li><li>Initial connection/SSL：和服务器建立连接</li><li>Request sent：网络进程发送请求，这个阶段很快</li><li>Waiting（TTFB）：也称第一字节时间，是反映服务端响应速度的重要指标，指等待接收服务器第一个字节数据</li><li>Content Download：陆续接收完整数据</li></ul><h3 id="DOM树与JavaScript"><a href="#DOM树与JavaScript" class="headerlink" title="DOM树与JavaScript"></a>DOM树与JavaScript</h3><h4 id="DOM树的生成简介"><a href="#DOM树的生成简介" class="headerlink" title="DOM树的生成简介"></a>DOM树的生成简介</h4><p>我们知道，在使用浏览器访问网页时，是由浏览器先向服务器发起网络请求，拿到网页源代码，然后生成各式各样的网页，供给客户端查看。从进程角度看，这涉及了两个重要的进程——网络进程、渲染进程。</p><p>网络进程和渲染进程之间会建立一个共享数据的管道，网络进程将拿到的数据放进该管道，而另一边的渲染进程则从管道的另外一端不断地读取数据，将其丢给HTML解析器，由其生成DOM。</p><blockquote><p>其实，网络进程拿过来的数据是字节流形式的，可以理解为页面源代码，也就是说，HTML解析器拿到的第一手数据也是字节流，需要先将字节流转化为Token，再将Token转化为DOM节点，并添加到DOM树上。</p></blockquote><p>第一部分，HTML解析器会维护一个Token栈，用以保存当前解析到的标签。</p><ul><li>如果解析到的是StartToken，就将其入栈，同时为该Token创建一个DOM节点；</li><li>如果解析到的是一个TextToken，不用入栈，直接创建文本节点，加入到DOM树中；</li><li>如果解析到的是EndToken，此时与栈顶元素匹配，将栈顶元素（StartToken）弹出，表示该元素标签封闭，解析完成。</li></ul><h4 id="JavaScript会阻塞DOM的生成"><a href="#JavaScript会阻塞DOM的生成" class="headerlink" title="JavaScript会阻塞DOM的生成"></a>JavaScript会阻塞DOM的生成</h4><p>网络进程传输给渲染进程的字节流中不一定全部都是html代码，也可能包括JavaScript脚本代码：</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;html&gt;&lt;body&gt;    &lt;div&gt;1&lt;&#x2F;div&gt;    &lt;script&gt;    let div1 &#x3D; document.getElementsByTagName(&#39;div&#39;)[0]    div1.innerText &#x3D; &#39;time.geekbang&#39;    &lt;&#x2F;script&gt;    &lt;div&gt;test&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当HTML解析器解析到script标签时，会发现这是JavaScript代码，由于它有可能操作DOM，因此HTML解析器停止解析，转而由JavaScript引擎介入，在执行JavaScript代码（修改了文本节点的内容）后，HTML解析器恢复解析，继续工作。</p><p>那如果拿到的JavaScript代码以文件形式被引入呢？</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>foo.js<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，JavaScript文件需要被下载，该下载过程会阻塞HTML的解析。Chrome对此做出的优化是，在渲染引擎收到字节流后，就会开启一个预解析线程，用于下载HTML中包含的JavaScript、CSS等相关文件。</p><h4 id="CSS样式表文件会阻塞JavaScript的执行"><a href="#CSS样式表文件会阻塞JavaScript的执行" class="headerlink" title="CSS样式表文件会阻塞JavaScript的执行"></a>CSS样式表文件会阻塞JavaScript的执行</h4><p>那接下来我们再来分析另外一种情况。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>theme.css<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token style"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            div1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'time.geekbang'</span> <span class="token comment">// 需要 DOM</span>            div1<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span>  <span class="token comment">// 需要 CSSOM</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在script标签中，出现了操作css样式的JavaScript代码，也就是说在执行JavaScript之前，还需要解析所有的CSS样式。</p><p>但是实际上，JavaScript引擎在解析JavaScript之前，并不知道JavaScript是否操作了CSSOM，因此渲染引擎在遇到JavaScript脚本时，不论其是否操作CSSOM，都会执行CSS文件下载、解析CSS，然后再执行JavaScript脚本。</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>如下代码，分析浏览器中的运行情况。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    div1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'time.geekbang'</span>     <span class="token keyword">let</span> div2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    div2<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'time.geekbang.com'</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之前提到过，JavaScript会阻塞DOM树的生成，因此HTML解析器解析到script标签的时候，会停止解析，交给JavaScript引擎。而此时DOM树中仅有一个div节点，因此div1有值，div2并不会拿到值，进而拿不到它的innerText属性，会报错。</p><p>JavaScript引擎将JavaScript代码执行完毕后，HTML解析器继续执行，将剩余的div解析出来，但是文本内容就是test，不会被改变。</p><h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><h4 id="显示器显示图像"><a href="#显示器显示图像" class="headerlink" title="显示器显示图像"></a>显示器显示图像</h4><p>显示器每秒固定读取一定次数前缓冲区的图像到显示器上，而显卡的职责是合成新的图像，并将图像保存到后缓冲区中，之后系统会让后缓冲区和前缓冲区互换，保证显示器能够读取最新显卡合成的图像。这样一来，通常情况下，显卡的更新频率和显示器的刷新频率一致。</p><h4 id="帧与帧率"><a href="#帧与帧率" class="headerlink" title="帧与帧率"></a>帧与帧率</h4><p>我们把渲染流水线生成的每一幅图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率。</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>当DOM结构较为复杂时，不断地修改DOM树会导致重排、重绘等操作，给渲染器增加负担。因此，虚拟DOM的出现，就是想尽可能地减少对真实DOM的操作次数。</p><h4 id="虚拟DOM用来干什么"><a href="#虚拟DOM用来干什么" class="headerlink" title="虚拟DOM用来干什么"></a>虚拟DOM用来干什么</h4><p>虚拟DOM其实可以理解为真实DOM之前的一个存在，在页面数据发生变化时，先重新创建出新的虚拟DOM树，然后与旧的DOM树进行比较，将变化的节点一次性全部应用到真实DOM树上，完成修改。</p><h4 id="从双缓存视角看虚拟DOM"><a href="#从双缓存视角看虚拟DOM" class="headerlink" title="从双缓存视角看虚拟DOM"></a>从双缓存视角看虚拟DOM</h4><p>缓冲区其实是一个方便计算机快速处理的机制。但有时候，如果将数据一部分一部分地写入缓冲区，就会导致页面上的信息一块一块地显示出来，带给用户不良的体验。因此，<strong>双缓存</strong>发挥了优势：<br>先将计算的中间结果存放在另一个缓冲区中，待全部计算结束，缓冲区已经存储了完整的数据之后（比如完整的图像数据信息），一次性复制到显示缓冲区，这样就会使得整个数据输出十分稳定。<br>这里的虚拟DOM就是一种类似双缓存的机制。</p><h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><ul><li>M：model，模型，可以理解为数据</li><li>V：view，视图，可以理解为人眼看到的画面</li><li>C：controller，控制器，是连接model与view的枢纽</li></ul><p>通过MVC模式来看，</p><ul><li>虚拟DOM实际上是MVC的<strong>视图</strong>部分，因为它将涉及后续视图的更新</li><li>控制器用于监视DOM的变化，一旦DOM变化了，控制器就会通知模型，让其更新（update）数据</li><li>模型数据更新好后，控制器会通知视图，告知（notify）其数据模型已经变化</li><li>视图收到消息，会根据新的数据来生成新的虚拟DOM</li><li>新的虚拟DOM一旦生成，会与旧的虚拟DOM进行比较，将变化的节点应用到真实DOM上</li></ul><h3 id="WebComponent——组件化"><a href="#WebComponent——组件化" class="headerlink" title="WebComponent——组件化"></a>WebComponent——组件化</h3><p>组件可以理解为具有某一个特定功能的“工具”，它高内聚、低耦合，在多人协作开发中可以被方便地复用，极大地提高了开发效率。</p><p>对于大多数编程语言，都可以实现组件化——凭借其类、作用域等特性，实现模块的封装等等，JavaScript也不例外。但是，在前端开发中，仍然存在着阻碍组件化开发的因素。</p><ul><li>CSS对标签属性的控制：css代码的标签选择器对全局标签进行选择，并设置属性，这样一来，不同开发人员编写的某一元素的样式可能会被全部修改。</li><li>DOM的阻碍：全局DOM只有一个，但是任意一个地方都可以修改DOM。</li></ul><p>对此，WebComponent提出了解决思路，提供了对局部视图封装能力——Web Components技术，它由三项主要技术组成：</p><ul><li>自定义元素（Custom elements）：一组JavaScript API</li><li>影子DOM（Shadow DOM）：一组JavaScript API，将封装的影子DOM树附加到元素（与主文档DOM分开呈现），这样可以保持元素功能私有</li><li>HTML模板（HTML templates）</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>geekbang-t<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">p</span> <span class="token punctuation">&#123;</span>                <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>                <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token selector">div</span> <span class="token punctuation">&#123;</span>                <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>                <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span>                <span class="token property">border</span><span class="token punctuation">:</span> 3px solid chocolate<span class="token punctuation">;</span>                <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'inner log'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">class</span> <span class="token class-name">GeekBang</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">&#123;</span>            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment">// 这里的content就是template下所有的html内容</span>                <span class="token keyword">const</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#geekbang-t'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>content                <span class="token keyword">const</span> shadowDOM <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                    <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'open'</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>shadowDOM<span class="token punctuation">)</span><span class="token punctuation">;</span>                shadowDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'geek-bang'</span><span class="token punctuation">,</span> GeekBang<span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要使用Web Component，通常要实现下面三个步骤：</p><ol><li><p>使用template属性来创建模板。实际上，模板元素内容并不会被渲染到页面上，也就是说template节点不会出现在布局树中。</p></li><li><p>创建一个GeekBang类。这个类的构造函数中完成三件事：</p><ul><li>查找模板内容</li><li>创建影子DOM</li><li>再将模板添加到影子DOM上</li></ul><blockquote><p>影子DOM，将模板中的内容与全局DOM和CSS进行隔离，实现元素和样式的私有化。</p></blockquote></li><li><p>上面两步实现后，就可以像正常使用HTML元素一样使用该元素，如\<geek-bang>\&lt;/geek-bang&gt;</p></li></ol><h2 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a>浏览器中的网络</h2><h3 id="HTTP性能优化"><a href="#HTTP性能优化" class="headerlink" title="HTTP性能优化"></a>HTTP性能优化</h3><blockquote><p>HTTP是浏览器最重要且使用最多的协议，是浏览器和服务器之间的通信语言。随着互联网的发展，HTTP也在持续进化。</p></blockquote><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h4><p>用途较为简单，主要用于学术交流，需求也很简单，只需要在网络之间传递HTML超文本内容，故称“超文本传输协议”。</p><ul><li>客户端根据IP地址、端口、服务器建立TCP连接，涉及TCP协议三次握手过程；</li><li>TCP连接建立完成后，发送应该GET请求行信息，如<code>GET /index.html</code>用来获取index.html；</li><li>服务器接收请求信息之后，读取对应的HTML文件，并将数据以ASCII字符流返回给客户端；</li><li>传输完成，连接断开。</li></ul><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><p>万维网的高速发展带来了很多新需求，HTTP/0.9已经不再适用于新的网络发展了。新的需求包括：</p><ul><li>浏览器中展示的不单单是HTML文件了，还有JavaScript、CSS、图片、音视频等不同类型的文件。</li><li>文件格式不仅仅局限于ASCII编码，还有很多其他类型编码的文件。</li></ul><p>为了<strong>支持对多种类型文件的下载</strong>，HTTP/1.0引入了<strong>请求头和响应头</strong>，也就是说，在HTTP发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。</p><blockquote><p>HTTP/1.0通过请求头、响应头支持多种不同类型的数据的原理：</p><p>HTTP在发起请求时候会通过HTTP<strong>请求头</strong>告诉服务器它期待服务器</p><ul><li>返回什么类型的文件</li><li>采取什么形式的压缩</li><li>提供什么语言的文件以及编码</li></ul><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">accept: text&#x2F;html&#x2F;&#x2F; 期望浏览器返回html类型文件accept-encoding: gzip, deflate, br&#x2F;&#x2F; 期望浏览器采用gzip、deflate或者br压缩方式accept-Charset: ISO-8859-1,utf-8&#x2F;&#x2F; 期望返回的文件编码是UTF-8或者ISO-8859-1accept-language: zh-CN,zh&#x2F;&#x2F; 期望页面的优先语言是中文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>服务器接收到浏览器发送过来的请求头信息之后，就会根据请求头的信息准备响应数据，并将相关信息以响应头形式反馈给客户端浏览器（按要求做事情，并给出反馈）。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">content-encoding: br&#x2F;&#x2F; 服务器采用了br压缩方法content-type: text&#x2F;html; charset&#x3D;UTF-8&#x2F;&#x2F; 服务器返回html文件，编码类型为UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>拿到如上的服务器响应头信息后，最终浏览器需要根据响应头的信息来处理数据。</p></blockquote><p>此外，HTTP/1.0还引入了很多其他的特性，比如</p><ul><li>状态码——通过响应行的方式通知浏览器，服务器最终处理情况</li><li>Cache机制——缓存已经下载过的数据，减轻服务器压力</li><li>用户代理字段——服务器需要统计客户端的基础信息</li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>相比于HTTP/1.0，1.1有如下方面的改进：</p><ul><li>改进持久连接</li></ul><p>在HTTP/1.0中，一次HTTP通信，需要经历<strong>建立TCP连接、传输HTTP数据和断开TCP连接</strong>三个阶段。但是随着单个页面中文件数量增多，每一次下载文件都需要重复这三个步骤，无疑会增加大量开销。</p><p>对此，HTTP/1.1中增加了持久连接，在应该TCP连接上可以传输多个HTTP请求，只要浏览器或者服务器没有断开连接，该TCP连接会一直保持。</p><p>另外，浏览器为每个域名最多同时维护6个TCP持久连接。</p><ul><li>不成熟的HTTP管线化</li></ul><p>TCP通道中一旦某个请求因为某些原因没有及时返回，就会阻塞后面的所有请求——队头阻塞问题。对此，HTTP/1.1中试图引入管线化技术来解决队头阻塞问题。</p><ul><li>引入客户端Cookie与安全机制</li></ul><p>但是，HTTP/1.1仍然有很大的不足，核心问题在于<strong>对带宽的利用率并不理想</strong>。</p><blockquote><p>带宽，是指每秒最大能够发送或者接收的字节数。每秒能够发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p></blockquote><p>原因主要有三点：</p><ol><li>TCP慢启动。TCP连接建立之后，会进入发送数据状态，刚开始TCP协议会采用应该非常慢的速度去发送数据。</li><li>同时开启多条TCP连接会竞争固定的带宽。</li><li>HTTP/1.1的队头阻塞问题。</li></ol><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>那么如何解决HTTP/1.1的问题呢？</p><p>我们先分析上面的三点原因，会发现，第一条、第二条是TCP本身的机制引起的，第三条是HTTP/1.1的机制导致的。</p><p>因此，HTTP/2的思路就是<strong>一个域名只使用一个TCP长连接来传输数据</strong>，这样整个页面资源的下载过程只需要一次慢启动，也不会有多个TCP连接竞争问题。</p><p>此外，HTTP/2最核心的功能是<strong>多路复用机制</strong>——引入二进制分帧层，实现了资源的并行传输。</p><p>当然，HTTP/2还有一些其他特性，比如</p><ul><li>可以设置请求的优先级：在发送请求时，可以标上该请求的优先级</li><li>服务器推送：直接将数据提前推送到浏览器</li><li>头部压缩：对请求头和响应头都进行了压缩</li></ul><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="Web页面安全"><a href="#Web页面安全" class="headerlink" title="Web页面安全"></a>Web页面安全</h3><p>Web页面安全的意义在于可以保障我们的隐私和数据的安全。</p><p>Web页面安全中最基础、最核心的安全策略——同源策略。</p><p>同源是针对URL而言的，<strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源</strong>。比如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org<span class="token operator">/</span><span class="token operator">?</span>category<span class="token operator">=</span><span class="token number">1</span><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org<span class="token operator">/</span><span class="token operator">?</span>category<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而同源策略就是，两个不同的源之间如果想要互相访问资源或者操作DOM，就会有一套基础的安全策略的制约。</p><p>同源策略会隔离不同源的DOM、页面数据和网络通信，进而实现Web页面的安全性。</p><p>但是，安全性和便利性是相互对立的。对此浏览器出让一些安全性来满足灵活性，以方便Web开发。浏览器出让了同源策略的哪些安全性呢？</p><ol><li>页面中可以嵌入第三方资源</li></ol><p>最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。最多的问题是，浏览器的首页内容会被一些恶意程序劫持，其中，最常见的是恶意程序通过各种途径往HTML文件中插入恶意脚本。</p><p>对此，我们引入了CSP策略来加以限制。</p><ol><li>跨域资源共享和跨文档消息机制</li></ol><p>跨域资源共享，CORS，允许进行跨域访问控制；</p><p>跨文档消息机制，允许两个不同源的DOM之间进行通信。</p><h3 id="跨站脚本攻击——XSS攻击"><a href="#跨站脚本攻击——XSS攻击" class="headerlink" title="跨站脚本攻击——XSS攻击"></a>跨站脚本攻击——XSS攻击</h3><h4 id="XSS攻击以及危害"><a href="#XSS攻击以及危害" class="headerlink" title="XSS攻击以及危害"></a>XSS攻击以及危害</h4><p>首先我们需要知道什么是XSS。XSS，Cross Site Scripting，为了区分于CSS，故称XSS，意为“跨站脚本”。<strong>所谓XSS攻击，指黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段</strong>。</p><p>HTML文件中注入恶意代码会给用户带来很多危害。比如</p><ul><li><p>窃取Cookie信息。</p><p>恶意的JavaScript通过document.cookie来获取Cookie信息，然后通过XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器。恶意服务器一旦拿到用户的Cookie信息，也即掌握了用户的账户等隐私信息，几乎可以为所欲为。</p></li><li><p>监听用户行为。</p><p>恶意JavaScript通过addEventListener接口来监听键盘事件，比如可以获取用户输入的信用卡等信息。</p></li><li><p>伪造假的登录窗口。</p><p>恶意代码修改DOM，属于欺骗用户行为。</p></li><li><p>生成浮窗广告。</p></li></ul><h4 id="恶意脚本的注入"><a href="#恶意脚本的注入" class="headerlink" title="恶意脚本的注入"></a>恶意脚本的注入</h4><p>要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式：</p><ul><li>存储型XSS攻击</li><li>反射型XSS攻击</li><li>基于DOM的XSS攻击</li></ul><h5 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h5><ul><li>黑客首先利用站点漏洞，将一段恶意JavaScript代码提交到网站的数据库中</li><li>用户向网站请求包含了恶意JavaScript脚本的页面</li><li>用户浏览该页面，恶意脚本上传用户的Cookie等信息</li></ul><h5 id="反射型xss攻击"><a href="#反射型xss攻击" class="headerlink" title="反射型xss攻击"></a>反射型xss攻击</h5><p>恶意JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又把JavaScript脚本返回给用户了。</p><p><strong>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方</strong>。</p><h5 id="基于DOM的XSS攻击"><a href="#基于DOM的XSS攻击" class="headerlink" title="基于DOM的XSS攻击"></a>基于DOM的XSS攻击</h5><p>不牵涉页面Web服务器，具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如网络劫持等。</p><h4 id="阻止XSS攻击"><a href="#阻止XSS攻击" class="headerlink" title="阻止XSS攻击"></a>阻止XSS攻击</h4><p>无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。所以要阻止 XSS 攻击，<strong>我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现</strong>。</p><ul><li><p>服务器对输入脚本进行过滤或者转码</p></li><li><p>充分利用CSP</p><blockquote><p>CSP，Content Security Policy，即内容安全策略，其主要目标是减少和报告XSS攻击。其实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以被加载和执行（提供白名单）。</p></blockquote></li><li><p>使用HttpOnly属性</p><p>使用HttpOnly标记的Cookie只能使用在HTTP请求过程中，无法通过JavaScript来读取（document.cookie）。</p></li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF，Cross-site request forgery，又称“跨站请求伪造”，指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</p><h3 id="页面安全和操作系统安全"><a href="#页面安全和操作系统安全" class="headerlink" title="页面安全和操作系统安全"></a>页面安全和操作系统安全</h3><h4 id="初代浏览器的架构"><a href="#初代浏览器的架构" class="headerlink" title="初代浏览器的架构"></a>初代浏览器的架构</h4><p>最开始的阶段浏览器是单进程的，JavaScript执行、网络加载、UI绘制等过程都是在同一个进程中执行的，如此简单的结构却也带来了很多问题。首先，就是单进程架构的浏览器并不稳定。</p><p>浏览器进程中任意一个功能出现异常，都有可能影响到整个浏览器。而如果浏览器存在漏洞，黑客有可能通过恶意的页面向浏览器中注入恶意程序，不仅如此，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入以及读取硬盘上的文件内容。</p><h4 id="现代浏览器的两个核心模块"><a href="#现代浏览器的两个核心模块" class="headerlink" title="现代浏览器的两个核心模块"></a>现代浏览器的两个核心模块</h4><p>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程分离开来。浏览器被划分为</p><ul><li>浏览器内核<ul><li>网络进程</li><li>浏览器主进程</li><li>GPU进程</li></ul></li><li>渲染内核<ul><li>渲染进程</li></ul></li></ul><p>当我们打开一个页面时，这两个模块就会互相配合。</p><ul><li>首先，浏览器内核会下载所有的网络资源，下载后的资源会通过IPC将其提交给渲染进程（IPC是浏览器内核和渲染进程的通信通道）；</li><li>然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片；</li><li>这张生成的图片会被提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</li></ul><h4 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h4><p>渲染进程执行下载的各种网络资源时，需要十分小心，否则容易执行恶意程序，进而被黑客攻击。对此，我们需要在渲染进程和操作系统之间建立一道墙，即使渲染进程由于存在漏洞被黑客攻击，但由于这道墙的存在，黑客获取不到渲染进程之外的任何操作权限——这道墙就是安全沙箱。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask基础</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/06/Flask%E5%9F%BA%E7%A1%80/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/06/Flask%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>Flask是基于Python的web开发框架。</p><p>从最基本的Flask代码开始吧：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flaskapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;&#39;)def hello_world():   return &#39;Hello World&#39;if __name__ &#x3D;&#x3D; &#39;__main__&#39;:   app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行如上代码，就可以在浏览器中看到运行结果——Hello，Flask!</p><ul><li>第二行调用Flask()构造函数，返回的是一个application对象；</li><li>url ‘/‘绑定到了hello_world()上面；</li><li><p>在上面的示例中，run()方法用于在本地服务器上运行应用程序，其函数原型为：<br>app.run(host, port, debug, options)</p></li><li><p>host，指定主机端口号</p></li><li>port，端口号</li><li>debug，是否启用调试模式</li></ul><h2 id="Flask路由"><a href="#Flask路由" class="headerlink" title="Flask路由"></a>Flask路由</h2><p>在Web应用中，不同的url对应不同的页面；Flask中的route()装饰器用于将URL绑定到函数：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flaskapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;hello&#39;)def hello_flask():    return &#39;hello Flask&#39;if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码示例中，route()装饰器将URL‘/hello’规则绑定到了hello_flask()函数，如果用户访问<br><a href="http://localhost:5000/hello">http://localhost:5000/hello</a> ，hello_flask()函数的输出就将在浏览器中呈现。</p><p>当然，也可以不使用装饰器写法，改用application对象的add_url_rule()函数也可以实现URL与函数的绑定：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def hello_flask():    return &#39;hello flask!&#39;app.add_url_rule(&#39;&#x2F;&#39;, &#39;hello&#39;, hello_flask)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Flask变量规则——路由参数"><a href="#Flask变量规则——路由参数" class="headerlink" title="Flask变量规则——路由参数"></a>Flask变量规则——路由参数</h2><p>向规则参数添加变量部分，可以动态地构建URL。<br>此变量部分标记为 &lt; variable-name &gt;<br>示例：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">@app.route(&#39;&#x2F;blog&#x2F;&lt;int:postId&gt;&#39;)def show_blog(postId):    return &#39;Blog Number %d&#39; % postId@app.route(&#39;&#x2F;rev&#x2F;&lt;float:revNo&gt;&#39;)def revision(revNo):    return &#39;Revision Number %f&#39; % revNo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&lt; int:postId&gt;中，int是对变量类型postId的限制，我们在地址栏中输入/blog/9后，按下回车，屏幕上就会显示Blog Number 9。</p><ul><li>%d 整型</li><li>%f 浮点型</li><li>%s 字符串型</li></ul><h2 id="Flask-URL构建"><a href="#Flask-URL构建" class="headerlink" title="Flask URL构建"></a>Flask URL构建</h2><p>函数url_for()，用于动态构建特定函数的URL。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flask, redirect, url_forapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;admin&#39;)def hello_admin():    return &#39;Hello Admin&#39;@app.route(&#39;&#x2F;guest&#x2F;&lt;guest&gt;&#39;)def hello_guest(guest):    return &#39;Hello %s as Guest&#39; % guest@app.route(&#39;&#x2F;user&#x2F;&lt;name&gt;&#39;)def hello_user(name):    if name &#x3D;&#x3D; &#39;admin&#39;:        return redirect(url_for(&#39;hello_adminn&#39;))    else:        return redirect(url_for(&#39;hello_guest&#39;, guest&#x3D;name))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/user/…对应的函数hello_user中，我们作出了处理：<br>如果接收参数为字符串admin，就重定向到hello_admin()函数否则重定向到hello_guest()函数。</p><h2 id="Flask中的HTTP"><a href="#Flask中的HTTP" class="headerlink" title="Flask中的HTTP"></a>Flask中的HTTP</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://localhost:5000/login<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Enter Name:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们创建一个html文件，在其中写一个表单，在下面的文件中接收表单提交到服务器的数据。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 在Flask中使用HTTP方法from flask import Flask, redirect, url_for, requestapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;success&#x2F;&lt;name&gt;&#39;)def success(name):    return &#39;welcome %s&#39; % name@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])def login():    if request.method &#x3D;&#x3D; &#39;POST&#39;:        # 通过表单拿到输入的名字，并给动态URL        user &#x3D; request.form[&#39;nm&#39;]        return redirect(url_for(&#39;success&#39;, name&#x3D;user))    else:        user &#x3D; request.args.get(&#39;nm&#39;)        return redirect(url_for(&#39;success&#39;, name&#x3D;user))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="模板的来历"><a href="#模板的来历" class="headerlink" title="模板的来历"></a>模板的来历</h3><p>之前与URL绑定的函数，叫做视图函数，一般来说，视图函数有两个作用：</p><ul><li>处理业务逻辑（背后的业务代码，也即展示出来的数据是怎么来的）</li><li>返回相应内容（将要展示的数据表现出来）</li></ul><p>在大型应用中，一般选择将业务逻辑与表现内容分开，否则代码极其复杂，维护起来很困难。<br>因此，我们需要用到模板。</p><h3 id="何为模板"><a href="#何为模板" class="headerlink" title="何为模板"></a>何为模板</h3><p>模板，其实就是一个包含响应文本的文件，特殊的地方在于，里面有动态文本内容，使用占位符变量来表示，占位符变量可以告诉模板引擎该处的值需要从另外的地方获取数据；<br>另外，从视图函数中的真实值，替换模板中的占位符变量，这个过程简单理解为“渲染”。<br>如此一来，模板的使用，就可以将业务逻辑与表现内容分离开来，使得</p><ul><li>视图函数只负责业务逻辑和数据处理</li><li>模板只负责从视图函数中获取数据进行展示</li></ul><p>举例：<br>我们在项目中单独创建templates文件夹，并在该目录下创建一个模板文件hello.html;<br><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>05_Flask模板<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    我的模板html内容    <span class="token comment">&lt;!-- 注意，以下的双括号插值都是待加入的变量，从视图函数中得来 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>&#123;&#123; my_str &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>&#123;&#123; my_int &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>&#123;&#123; my_array &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>&#123;&#123; my_dict &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>可以发现，模板文件中，占位符处的值需要从视图函数中获取对应的数据，下面是视图函数所在文件：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flask, render_templatefrom sympy import degapp &#x3D; Flask(__name__)# 我们向模板中传入字符串、列表、字典@app.route(&#39;&#x2F;&#39;)def index():    # 定义要往模板中传递的数据    my_str &#x3D; &#39;Hello World&#39;    my_int &#x3D; 10    my_array &#x3D; [3, 4, 2, 1, 7, 9]    my_dict &#x3D; &#123;        &#39;name&#39;: &#39;xiaoming&#39;,        &#39;age&#39;: 18,    &#125;    return render_template(&#39;hello.html&#39;,                           my_str&#x3D;my_str,                           my_int&#x3D;my_int,                           my_array&#x3D;my_array,                           my_dict&#x3D;my_dict                           )if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="控制代码块写法"><a href="#控制代码块写法" class="headerlink" title="控制代码块写法"></a>控制代码块写法</h2><p>包括if写法（选择）、for写法（循环）。<br>演示相关的模板语法：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 模板语法，使用&#123;# #&#125;表示注释 --></span>    &#123;# 判断显示内容 #&#125;    &#123;% if name %&#125;    <span class="token comment">&lt;!-- janjo模板语法，双括号插值写法，|后面跟一个函数（首字母大写） --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>hello &#123;&#123; name|capitalize &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    &#123;% else %&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>请登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 选择代码块的结束标识 --></span>    &#123;% endif %&#125;    <span class="token comment">&lt;!-- for循环的使用 --></span>    &#123;% for general in my_list %&#125;        &#123;&#123; general &#125;&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!-- 循环代码块的结束标识 --></span>    &#123;% endfor %&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视图函数如下：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flask, render_templateapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;control&#39;)def control():    my_list &#x3D; [&#39;徐达&#39;, &#39;常遇春&#39;, &#39;郭英&#39;, &#39;蓝玉&#39;, &#39;傅友德&#39;, &#39;耿炳文&#39;]    return render_template(&#39;control.html&#39;, name&#x3D;&#39;xiaoming&#39;, my_list&#x3D;my_list)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器的本质就是函数。它的作用在于“微调”，即有时候我们需要对模板中的数据做一定的修改，比如更改格式（首字母大写、日期格式等），在模板中自然不能直接调用Python方法，这样一来，就需要用到过滤器。<br>语法格式如下：</p><p><code>&#123;&#123; variable | filter_name(*args) &#125;&#125;</code><br>variable即为变量，filter_name即为过滤器函数，*args 为过滤器接收的参数<br>常见的内置过滤器有</p><ul><li>upper：字符串中全部字符大写</li><li>lower：字符串中全部字符小写</li><li>reverse：字符串反转</li><li>format：格式化输出</li><li>first：取列表的首元素</li><li>last：去列表的尾元素</li><li>length：得到列表长度</li><li>sum：得到列表所有元素之和</li><li>sort：列表排序</li></ul><p>等等。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    &#123;% for item in my_list %&#125;    <span class="token comment">&lt;!-- upper为过滤器，表示将变量item全部大写 --></span>        &#123;&#123; item | upper &#125;&#125;    &#123;% endfor %&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flask, render_templateapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;&#39;)def show_filter():    my_list &#x3D; [&#39;www&#39;, &#39;wanda&#39;, &#39;amazi&#39;]    return render_template(&#39;filter.html&#39;, my_list&#x3D;my_list)if __name__&#x3D;&#x3D;&#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Flask-Request对象"><a href="#Flask-Request对象" class="headerlink" title="Flask Request对象"></a>Flask Request对象</h2><p>来自客户端网页的数据作为全局请求对象发送到服务器，为了处理请求数据，应该从Flask模块导入。</p><p>Request对象的重要属性如下：</p><ul><li>Form：字典对象，包含表单参数及其值的键、值；</li><li>args：解析查询字符串的内容，URL中？之后的部分；</li><li>Cookies：保存Cookie名称和值的字典对象；</li><li>files：与上传文件有关的数据；</li><li>method：当前的请求方法</li></ul><h2 id="Web表单"><a href="#Web表单" class="headerlink" title="Web表单"></a>Web表单</h2><p>web表单是web应用程序的基本功能。在Flask中，为了处理web表单，我们一般使用Flask-WTF扩展，它封装了WTForms，并且有验证表单数据的功能。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from curses import flashfrom flask import Flask, render_template, requestapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def index():    # request对象，里面包含请求的信息，包括请求方式    if request.method &#x3D;&#x3D; &#39;POST&#39;:        # 获取表单数据        form &#x3D; request.form        username &#x3D; form.get(&#39;username&#39;)        password &#x3D; form.get(&#39;password&#39;)        print(password)        if not all([username, password]):            # print(&#39;参数不完整&#39;)            # 使用消息闪现            flash(&#39;参数不完整&#39;)        elif password !&#x3D; &#39;123&#39;:            # print(&#39;密码错误...&#39;)            flash(&#39;密码错误!&#39;)        else:            return &#39;success&#39;    return render_template(&#39;login.html&#39;)if __name__&#x3D;&#x3D;&#39;__main__&#39;:    app.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="消息闪现flash"><a href="#消息闪现flash" class="headerlink" title="消息闪现flash"></a>消息闪现flash</h3><p>在上面的栗子中，我们使用了flash，它代替了print语句，也可以传递消息。</p><ul><li>视图函数中，我们使用flash，其中参数就是消息内容字符串</li><li>模板中，使用for循环遍历获取闪现消息</li></ul><h2 id="表单数据发送到模板"><a href="#表单数据发送到模板" class="headerlink" title="表单数据发送到模板"></a>表单数据发送到模板</h2><h3 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h3><p>有了前面的知识点，我们接下来研究如何将表单数据发送到模板。<br>我们的案例中，准备了两个模板文件student.html(收集表单数据)、result.html(展现收集到的表单数据，以表格形式)。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- student.html --></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://localhost:5000/result<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Name <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Physics <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Physics<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Chemistry <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>chemistry<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Maths <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Mathematics<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flask, render_template, requestapp &#x3D; Flask(__name__)# 首先进入&#x2F; URL页面，呈现具有表单的网页@app.route(&#39;&#x2F;&#39;)def student():    return render_template(&#39;student.html&#39;)@app.route(&#39;&#x2F;result&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])def result():    if request.method &#x3D;&#x3D; &#39;POST&#39;:        # 收集字典对象中的request.form中的表单数据，并给result.html        result &#x3D; request.form        return render_template(&#39;result.html&#39;, result&#x3D;result)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于student()绑定到URL /页面下，因此首先展示的就是student()中渲染的student.html文件，即展示表单；<br>而一旦有提交表单的POST请求，就会将请求中的表单数据给模板result.html来渲染。<br>result.html文件如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>1</span><span class="token punctuation">></span></span>        &#123;% for key, value in result.items() %&#125;        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span> &#123;&#123; key &#125;&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span> &#123;&#123; value &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        &#123;% endfor %&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Flask的WTF表单，提供了更加方便的写法：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from flask import Flask, render_template, request, flashfrom flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, SubmitFieldapp &#x3D; Flask(__name__)app.secret_key &#x3D; &#39;itheima&#39;  # 设置加密密钥&#39;&#39;&#39;使用WTF实现表单自定义一个表单类LoginForm&#39;&#39;&#39;class LoginForm(FlaskForm):    username &#x3D; StringField(u&#39;用户名:&#39;)    password &#x3D; PasswordField(u&#39;密码:&#39;)    submit &#x3D; SubmitField(u&#39;提交:&#39;)@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def login():    login_form &#x3D; LoginForm()    return render_template(&#39;wtf.html&#39;, form&#x3D;login_form)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板文件wtf.html内容如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        &#123;&#123; form.username.label &#125;&#125; &#123;&#123; form.username &#125;&#125;        &#123;&#123; form.password.label &#125;&#125; &#123;&#123; form.password &#125;&#125;        &#123;&#123; form.submit.label &#125;&#125; &#123;&#123; form.submit &#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在视图函数所在的.py文件，导入所需要的库之后，需要单独定一个类，并定义出表单所有项，然后将该类的实例对象给渲染函数，便于模板文件中使用。<br>在模板文件中，我们用FlaskForm继承类的表单项来获取相应的组件，通过其label属性来获取文本标签。可见上面.html栗子。</p><h4 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 开启wtf验证@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def login():    login_form &#x3D; LoginForm()    # 判断请求方式    if request.method &#x3D;&#x3D; &#39;POST&#39;:        # 获取请求参数        form &#x3D; request.form        username &#x3D; form.get(&#39;username&#39;)        password &#x3D; form.get(&#39;password&#39;)        # 验证参数，WTF可以一句话实现所有的校验        if login_form.validate_on_submit():            return &#39;success!&#39;        else:            flash(&#39;参数有误!&#39;)    return render_template(&#39;wtf.html&#39;, form&#x3D;login_form)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在Flask中使用数据库"><a href="#在Flask中使用数据库" class="headerlink" title="在Flask中使用数据库"></a>在Flask中使用数据库</h2><h2 id="Flask-Cookie"><a href="#Flask-Cookie" class="headerlink" title="Flask Cookie"></a>Flask Cookie</h2><p>Request对象包含Cookie的属性</p><h2 id="Flask-Session"><a href="#Flask-Session" class="headerlink" title="Flask Session"></a>Flask Session</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统——入门"><a href="#操作系统——入门" class="headerlink" title="操作系统——入门"></a>操作系统——入门</h2><p>操作系统（Operating System）—— 是计算机硬件和应用程序之间的一层软件</p><p>它最靠近硬件层，用于<br>CPU管理、内存管理、终端管理、磁盘管理、文件管理、网络管理、电源管理、多核管理。</p><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li></ul><p>操作系统形象地看来，就如同政府，本身不能实现任何有用的功能，但是可以提供一个方便其他程序执行的有用的工作环境。</p><p>下面我们从两个角度来探讨操作系统。</p><h3 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h3><p>对于大多数PC机，其操作系统设计的主要目的是为了用户使用方便；<br>对于大型机或者小型机，操作系统的设计目标是优化资源利用率。</p><h3 id="系统角度"><a href="#系统角度" class="headerlink" title="系统角度"></a>系统角度</h3><p>操作系统是资源分配器，调度CPU时间、内存空间、文件存储空间、I/O设备等。</p><h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><ul><li>计算机刚开机时，操作系统存放在磁盘disk上</li><li>开机后，基本I/O处理系统（简称BIOS）可以让计算机系统检测各种各样的外设</li><li>Bootloader将操作系统的代码和数据从硬盘加载到内存中，接下来跳转到操作系统的起始地址</li></ul><h2 id="操作系统的interface"><a href="#操作系统的interface" class="headerlink" title="操作系统的interface"></a>操作系统的interface</h2><p>一般来说，操作系统需要和外设和应用程序打交道。<br>操作系统与外设：中断技术<br>操作系统与应用程序：系统调用、异常</p><p>下面分别简要介绍这三种接口。</p><ul><li>系统调用（sys call）：应用程序主动向操作系统发出服务请求，来源于应用程序</li><li>异常：非法指令或者其他不良处理状态，来源于不良的应用程序</li><li>中断：来自不同的硬件设备的计时器和网络中断，来源于外设（键盘、鼠标等），它是一个相对持续的过程，对于用户来说是透明的，也就是说用户一般是察觉不到的。</li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断——外设事件，一般需要硬件和软件两方面参与。<br>硬件：设置中断标记（报价将中断事件设置中断标记、记下中断事件的ID）<br>软件：保存当前处理状态、中断服务程序处理、清除中断标记</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/mid-lake-pavilion.github.io/2022/02/05/Docker%E5%85%A5%E9%97%A8/"/>
      <url>/mid-lake-pavilion.github.io/2022/02/05/Docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript进阶</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/27/TypeScript%E8%BF%9B%E9%98%B6/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/27/TypeScript%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h2><p>泛型，就是在定义函数、接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 函数功能：接收用户输入，得到一个指定长度的数组，数组元素类型取决于输入的值的类型&#x2F;&#x2F; 这种写法并不好，并不知道最后返回值类型（any）function create(length: number, value: any): Array&lt;any&gt; &#123;    let result: any[] &#x3D; []    for(let i &#x3D; 0; i&lt;length; i++) &#123;        result[i] &#x3D; value    &#125;    return result&#125;&#x2F;&#x2F; 改用泛型function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] &#x3D; []    for(let i &#x3D; 0; i&lt;length; i++) &#123;        result[i] &#x3D; value    &#125;    return result&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在createArray()函数中，我们在函数名后面加上了&lt; T &gt;，用以指代任意输入的类型。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起一个新名字。<br><code>type 别名 = 数据类型</code></p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>字符串字面量类型，用来约束取值只能是某几个字符串中的一个。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">type EventNames &#x3D; &#39;click&#39; | &#39;scroll&#39;function handleEvent(ele: HTMLElement | null, event: EventNames) &#123;    console.log(&#39;666&#39;);&#125;&#x2F;&#x2F; 这两种写法没有错误handleEvent(document.querySelector(&#39;a&#39;) as HTMLElement, &#39;scroll&#39;)handleEvent(document.getElementById(&#39;hello&#39;), &#39;click&#39;)&#x2F;&#x2F; handleEvent(document.getElementById(&#39;div&#39;) as HTMLElement, &#39;mousemove&#39;)  报错，第二个参数不可以是mousemove<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组是合并了不同类型的对象的一种数据类型。与之类似的是数组，它合并了相同类型的对象。<br>它的声明方式与数组几乎无异，只不过在元组中，类型声明显得尤为重要。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 如下即声明了一个元组：一对值为string、number的元组let mar: [string, number] &#x3D; [&#39;Mar&#39;, 28]&#x2F;&#x2F; 访问元组的元素：索引下标访问即可console.log(mar[0]);console.log(mar[1]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>元组并非只能有两个元素，当向其中添加越界元素时，会受到类型限制。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 此时，若向mar中再添加元素，添加的第一个只能是字符串，第二个只能是numbermar.push(&#39;Hah&#39;)mar.push(90)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Enum类型用于取值被限定在·一定范围内的场景。<br>与C语言中的枚举类型几乎一致，使用enum关键字，语法格式如：<br><code>enum Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;</code><br>枚举成员会被赋值为从0开始递增的数字，同时也会对枚举值到枚举名进行反向映射。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">enum Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;console.log(Days[&quot;Sun&quot;])console.log(Days[0])console.log(Days[&quot;Sat&quot;] &#x3D;&#x3D;&#x3D; 6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>类是在ES6中引入的，此后，JavaScript也有了class关键字，用于声明一个类了。</p><p>简单介绍ES6以来，类的一些用法：</p><ul><li>首先，这里的class体现的是面向对象，和Java、c++中的面向对象几乎一致，都具有封装、继承、多态三大特性，此外也有存取器、修饰符、抽象类、接口等概念；</li><li>类中具有方法、属性且实例的属性可以直接在类里面定义（ES7）；</li><li>extends关键字用于实现继承，子类中使用super关键字来调用父类的构造函数（类似Java）；</li><li>类中也具有静态属性、静态方法，它们都可以直接通过类名来调用；</li><li>参数属性具有简便写法，修饰符可以出现在构造函数参数中，用于直接赋值；</li><li>只读属性关键字readonly，可以使属性不可以被修改；</li><li>abstract关键字，用于声明抽象类</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><p>接口不仅可以用于声明对象的形状，还可以对类的一部分行为进行抽象。<br>一般来说，在javascript中，一个类最多只能继承自一个类，但是如果要真的有继承多个类的打算，就需要单独将它们做成接口，然后分别实现。</p><p>比如，对于一般的车，假设只有行驶（run）功能：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">class Car &#123;    run() &#123;        console.log(&#39;I can run.&#39;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要想让它实现接口，如下书写即可：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 类与接口&#x2F;&#x2F; 接口：可以警鸣interface Alarmable &#123;    alert(): void&#125;interface Lightable &#123;    lighten(): void&#125;&#x2F;&#x2F; 类：车class Car implements Alarmable, Lightable &#123;    run() &#123;        console.log(&#39;I can run.&#39;);    &#125;    alert(): void &#123;        console.log(&#39;I can alert!&#39;);    &#125;    lighten(): void &#123;        console.log(&#39;I can lighten everything!&#39;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><p>即：如果定义了两个相同名字的函数、接口或者类，那么它们会合并成一个类型。<br>下面演示接口的合并：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 如下两个接口声明可以合并interface Foldable &#123;    price: number&#125;interface Foldable &#123;    weight: number&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 玩转TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript基础</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/26/TypeScript%E5%9F%BA%E7%A1%80/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/26/TypeScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>鉴于TypeScript和JavaScript之间的紧密联系，我们首先需要清楚JavaScript的原始数据类型有哪些：</p><ul><li>布尔值 boolean</li><li>数值 Number</li><li>字符串 string</li><li>null</li><li>undefined</li><li>Symbol（来自ES6）</li><li>BigInt（来自ES10）</li></ul><p>以上，前五种来自ES5，后面两种诞生较迟。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">let isDone: boolean &#x3D; flaselet num: number &#x3D; 9let str: string &#x3D; &#39;Tom&#39;let sentence: string &#x3D; &#96;My name is $&#123;str&#125;&#96;function sayHello(): void &#123;console.log(&#39;Hello!&#39; + sentence)&#125;let un: undefined &#x3D; undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在TypeScript中，还有一种重要的数据类型——元组（tuple）。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 如下即声明了一个元组：一对值为string、number的元组let mar: [string, number] &#x3D; [&#39;Mar&#39;, 28]&#x2F;&#x2F; 访问元组的元素：索引下标访问即可console.log(mar[0]);console.log(mar[1]);&#x2F;&#x2F; 此时，若向mar中再添加元素，添加的第一个只能是字符串，第二个只能是numbermar.push(&#39;Hah&#39;)mar.push(90)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h2><p>对于规定了数据类型的变量，在赋值过程中不允许被改变类型，否则报错。<br>但是规定为any类型，则是可以被赋值为任意类型的。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">let anything: any &#x3D; &#39;Tom&#39;console.log(anything.name);console.log(anything.age);  &#x2F;&#x2F; 均输出 undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>类型推论规则：在变量赋值时，虽然有时候并没有指定类型，但是会根据赋值的结果自动推断其类型。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">let str &#x3D; &#39;Hello&#39;&#x2F;&#x2F; 会根据&#39;Hello&#39;自动将str规定为string类型let anyone&#x2F;&#x2F; 若没有赋值，则自动为any类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>使用 | 将多个可能的数据类型分隔。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">let identity: string | number&#x2F;&#x2F; 允许identity变量是string或者number类型identity &#x3D; &#39;872092&#39;identity &#x3D; 872092<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是，即使是联合类型的变量，在赋值时也会根据类型推论的规则，推断出来一个类型。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是对行为的抽象，此外，在TypeScript中，它也常用于对对象的形状进行描述。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; interface就是接口的关键字interface Person &#123;    name: string;    age: number;    readonly indentity: string | number;&#x2F;&#x2F; readonly 表示成员只读    birthPlace?: string; &#x2F;&#x2F; ?表示可选属性，允许变量与接口在该成员上的不完全匹配    [propName: string | number]: any&#x2F;&#x2F; 表示可选属性和确定属性都必须是string或者number类型&#125;&#x2F;&#x2F; 定义的变量中，必须严格按照接口来声明成员，多一个、少一个都不可以let tom: Person &#x3D; &#123;    name: &#39;Tom&#39;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>readonly关键字，用于声明某一成员为只读属性，注意这个只读是针对第一次给对象赋值时候的约束，而不是第一次给该只读属性赋值时。</li><li>[propName: string]，表示定义了任意属性取string类型的值</li></ul><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5]let fibonacci2: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接口中也可以描述数组：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">interface NumberArray &#123;&#x2F;&#x2F; 表示：只要索引（下标）类型是数字，那么值的类型必须是数字[index: number]: number&#125;let fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数的两种写法：函数声明和函数表达式，它们的TypeScript写法如下：</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 定义两数相加的函数&#x2F;&#x2F; 函数声明function sum(x: number, y: number): number &#123;    return x + y&#125;console.log(sum(1, 1));     &#x2F;&#x2F; 2&#x2F;&#x2F; 函数表达式&#x2F;&#x2F; TypeScript的完整写法let mySum: (x: number, y: number) &#x3D;&gt; number &#x3D; function(x: number, y: number): number &#123;    return x + y&#125;console.log(mySum(1, 1));   &#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，由于函数表达式的写法较为繁琐，有时也可以采用接口方式声明。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 用接口定义函数形状interface SearchFunc &#123;    (source: string, subString: string): boolean&#125;let mySearch: SearchFunc&#x2F;&#x2F; 函数：判断一个字符串是否为另一个字符串的子串mySearch &#x3D; function(source: string, subString: string) &#123;    return source.search(subString) !&#x3D;&#x3D; -1&#125;console.log(mySearch(&#39;Hello, JavaScript!&#39;, &#39;Hello&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载是为了准确地声明函数的接收参数和返回类型。</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 函数重载&#x2F;&#x2F; 函数功能: 接收参数,若为数字123,则返回321,若为字符串&#39;123&#39;,则返回&#39;hello&#39;function reverse(x: number): numberfunction reverse(x: string): string&#x2F;&#x2F; 定义函数function reverse(x: number | string): number | string | void &#123;    if( typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;))    &#125; else if ( typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39; ) &#123;        return x.split(&#39;&#39;).reverse().join()    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言，即Type Assertion，用于手动指定一个值的类型。语法如：<br><code>值 as 类型</code></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>将一个联合类型断言为其中一个类型，因为有时候我们确实需要其中一个类型特有的方法或者属性。</li><li>父类可以被断言为子类</li><li>任何类型都可以被断言为any</li><li>any可以被断言为任何类型</li></ol><h3 id="类型断言的限制"><a href="#类型断言的限制" class="headerlink" title="类型断言的限制"></a>类型断言的限制</h3><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; 只有在兼容情况下，才可以使用断言&#x2F;&#x2F; 兼容：可以类比为面向对象里的继承，下面的栗子中，我们可以说，Animal兼容Catinterface Animal &#123;    name: string&#125;interface Cat &#123;    name: string    run(): void&#125;&#x2F;&#x2F; Animal和Cat可以相互断言<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>内置对象，是指根据标准，在全局作用域上存在的对象，这里的标准指ECMAScript和其他环境（如DOM）的标准。</p><h3 id="ES的内置对象"><a href="#ES的内置对象" class="headerlink" title="ES的内置对象"></a>ES的内置对象</h3><p>包括：</p><ul><li>Boolean</li><li>Error</li><li>Date</li><li>RegExp等</li></ul><h3 id="DOM和BOM中的内置对象"><a href="#DOM和BOM中的内置对象" class="headerlink" title="DOM和BOM中的内置对象"></a>DOM和BOM中的内置对象</h3><p>包括：</p><ul><li>Document</li><li>HTMLElement    HTML元素</li><li>Event    事件</li><li>NodeList    节点列表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 玩转TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript概述</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/25/Typescript%E6%A6%82%E8%BF%B0/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/25/Typescript%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>Typescript的核心特性——类型（type），极大程度上弥补了JavaScript的缺点。</p><h2 id="静态类型语言TypeScript"><a href="#静态类型语言TypeScript" class="headerlink" title="静态类型语言TypeScript"></a>静态类型语言TypeScript</h2><p>类型系统按照类型检查时机可以分为</p><ul><li>动态类型：在运行时才会进行类型检查，而其类型错误往往会导致运行出错，如JavaScript。</li><li>静态类型：在编译阶段就能确定每一个变量的类型，从而进行类型检查，其类型错误往往导致语法错误，如TypeScript、C语言。</li></ul><p>静态类型语言的特点：</p><ul><li>对类型极度严格，比如C</li><li>可以立即发现错误</li><li>运行时性能更加良好</li><li>自文档化</li></ul><h2 id="弱类型语言TypeScript"><a href="#弱类型语言TypeScript" class="headerlink" title="弱类型语言TypeScript"></a>弱类型语言TypeScript</h2><p>类型系统按照是否允许隐式类型转换可以分为</p><ul><li>强类型</li><li>弱类型：允许隐式类型转换，如TypeScript、JavaScript</li></ul><h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><ol><li>完全兼容JavaScript；</li><li>可以编译为JavaScript，然后运行在浏览器、Node.js等任何能运行JavaScript的环境中；</li><li>可以与JavaScript并存，JavaScript项目可以渐进式迁移到TypeScript。</li><li>与标准同步发展。</li></ol><p>在今后的编写TypeScript代码中，我们以vscode为编辑器进行练习。需要注意的是，写好的TypeScript代码（.ts文件）需要先编译成JavaScript代码（.js文件），然后再运行.js文件（静态类型语言编译、运行）。<br>当然，借助vscode的codder runner插件，我们也可以直接跑代码，操作起来更加简便，但是本质上都是先编译、再运行的。</p><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>类似于强类型语言中的类型声明，也可以对变量类型进行约束，如</p><p><code>let name: string = &#39;杨继盛&#39;</code></p>]]></content>
      
      
      <categories>
          
          <category> 玩转TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系型数据库</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/24/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/24/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h3><p>关系模型是从表以及表的处理方式中抽象出来的，引入了集合理论与逻辑学理论的知识。</p><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><p>一个关系就是一个Table。我们学习关系模型，就是要学习：Table如何描述，有哪些操作、结果如何、有哪些约束等。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>三要素：</p><ul><li>基本结构：Table</li><li>基本操作：并、差、广义积等</li><li>完整性约束</li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h3><p>R(A1: D1, A2: D2, …, An: Dn)<br>关系模式中属性向域的映像在很多DBMS中一般直接说明为属性的类型、长度等，例如：<br>Student(S# char(8), Sname char(10), Ssex char(2), Sage integer, D# char(2), Sclass char(6))<br>表名为Student，属性名Sname是长度为10的char型数据</p><h3 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h3><ul><li>属性不可再分，即关系第一范式</li></ul><blockquote><p>关系和表其实是有一定差别的。关系是一个严格的数学定义，而表是记录的集合，表允许有重复的元组（行）。</p></blockquote><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul><li>候选码（候选键）：是关系中的一个属性组，其值能够唯一地标识一个元组（表中的某一行），若从该属性组中去掉任何一个属性，它就不再具有这一性质。<br>如Student(S#, SIdentity, Sname, Ssex, Sage, Sclass)表中，S#和SIdentity都可以唯一地标识一个元组，故(S#, SIdentity)可以作为候选码。</li><li>主码（主键）：当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组。比如上面的候选码中，我们就可以选定S#作为主码。</li><li>主属性与非主属性：包含在任何一个候选码中的属性被称作主属性，否则就是非主属性。</li><li>外码（外键）：关系R中的一个属性组，虽不是R的候选码，但是与另一个关系S的候选码对应。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库入门概念</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8%E6%A6%82%E5%BF%B5/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>相互有关系的若干表的集合。<br>关系型数据库是基础，由此产生了各种形式的数据的数据库，比如图像数据库。</p><h3 id="数据库系统的构成"><a href="#数据库系统的构成" class="headerlink" title="数据库系统的构成"></a>数据库系统的构成</h3><ul><li>数据库DB：相互具有关联关系的数据的集合</li><li>数据库管理系统DBMS：用于管理数据库的一种系统软件</li><li>数据库应用程序DBAP：为用户使用的完成某一功能的应用程序</li><li>数据库管理员DBA：管理数据库的人员</li><li>计算机基本系统：是以上数据库系统能够运行起来的必要条件。</li></ul><p>以图书管理数据库系统（业务数据库系统）为例：</p><ul><li>数据库就是各种数据表，如出版社表、图书表、借阅登记表等；</li><li>数据库管理系统就是Oracle或者SQL Server等。</li><li>而数据库应用程序，是面向普通用户的应用程序</li></ul><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><p>从用户角度看，数据库管理系统应当具有数据定义、数据操纵、数据控制以及其他各种操作的执行。<br>数据库语言，与高级语言相比，一条数据库语句相当于高级语言的一个或者多个循环程序。</p><p>从系统角度看，DBMS为了完成数据库管理，在后台会运行一系列程序：</p><ul><li>语言编译器</li><li>查询优化与查询实现</li><li>数据存取与索引</li><li>通信控制程序</li><li>事务管理程序</li><li>故障恢复程序等</li></ul><h3 id="数据库系统的标准结构"><a href="#数据库系统的标准结构" class="headerlink" title="数据库系统的标准结构"></a>数据库系统的标准结构</h3><h4 id="数据库管理系统的三个层次"><a href="#数据库管理系统的三个层次" class="headerlink" title="数据库管理系统的三个层次"></a>数据库管理系统的三个层次</h4><ol><li>外部层次（用户层次）<br>即某一用户能够看到与处理的数据，是全局数据中的一部分。</li><li>概念层次（逻辑层次）<br>即从全局角度理解的数据。</li><li>内部层次（物理层次）<br>存储在介质上的数据，含存储路径、存储方式、索引方式等。</li></ol><h4 id="数据与模式"><a href="#数据与模式" class="headerlink" title="数据与模式"></a>数据与模式</h4><ul><li>模式：对数据库中数据所进行的一种结构性的描述。</li><li>视图：某一种表现形式下表现出来的数据库中的数据。</li></ul><p>模式是对视图的一种抽象，而视图则是模式在一种表现形式下的数据。</p><h5 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h5><ul><li>外模式</li><li>概念模式</li><li>内模式</li></ul><h5 id="两层映像"><a href="#两层映像" class="headerlink" title="两层映像"></a>两层映像</h5><ul><li>E-C Mapping：将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li><li>C-I Mapping：将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>规定模式统一描述方式的模型，包括：数据结构、操作、约束<br>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象<br>以关系模型为例：<br>关系模型：</p><ul><li>所有模式都可以为抽象表的形式    ——数据结构</li><li>而每一个具体的模式都是拥有不同列名的具体的表</li><li>对这种表形式的数据有哪些操作和约束</li></ul><p>三大经典数据模型</p><ul><li>关系模型（表结构）</li><li>层次模型（树形结构）</li><li>网络模型（图结构）</li></ul><h3 id="数据库系统的演变与发展"><a href="#数据库系统的演变与发展" class="headerlink" title="数据库系统的演变与发展"></a>数据库系统的演变与发展</h3><p>四个阶段</p><ul><li>文件系统发展到数据库</li><li><p>由层次模型数据库、网状模型数据库到关系型数据库</p><blockquote><p>关系型数据库满足关系第1范式，数据不可再分</p></blockquote></li><li><p>由关系型数据库到对象关系数据库、面向对象数据库</p><blockquote><p>可有效支持不满足关系第1范式的数据项<br>以对象来封装需分解的数据项</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/21/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/21/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>近世代数的特点：抽象、思维难度大。<br>学习这门课程的两个关键点：</p><ol><li>理解概念，把握基础</li><li>掌握一些常见的技巧</li></ol><p>本节从贯穿整个近世代数知识体系的基本概念入手，厘清它们的联系，并回顾集合论中的相关概念。</p><p>代数运算</p><p>本质：映射。<br>定义X为一个集合，<br>● 从X×X到X的映射f称为X上的二元运算<br>● 从X到X的映射f称为X上的一元运算</p>]]></content>
      
      
      <categories>
          
          <category> 近世代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式设计</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/20/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/20/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>响应式设计并不是一项技术，而是一种设计模式，通常包括三步：</p><ul><li>设置meta标签</li><li>媒体查询</li><li>长度单位的合理使用</li></ul><h2 id="设置meta标签"><a href="#设置meta标签" class="headerlink" title="设置meta标签"></a>设置meta标签</h2><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>即针对不同的设备尺寸，设置对应的样式。随着屏幕宽度的增大或减小，后面的样式会覆盖前面的样式。<br>对于pc端和移动端，样式的优先顺序有所不同：移动端优先使用min-width，PC端优先使用max-width。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The County Fair</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/16/The-County-Fair/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/16/The-County-Fair/</url>
      
        <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先需要明确的是，我们要尽可能地按照礼品发放时间先后顺序考虑来拿取礼品，这样才会拿到数量更多的礼品。<br>这里提供一种动态规划的思路做法。我们需要用数组存储每一个集市以及它发放礼品的时间。在按照时间从小到大顺序排序（sort）之后，考虑第i个礼品拿到的情况下，前i个礼品中拿到礼品的数量，记作dp[i]。此时，需要遍历i号元素之前的所有元素。一旦时间上可以满足“从j号集市赶到i号集市，拿到i号集市的礼品”，就考虑是否更新dp[i]（考虑原来的dp[i]和dp[j]+1哪个更大）。不满足dp[i]保持不变。状态转移方程即为：</p><p><code>dp[i] = max(dp[i], dp[j]+1)    // j小于i，</code></p><h2 id="关键代码实现"><a href="#关键代码实现" class="headerlink" title="关键代码实现"></a>关键代码实现</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef pair&lt;int, int&gt; P;&#x2F;&#x2F; &lt;集市号，分发时间&gt;int mapt[405][405];&#x2F;&#x2F; t_i,jP mak[405];for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;    for (int j &#x3D; 0; j &lt; i; j++)    &#123;        &#x2F;&#x2F; 表示可以赶上第i个礼品发放时间        if (mapt[mak[j].first][mak[i].first] + mak[j].second &lt;&#x3D; mak[i].second)        &#123;            dp[i] &#x3D; (dp[j] + 1) &gt; dp[i] ? (dp[j] + 1) : dp[i];        &#125;        &#x2F;&#x2F; 如果赶不上，默认dp[i]保持不变，不作处理    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;int mapt[405][405];P mak[405];int dp[405];int n;int ans;bool com(P a, P b)&#123;    return a.second &lt; b.second;&#125;int main()&#123;    cin &gt;&gt; n;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        int t;        cin &gt;&gt; t;        mak[i] &#x3D; &#123; i,t &#125;;    &#125;    mak[0] &#x3D; &#123; 1,0 &#125;;   &#x2F;&#x2F; 记录初始情况，t&#x3D;0，从1号集市开始    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)        &#123;            cin &gt;&gt; mapt[i][j];        &#125;    &#125;    sort(mak + 1, mak + 1 + n, com);       for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        for (int j &#x3D; 0; j &lt; i; j++)        &#123;            &#x2F;&#x2F;表示可以赶上第i个礼品发放时间            if (mapt[mak[j].first][mak[i].first] + mak[j].second &lt;&#x3D; mak[i].second)            &#123;                dp[i] &#x3D; (dp[j] + 1) &gt; dp[i] ? (dp[j] + 1) : dp[i];            &#125;        &#125;    &#125;        &#x2F;&#x2F; 注意，需要综合考虑所有的dp，取其中的最大值，因为之前的“dp[i]表示第i个礼品一定取到”只是一个假设，但是总会取到一个礼品，使得最后的礼品数量最多    sort(dp + 1, dp + 1 + n);    cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Node.js</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/14/%E5%88%9D%E8%AF%86Node-js/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/14/%E5%88%9D%E8%AF%86Node-js/</url>
      
        <content type="html"><![CDATA[<h2 id="一些先导概念"><a href="#一些先导概念" class="headerlink" title="一些先导概念"></a>一些先导概念</h2><h3 id="浏览器中的JavaScript运行环境"><a href="#浏览器中的JavaScript运行环境" class="headerlink" title="浏览器中的JavaScript运行环境"></a>浏览器中的JavaScript运行环境</h3><p>这是前端开发的常见运行环境。<br>运行环境是指，代码正常运行所需的必要环境。<br>以Chrome浏览器为例，它的运行环境包括了V8引擎和内置API，当然还需要待执行的JavaScript代码了。</p><ul><li>其中，V8引擎负责解析和执行JavaScript代码；</li><li>而内置的API则是由运行环境提供的特殊接口，只能在所属的运行环境中被调用。</li></ul><h3 id="node-js简介"><a href="#node-js简介" class="headerlink" title="node.js简介"></a>node.js简介</h3><p>这是后端开发的常见运行环境。<br>Node.js中的javascript运行环境包括V8引擎和内置API，而后者就是我们学习Node的一个重点之一。<br>注意，在Node.js中，我们无法调用DOM和BOM等浏览器内置API。</p><h3 id="node-js的作用"><a href="#node-js的作用" class="headerlink" title="node.js的作用"></a>node.js的作用</h3><ul><li>基于Express框架，构建Web应用</li><li>基于Electron框架，构建跨平台的桌面应用</li><li>基于restify框架，构建API接口项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码与JavaScript知识点回顾</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/12/Vue%E6%BA%90%E7%A0%81%E4%B8%8EJavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/12/Vue%E6%BA%90%E7%A0%81%E4%B8%8EJavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<p>学习Vue的源码，过程中少不了要补习补习javascript的知识，以此博客作为简要记录。</p><ol><li>plain javascript object，js简单对象<br>简单对象就是通过“{}”或者“new Object”创建的对象。使用typeof运算符的结果为object且不为null。</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!=</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>&amp;&amp;运算符<br>特别地，当&amp;&amp;两边都是boolean类型表达式时，整个与运算结果为true当且仅当两边的表达式结果都为true。<br>一般地，&amp;&amp;运算符返回从左到右求值时遇到的第一个false操作数的值；当它们都是true时，返回最后一个操作数的值。<blockquote><p>如果一个值可以转换为true，那么它就是真值，否则就是假值。<br>可以转化为false的假值包括：<br>false<br>null<br>NaN<br>0<br>空字符串<br>undefined</p></blockquote></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">result <span class="token operator">=</span> <span class="token string">'foo'</span> <span class="token operator">&amp;&amp;</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// return 4, for 'foo' and 4 are both true value</span>result <span class="token operator">=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">undefined</span><span class="token comment">// return '', for '' and undefined are both false value while '' is the former</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h2><p>JavaScript中的in运算符，用于检测某一对象中是否存在某一属性<br><code>const isExist = key in obj</code><br>如果对象obj中具有属性key，isExist为true，否则为false。<br>如果一个属性是从原型链上继承而来，in运算符也会返回true：<br><code>const a = &quot;toString&quot; in &#123;&#125;</code><br>上面的栗子中，{}表示空对象实例，它其实继承了Object，toString在<strong>proto</strong>上，返回true。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>根据现有的对象来作为新创建对象的原型<strong>proto</strong>。<br>我们来看看vue2.x源码中的一个细节：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const arrayProto &#x3D; Array.prototype&#x2F;**将数组原型链prototype上面的所有方法放到一个对象————arrayMethods里面 *&#x2F;export const arrayMethods &#x3D; Object.create(arrayProto)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><h3 id="Function-call"><a href="#Function-call" class="headerlink" title="Function.call()"></a>Function.call()</h3><p>语法格式：<br><code>Function.call(thisArg, arg1, arg2, ...)</code><br>其中，thisArg是Function在运行时的this，可以使用该函数实现继承。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">function Product(name, price) &#123;    this.name &#x3D; name    this.price &#x3D; price&#125;function Food(name, price) &#123;    console.log(&#39;Food调用了.&#39;, this)    Product.call(this, name, price)    this.category &#x3D; &#39;food&#39;&#125;console.log(new Food(&#39;cheese&#39;, 5.9));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面栗子中，虽然调用了<code>Product.call(this, name, price)</code>，但是该函数参数中的this指向的是Food函数对象，而调用该函数之后的Food对象为：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">Food <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> 'cheese'<span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">5.9</span><span class="token punctuation">,</span> category<span class="token operator">:</span> 'food'<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="With语句"><a href="#With语句" class="headerlink" title="With语句"></a>With语句</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据解析</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/11/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/11/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="数据解析概述"><a href="#数据解析概述" class="headerlink" title="数据解析概述"></a>数据解析概述</h2><p>数据解析往往是爬取页面后重要的一步,用来提取有效的、我们想要的数据信息。常用的数据解析方式包括</p><ul><li>re解析</li><li>bs4解析</li></ul><h2 id="re解析"><a href="#re解析" class="headerlink" title="re解析"></a>re解析</h2><p>re解析是一种速度较快的数据解析方式，主要涉及正则表达式的使用。正则表达式，是一种使用表达式的方式，对字符串进行匹配的语法规则。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote><p>正则表达式的语法：能使用元字符（具有固定含义的特殊符号）进行排列组合用来匹配字符串。<br>.        匹配任意一个字符<br>\w    匹配一个字母、数字、下划线<br>\s    匹配任意一个的空白符<br>\d    匹配一个数字<br>|n    匹配一个换行符<br>\t    匹配一个制表符<br>^        匹配字符串的开始<br>$        匹配字符串的结尾<br>下面的大写元字符是之前小写元字符的取反<br>\W    匹配一个非字母、非数字、非下划线<br>\D    匹配一个非数字<br>\S    匹配一个非空白符<br>a|b    匹配字符a或者字符b<br>()    匹配括号内的表达式，也表示一个组<br>[…]        匹配字符组中的字符</p><p>下面的是控制前面元字符出现次数的量词<br>*    重复零次或者多次<br>+    重复一次或者更多次<br>?    重复零次或者一次<br>{n}    重复n次<br>{n,}    重复n次或者更多次<br>{n, m}    重复n到m次</p></blockquote><p>如前所说，正则表达式语法需要掌握元字符的写法。灵活运用上述元字符，可以实现各种匹配要求。<br>[a-zA-Z0-9]：表示匹配字符串中所有的字母和数字</p><p>正则表达式中的贪婪匹配与惰性匹配：</p><ul><li>.*    贪婪匹配</li><li>.*?    惰性匹配</li></ul><p>之前我们已经知道，？是量词，重复一次或者两次的量词，也就是说，惰性匹配中，？限制了前面的元字符*的出现次数（尽可能地少），因此惰性匹配尽可能的匹配到较短的匹配内容。</p><blockquote><p>例如，待检测字符串“玩儿吃鸡游戏，晚上一起上游戏，干嘛呢？打游戏啊！<br>如果匹配字符串为 玩儿.<em>?游戏，匹配结果为：玩儿吃鸡游戏<br>而如果匹配字符串为 玩儿.</em>游戏，匹配结果为：玩儿吃鸡游戏，晚上一起上游戏，干嘛呢？打游戏</p></blockquote><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>爬取网页内容，拿到源码之后，通常在要提取的内容附近找到标识字符串，通过(?P&lt; name &gt;)写法，由”name”标记拿到数据。<br>比如，在爬取电影天堂网页数据时，要提取出电影名，现在找到其源码片段如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--&#123;start:最新--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>co_area2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title_all<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>最新电影更新:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>co_content2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20160320/50523.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>IMDB评分8分左右影片500余部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/dyzz/20220114/62205.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年剧情喜剧《腿》BD国语<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20220113/62204.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年惊悚动作《僵局救援/反<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20220112/62203.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年动作奇幻《东京复仇者<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/dyzz/20220112/62202.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年科幻动作《永恒族/永恒<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/dyzz/20220112/62201.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年喜剧悬疑《不速来客》H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20220109/62196.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2022年动作《特种兵/特攻队员<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20220111/62200.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年喜剧《大红狗克里弗》B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/dyzz/20220111/62199.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年喜剧《亚当斯一家2》BD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20220111/62198.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2021年悬疑《角色》BD日语中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/dyzz/20220111/62197.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2022年纪录片《哈利·波特20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/html/gndy/jddy/20220109/62195.html<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>2022年悬疑《新洗冤录》HD国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现，片名都在“《》”中，因此可以定义如下正则字符串：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 上述源码已经爬取保存到page中，re.S表示忽略换行符str &#x3D; re.compile(r&quot;&lt;ul&gt;.*?《(?P&lt;name&gt;.*?)》&quot;, re.S)# 通过懒匹配可以拿到对应的数据，注意写法，且返回迭代器给namesnames &#x3D; str.finditer(page)for it in names:print(it.group(&quot;name&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bs4解析"><a href="#bs4解析" class="headerlink" title="bs4解析"></a>bs4解析</h2><p>bs4是Python中的第三方库，其中的BeautifulSoup可以用来进行数据解析。<br>基本用法：</p><ol><li>将页面源代码交给BeautifulSoup进行处理，生成bs对象；</li><li>从bs对象中查找数据，要掌握两个方法；</li></ol><ul><li>find(标签, 属性=值)    返回符合条件的一个html标签</li><li>find_all(标签, 属性=值)    返回符合条件的全部html标签</li></ul><ol><li>可以使用text属性拿到被标签标记的内容，也可以通过get(属性)拿到标签的属性。</li></ol><p>实例：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 使用bs4筛选数据，爬取优美图库# 步骤# 1. 拿到主页面的源代码，拿到链接地址href# 2. 通过href拿到子页面内容，从子页面中找到图片下载地址# 3. 下载图片import requestsfrom bs4 import BeautifulSoupdomain &#x3D; &quot;https:&#x2F;&#x2F;www.umei.cc&#x2F;bizhitupian&#x2F;diannaobizhi&#x2F;&quot;img_urls &#x3D; []header &#x3D; &#123;    &quot;User-agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;96.0.4664.110 Safari&#x2F;537.36&quot;&#125;resp &#x3D; requests.get(domain)resp.encoding &#x3D; &quot;utf-8&quot;# 生成bs对象page_content &#x3D; BeautifulSoup(resp.text, &quot;html.parser&quot;)div &#x3D; page_content.find(&#39;div&#39;, attrs&#x3D;&#123;&quot;class&quot;: &quot;TypeList&quot;&#125;)links &#x3D; div.find_all(&#39;a&#39;, class_&#x3D;&quot;TypeBigPics&quot;)for link in links:    # links列表中的每一个元素都是一个a标签    # print(link)    # 直接通过get就可以拿到属性的值    img_url &#x3D; domain+link.get(&#39;href&#39;)[-10:]    # 1. 拿到子页面源代码    resp_img &#x3D; requests.get(img_url, headers&#x3D;header)    resp_img.encoding &#x3D; &#39;utf-8&#39;    img_subcontent &#x3D; BeautifulSoup(resp_img.text, &quot;html.parser&quot;)    # 2. 从子页面中拿到图片地址    p &#x3D; img_subcontent.find(&#39;p&#39;, attrs&#x3D;&#123;        &quot;align&quot;: &quot;center&quot;    &#125;)    download &#x3D; p.find(&#39;img&#39;).get(&#39;src&#39;)    print(download)    resp_img.close()    # 3. 下载图片    resp_download &#x3D; requests.get(download)    img_name &#x3D; download.split(&#39;&#x2F;&#39;)[-1]  # 将最后一个&#x2F;后的内容作为图片名    with open(&quot;D:&#x2F;programming_exercises&#x2F;2022寒假javascript&#x2F;资源存放文件夹&#x2F;网络爬虫图片&#x2F;&quot;+img_name, mode&#x3D;&quot;wb&quot;) as f:        f.write(resp_download.content)  # 将字节内容写入文件    print(&quot;图片下载完成&quot;)    # 追加到links数组中    img_urls.append(link.get(&#39;href&#39;))for item in img_urls:    url &#x3D; domain+item.strip(&#39;&#x2F;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络爬虫</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/09/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/09/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫基本概念"><a href="#爬虫基本概念" class="headerlink" title="爬虫基本概念"></a>爬虫基本概念</h2><h3 id="何为网络爬虫"><a href="#何为网络爬虫" class="headerlink" title="何为网络爬虫"></a>何为网络爬虫</h3><p>所谓爬虫（网络机器人），就是编写程序，模拟浏览器发送网络请求，接收请求响应，按照一定的规则，自动地抓取互联网信息的程序。</p><h3 id="爬虫的意义"><a href="#爬虫的意义" class="headerlink" title="爬虫的意义"></a>爬虫的意义</h3><p>互联网大数据时代，面对海量的数据，如何获取到有效的信息显得十分关键。而网络爬虫为我们提供了一种筛选相关信息并分析整合的手段，是一种强有力的工具。</p><h3 id="爬虫准备"><a href="#爬虫准备" class="headerlink" title="爬虫准备"></a>爬虫准备</h3><p>做爬虫，其实很多语言都可，例如Python，PHP，Java等，当然其中最简单的是Python了，并且功能也比较齐全。<br>在Python中，一些常用的库包括：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from bs4 import BeautifulSoup   # 网页解析，获取数据import re   # 正则表达式，进行文字匹配import urllib.request, urllib.error # 指定URL，获取网页数据import xlwt # 进行excel操作import sqlite3  # 进行SQLite数据库操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个入门案例"><a href="#一个入门案例" class="headerlink" title="一个入门案例"></a>一个入门案例</h2><p>爬取豆瓣评分电影Top250：<a href="https://movie.douban.com/top250">https://movie.douban.com/top250</a><br>爬取内容包括：</p><ul><li>电影详情链接</li><li>图片链接</li><li>影片中文名</li><li>影片外国名</li><li>评分</li><li>评价数</li><li>概况</li><li>相关信息</li></ul><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 开头设置编码为utf-8，写在开头，防止乱码问题# -*- codeing &#x3D; utf-8 -*-# 导入用到的库from bs4 import BeautifulSoup  # 网页解析，获取数据import re  # 正则表达式，进行文字匹配&#96;import urllib.request, urllib.error  # 制定URL，获取网页数据import xlwt  # 进行excel操作#import sqlite3  # 进行SQLite数据库操作# 逐一解析数据：使用正则表达式，用来筛选、匹配信息findLink &#x3D; re.compile(r&#39;&lt;a href&#x3D;&quot;(.*?)&quot;&gt;&#39;)  # 创建正则表达式对象，标售规则   影片详情链接的规则findImgSrc &#x3D; re.compile(r&#39;&lt;img.*src&#x3D;&quot;(.*?)&quot;&#39;, re.S)findTitle &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;title&quot;&gt;(.*)&lt;&#x2F;span&gt;&#39;)findRating &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;rating_num&quot; property&#x3D;&quot;v:average&quot;&gt;(.*)&lt;&#x2F;span&gt;&#39;)findJudge &#x3D; re.compile(r&#39;&lt;span&gt;(\d*)人评价&lt;&#x2F;span&gt;&#39;)findInq &#x3D; re.compile(r&#39;&lt;span class&#x3D;&quot;inq&quot;&gt;(.*)&lt;&#x2F;span&gt;&#39;)findBd &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;&quot;&gt;(.*?)&lt;&#x2F;p&gt;&#39;, re.S)# 大体流程分三步走：# 1. 爬取网页# 2. 逐一解析数据# 3. 保存网页def main():# baseurl指定了我们要爬取的网页地址    baseurl &#x3D; &quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;  # 要爬取的网页链接    # 1.爬取网页    datalist &#x3D; getData(baseurl)    savepath &#x3D; &quot;豆瓣电影Top250.xls&quot;    #当前目录新建XLS，存储进去    # dbpath &#x3D; &quot;movie.db&quot;              #当前目录新建数据库，存储进去    # 3.保存数据    saveData(datalist,savepath)      # 保存到xls表和sqlite数据库，2种存储方式可以只选择一种，这里选择前者，故保存到数据库代码全部注释掉了    # saveData2DB(datalist,dbpath)# 函数功能：爬取网页def getData(baseurl):    datalist &#x3D; []  # 用来存储爬取的网页信息，经过解析后符合要求的数据存放于此        # 由于豆瓣电影评分Top250，每一个页面只显示25个，所以需要访问页面10次    for i in range(0, 10):  # 调用获取页面信息的函数，10次        url &#x3D; baseurl + str(i * 25)# 根据i取值的不同，得到不同的url（仅仅start后面的参数不同而已）        html &#x3D; askURL(url)  # askURL()是请求网页的主体方法，保存获取到的网页源码        # 2. 逐一解析数据        soup &#x3D; BeautifulSoup(html, &quot;html.parser&quot;)        for item in soup.find_all(&#39;div&#39;, class_&#x3D;&quot;item&quot;):  # 查找符合要求的字符串            data &#x3D; []  # 保存一部电影所有信息            item &#x3D; str(item)            link &#x3D; re.findall(findLink, item)[0]  # 通过正则表达式查找            data.append(link)            imgSrc &#x3D; re.findall(findImgSrc, item)[0]            data.append(imgSrc)            titles &#x3D; re.findall(findTitle, item)            if (len(titles) &#x3D;&#x3D; 2):                ctitle &#x3D; titles[0]                data.append(ctitle)                otitle &#x3D; titles[1].replace(&quot;&#x2F;&quot;, &quot;&quot;)  #消除转义字符                data.append(otitle)            else:                data.append(titles[0])                data.append(&#39; &#39;)            rating &#x3D; re.findall(findRating, item)[0]            data.append(rating)            judgeNum &#x3D; re.findall(findJudge, item)[0]            data.append(judgeNum)            inq &#x3D; re.findall(findInq, item)            if len(inq) !&#x3D; 0:                inq &#x3D; inq[0].replace(&quot;。&quot;, &quot;&quot;)                data.append(inq)            else:                data.append(&quot; &quot;)            bd &#x3D; re.findall(findBd, item)[0]            bd &#x3D; re.sub(&#39;&lt;br(\s+)?&#x2F;&gt;(\s+)?&#39;, &quot;&quot;, bd)            bd &#x3D; re.sub(&#39;&#x2F;&#39;, &quot;&quot;, bd)            data.append(bd.strip())            datalist.append(data)    return datalist# 函数功能：向网页发起请求，得到指定一个URL的网页内容def askURL(url):# 模拟浏览器头部信息，向豆瓣服务器发送消息，即伪装为浏览器与服务器的通信（否则会被服务器识破为爬虫而出错）    head &#x3D; &#123;        &quot;User-Agent&quot;: &quot;Mozilla &#x2F; 5.0(Windows NT 10.0; Win64; x64) AppleWebKit &#x2F; 537.36(KHTML, like Gecko) Chrome &#x2F; 80.0.3987.122  Safari &#x2F; 537.36&quot;    &#125;    # 用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容）    request &#x3D; urllib.request.Request(url, headers&#x3D;head)    html &#x3D; &quot;&quot;    try:        response &#x3D; urllib.request.urlopen(request)        # 下面读取网页内容，设置编码为utf-8,防止乱码        html &#x3D; response.read().decode(&quot;utf-8&quot;)    except urllib.error.URLError as e:        if hasattr(e, &quot;code&quot;):            print(e.code)        if hasattr(e, &quot;reason&quot;):            print(e.reason)    return html# 保存数据到表格def saveData(datalist,savepath):    print(&quot;save.......&quot;)    book &#x3D; xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;,style_compression&#x3D;0) #创建workbook对象    sheet &#x3D; book.add_sheet(&#39;豆瓣电影Top250&#39;, cell_overwrite_ok&#x3D;True) #创建工作表    col &#x3D; (&quot;电影详情链接&quot;,&quot;图片链接&quot;,&quot;影片中文名&quot;,&quot;影片外国名&quot;,&quot;评分&quot;,&quot;评价数&quot;,&quot;概况&quot;,&quot;相关信息&quot;)    for i in range(0,8):        sheet.write(0,i,col[i])  #列名    for i in range(0,250):        # print(&quot;第%d条&quot; %(i+1))       #输出语句，用来测试        data &#x3D; datalist[i]        for j in range(0,8):            sheet.write(i+1,j,data[j])  #数据    book.save(savepath) #保存# def saveData2DB(datalist,dbpath):#     init_db(dbpath)#     conn &#x3D; sqlite3.connect(dbpath)#     cur &#x3D; conn.cursor()#     for data in datalist:#             for index in range(len(data)):#                 if index &#x3D;&#x3D; 4 or index &#x3D;&#x3D; 5:#                     continue#                 data[index] &#x3D; &#39;&quot;&#39;+data[index]+&#39;&quot;&#39;#             sql &#x3D; &#39;&#39;&#39;#                     insert into movie250(#                     info_link,pic_link,cname,ename,score,rated,instroduction,info)#                     values (%s)&#39;&#39;&#39;%&quot;,&quot;.join(data)#             # print(sql)     #输出查询语句，用来测试#             cur.execute(sql)#             conn.commit()#     cur.close#     conn.close()# def init_db(dbpath):#     sql &#x3D; &#39;&#39;&#39;#         create table movie250(#         id integer  primary  key autoincrement,#         info_link text,#         pic_link text,#         cname varchar,#         ename varchar ,#         score numeric,#         rated numeric,#         instroduction text,#         info text#         )###     &#39;&#39;&#39;  #创建数据表#     conn &#x3D; sqlite3.connect(dbpath)#     cursor &#x3D; conn.cursor()#     cursor.execute(sql)#     conn.commit()#     conn.close()# 保存数据到数据库if __name__ &#x3D;&#x3D; &quot;__main__&quot;:  # 当程序执行时    # 调用函数     main()    # init_db(&quot;movietest.db&quot;)     print(&quot;爬取完毕！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>具体的代码解析已经写在了对应代码的注释，上述爬虫代码的总体思路分三步：</p><ol><li>爬取网页</li><li>逐一解析数据</li><li>保存数据</li></ol><h2 id="爬虫预备知识"><a href="#爬虫预备知识" class="headerlink" title="爬虫预备知识"></a>爬虫预备知识</h2><h3 id="Web请求过程"><a href="#Web请求过程" class="headerlink" title="Web请求过程"></a>Web请求过程</h3><ul><li>服务器渲染：在服务器那边直接把数据和html整合在一起，统一返回给浏览器，特点是在页面源代码中能够看到数据。</li><li>客户端渲染：第一次请求只要一个html骨架，第二次请求拿到数据，进行数据展示。特点是在页面源代码中，看不到数据。</li></ul><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote><p>什么是协议<br>所谓协议,就是两台计算机之间为了能够流畅地进行沟通而设置的一个君子协定,常见的协议包括TCP/IP,SOAP协议,HTTP协议,SMTP协议等等……</p></blockquote><p>HTTP协议，即超文本传输协议，是用于从万维网服务器传输超文本到本地浏览器的传送协议。<br>HTTP协议将一条消息分为三大块内容，无论是请求还是响应都是三部分：</p><p>请求：</p><ul><li>请求行：请求方式（get/post），请求url地址，协议</li><li>请求头：放置一些服务器要使用的附加信息</li><li>请求体：放置一些请求参数</li></ul><p>响应：</p><ul><li>状态行：协议，状态码</li><li>响应头：放一些客户端要使用的附加信息</li><li>响应体：服务器返回的真正客户端要使用的内容（HTML，json等）</li></ul><p>请求头中最常见的一些重要内容包括：</p><ol><li>User-Agent：请求载体的身份标识（用什么发送的请求）</li><li>Referer：防盗链</li><li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li></ol><p>响应头中的一些重要内容：</p><ol><li>cookie：本地字符串数据信息</li><li>各种神奇的莫名其妙的字符串</li></ol><h3 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h3><p>request库是一个Python网络请求相关的第三方库，常用于Python爬虫。</p><h4 id="入门实例1：爬取网络搜索页面"><a href="#入门实例1：爬取网络搜索页面" class="headerlink" title="入门实例1：爬取网络搜索页面"></a>入门实例1：爬取网络搜索页面</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import requestsurl &#x3D; &#39;https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%E5%91%A8%E6%9D%B0%E4%BC%A6&#x2F;129156&#39;headers &#x3D; &#123;    &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;96.0.4664.110 Safari&#x2F;537.36&quot;&#125;#  浏览器地址栏中的内容，均以get方式进行请求resp &#x3D; requests.get(url, headers&#x3D;headers)print(resp.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里加入headers请求头的原因，在于模拟浏览器向服务器发起get请求。否则，服务器就会识别出来，并不是浏览器在向它发起get请求，而是一个爬虫程序，就会出现错误。</p><p>request.get(url, params, …)方法，接收的参数包括</p><ul><li>url：地址</li><li>params：参数</li></ul><p>它将发起get请求，返回一个对象（response），包括的信息：</p><ul><li>text，即页面内容</li><li>status_code，即响应状态码</li><li>encoding，即响应的编码方式</li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>使用元字符对字符串进行匹配，得到匹配结果。</p><p>Python中的re模块，提供了很多基于正则的函数，包括</p><ul><li>findall()</li><li>finditer()</li><li>search()</li><li>compile()预加载等</li></ul><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import re# findall: 匹配字符串中所有的符合正则表达式的内容，返回一个列表all &#x3D; re.findall(r&quot;\d+&quot;, &quot;中国移动10086，中国联通10010&quot;)print(all)# finditer：匹配字符串中所有的内容（返回一个迭代器），从迭代器中拿到内容需要.group()it &#x3D; re.finditer(r&quot;\d+&quot;, &quot;中国移动10086，中国联通10010&quot;)for i in it:    print(i.group())# search，找到一个匹配结果就返回一个对象，返回的结果是match对象，拿数据需要.group()s &#x3D; re.search(r&quot;\d+&quot;, &quot;中国移动10086，中国联通10010&quot;)print(s.group())# 预加载正则表达式，使提高速度obj &#x3D; re.compile(r&quot;\d+&quot;)# 接下来直接使用obj来调用re模块中的函数ret &#x3D; obj.finditer(&quot;中国移动10086，中国联通10010&quot;)for it in ret:    print(it.group())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="抓取指定内容"><a href="#抓取指定内容" class="headerlink" title="抓取指定内容"></a>抓取指定内容</h4><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import res &#x3D; &quot;&quot;&quot;&lt;div class&#x3D;&quot;jay&quot;&gt;&lt;span id&#x3D;&quot;1&quot;&gt;过秦论&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;jj&quot;&gt;&lt;span id&#x3D;&quot;2&quot;&gt;茅屋为秋风所破歌&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;jolin&quot;&gt;&lt;span id&#x3D;&quot;3&quot;&gt;陈情表&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;sylar&quot;&gt;&lt;span id&#x3D;&quot;4&quot;&gt;伶官传序&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;tory&quot;&gt;&lt;span id&#x3D;&quot;5&quot;&gt;记承天寺夜游&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&quot;&quot;&quot;obj &#x3D; re.compile(r&#39;&lt;div class&#x3D;&quot;.*?&quot;&gt;&lt;span id&#x3D;&quot;\d+&quot;&gt;.*?&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#39;, re.S)result &#x3D; obj.finditer(s)for it in result:    print(it.group())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我要提取出过秦论、茅屋为秋风所破歌等文本信息，应该怎么办？</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import res &#x3D; &quot;&quot;&quot;&lt;div class&#x3D;&quot;jay&quot;&gt;&lt;span id&#x3D;&quot;1&quot;&gt;过秦论&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;jj&quot;&gt;&lt;span id&#x3D;&quot;2&quot;&gt;茅屋为秋风所破歌&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;jolin&quot;&gt;&lt;span id&#x3D;&quot;3&quot;&gt;陈情表&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;sylar&quot;&gt;&lt;span id&#x3D;&quot;4&quot;&gt;伶官传序&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;tory&quot;&gt;&lt;span id&#x3D;&quot;5&quot;&gt;记承天寺夜游&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&quot;&quot;&quot;# 注意写法，.*?处的匹配结果存放在了wahaha中obj &#x3D; re.compile(r&#39;&lt;div class&#x3D;&quot;.*?&quot;&gt;&lt;span id&#x3D;&quot;(?P&lt;id&gt;\d+)&quot;&gt;(?P&lt;wahaha&gt;.*?)&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#39;, re.S)result &#x3D; obj.finditer(s)for it in result:    # 表示从wahaha中拿到匹配结果    print(it.group(&quot;wahaha&quot;))    print(it.group(&quot;id&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即，(?P<name>正则) 可以单独从正则匹配的内容中进一步提取内容。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据交互与异步编程</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/08/%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/08/%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本质上说，我们上网冲浪，都是获取、消费互联网上的各种资源，而这些资源并不在我们电脑的本地，所以我们需要利用互联网进行获取。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="客户端与服务器"><a href="#客户端与服务器" class="headerlink" title="客户端与服务器"></a>客户端与服务器</h3><p>要谈数据交互、获取网络资源，必定离不开两个基本概念：</p><ul><li>服务器</li><li>客户端</li></ul><p>服务器，就是用户在上网过程中，那些负责存放和对外提供资源的电脑。</p><blockquote><p>服务器本质上也是一台计算机（电脑），只不过它的性能比较高。<br>客户端，就是用户上网过程中，负责获取和消费资源的电脑。比如个人电脑。在个人电脑中，可以通过浏览器方式获取网络资源。</p></blockquote><h3 id="URL地址"><a href="#URL地址" class="headerlink" title="URL地址"></a>URL地址</h3><p>URL，中文名为统一资源定位符，标识互联网上每一个资源的唯一存放位置。浏览器只有通过URL地址才能正确地定位资源存放位置。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>一般，URL地址由三部分组成：</p><ul><li>客户端与服务器之间的通信协议</li><li>存有该资源的服务器名称</li><li>资源在服务器上的具体存放位置</li></ul><p><a href="http://www.cnblogs.com/luoshanheblogs/p/51581266.html">http://www.cnblogs.com/luoshanheblogs/p/51581266.html</a></p><h3 id="客户端与服务器的通信"><a href="#客户端与服务器的通信" class="headerlink" title="客户端与服务器的通信"></a>客户端与服务器的通信</h3><p>一般可以分为三步：</p><ol><li>客户端请求服务器</li><li>服务器处理本次请求</li><li>服务器响应客户端</li></ol><h3 id="数据是网页的灵魂"><a href="#数据是网页的灵魂" class="headerlink" title="数据是网页的灵魂"></a>数据是网页的灵魂</h3><p>在服务器对外提供的诸多资源中，最重要也是最根本的，就是数据。</p><h4 id="客户端与服务器之间的数据通信"><a href="#客户端与服务器之间的数据通信" class="headerlink" title="客户端与服务器之间的数据通信"></a>客户端与服务器之间的数据通信</h4><p>通常，客户端向服务器发起数据请求的步骤也分为三步：</p><ol><li>客户端请求数据资源</li><li>服务器处理这次数据请求</li><li>服务器将数据响应给客户端</li></ol><p>此外，浏览器还提供了一个XMLHttpRequest对象（简称xhr），可以通过它来请求服务器上的数据资源。</p><h4 id="资源的请求方式"><a href="#资源的请求方式" class="headerlink" title="资源的请求方式"></a>资源的请求方式</h4><p>客户端请求服务器时，请求方式有多种，最常见的两种为get和post请求。</p><ul><li>get<br>通常用于获取服务端资源<br>例如，根据URL地址，从服务器获取各种资源</li><li>post<br>通常用于向服务器提交资源<br>例如，登录时向服务器提交登陆信息等</li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax即异步Javascript和XML，通俗理解就是，在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就叫做Ajax。</p><h3 id="Ajax的功能"><a href="#Ajax的功能" class="headerlink" title="Ajax的功能"></a>Ajax的功能</h3><p>此前学习的前端三件套HTML，CSS和Javascript，都只能将网页做的美观漂亮、交互多样，但是缺乏与服务器之间的数据交互。Ajax可以做到这一点。</p><h3 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h3><h4 id="get-函数"><a href="#get-函数" class="headerlink" title="$.get()函数"></a>$.get()函数</h4><p>在jQuery中，$.get()函数功能单一，专门用来发起get请求，语法如下：<br><code>$.get(url, [data], [callback])</code><br>url(string): 要请求的资源地址<br>data(object): 请求资源期间要携带的参数<br>callback(function): 请求成功时的回调函数</p><p>若不带参数发起请求，直接提供url与callback即可。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 发起不带参数的请求</span>$<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://www.liulongbin.top:3006/api/getbooks'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// res是服务器响应的数据</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 发起带参数的请求</span>$<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://www.liulongbin.top:3006/api/getbooks'</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用Ajax请求数据时，被请求的URL地址，就叫做数据接口（简称接口），同时，每一个接口必须有请求方式。</p><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><p>说明了每一个接口的用法，在前后端开发过程中是一个很重要的文档，包含：</p><ul><li>接口名称：标识各个接口的简单说明，如登录接口</li><li>接口URL：接口的调用地址</li><li>调用方式：GET/POST</li><li>参数格式：接口需要传递的参数，每一个参数都应该包含四项说明内容：<ul><li>参数名称</li><li>参数类型</li><li>是否必选</li><li>参数说明</li></ul></li><li>响应格式：接口返回值的详细描述，一般包含三项内容：<ul><li>数据名称</li><li>数据类型</li><li>说明</li></ul></li><li>返回示例</li></ul><h2 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h2><p>数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式，在前端领域，包含两种格式：XML和JSON。这里重点介绍JSON。</p><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><p>XML，即可扩展标记语言，与HTML类似，也是一种标记语言。<br>HTML被设计用来描述网页上的内容，是网页内容的载体。<br>XML被设计用来传输和存储数据，是数据的载体。由于其无关代码较多，体积臃肿，在javascript中解析XML较为麻烦。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>英文全称为JavaScript Object Notation，即JavaScript对象表示法，也就是说，JSON是javascript对象和数组的字符串表示法，其本质就是字符串。同时，它也是一种轻量级的文本数据交换格式。</p><p>对于JSON表示的对象、数组两种数据结构，里面的数据类型只能是数字、字符串、布尔值、null、数组、对象六种类型。</p><p>注意事项：</p><ul><li>属性名必须用双引号</li><li>JSON中不允许使用单引号表示字符串</li><li>JSON中不允许写注释</li><li>不能使用undefined作为值</li></ul><h4 id="JSON与JS对象"><a href="#JSON与JS对象" class="headerlink" title="JSON与JS对象"></a>JSON与JS对象</h4><p>JSON是JS对象的字符串表示方法。<br>JSON字符串转化为JS对象，可以使用JSON.parse()方法。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'&#123;"a": "Hello", "b": "World"&#125;'</span><span class="token punctuation">)</span><span class="token comment">// 结果是</span><span class="token comment">/*&#123;  a: 'Hello',  b: 'World'&#125;*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JS对象转化为JSON字符串，可以使用JSON.stringify()方法。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">'Hello'</span><span class="token punctuation">,</span>  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token string">'World'</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">// 结果是</span><span class="token comment">/*&#123;  "a": "Hello",  "b": "World"&#125;*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同源策略与跨域"><a href="#同源策略与跨域" class="headerlink" title="同源策略与跨域"></a>同源策略与跨域</h2><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>首先，需要了解什么是同源。<br>如果两个页面的协议、域名和端口都相同，则两个页面具有相同的源。<br>比如如下页面url：<br><a href="http://www.test.com/index.html">http://www.test.com/index.html</a><br>协议是http，域名是www.test.com，端口没有标出，默认是80，那么与之同源的页面url的协议、域名、端口均与之相同，即<br><a href="http://www.test.com:80/...">http://www.test.com:80/...</a></p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略是浏览器提供的一个安全功能。<br>它限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的重要安全机制。</p><blockquote><p>也就是说，浏览器规定：某一个网站的JavaScript不允许与非同源的网站之间进行资源交互。</p></blockquote><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>同源的对立面，就是跨域。<br>比如，当前网页url是<a href="http://www.test.com/index.html">http://www.test.com/index.html</a><br>而接口的url是<a href="http://www.api.com/userlist">http://www.api.com/userlist</a><br>此时，出现了跨域问题。</p><h3 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h3><p>最主要有两种方案，分别是</p><ul><li>JSONP：临时解决方案，只支持GET请求</li><li>CORS：W3C标准，是一种跨域Ajax请求的根本解决方案，支持GET和POST。</li></ul><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP的实现原理是，利用script标签不受浏览器同源策略的影响这一特点，用过src属性，请求非同源的js脚本。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>自己实现简单的JSONP数据请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token comment">// 定义一个success函数，相当于Ajax中的第三个callback参数</span>        <span class="token keyword">function</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"JSONP响应回来的数据是："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 字符串查询，希望服务器返回一个success函数的调用callback=success --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://ajax.fronted.itheima.net:3006/api/jsonp?callback=success&amp;name=ls&amp;age=30<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，JSONP与Ajax没有关系。</p><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defineProperty与数据劫持</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/08/%E5%88%9D%E8%AF%86defineProperty/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/08/%E5%88%9D%E8%AF%86defineProperty/</url>
      
        <content type="html"><![CDATA[<h2 id="初识defineProperty"><a href="#初识defineProperty" class="headerlink" title="初识defineProperty"></a>初识defineProperty</h2><p>Object.defineProperty()，是一个Object对象上的方法，用于创建对象上的属性。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Object.defineProperty(object, prop, desp);<br>其中，object指明要添加属性的对象名，prop指出属性名，而desp则是一些属性描述符。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> phone <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'nava7'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>car<span class="token punctuation">,</span> <span class="token string">'price'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">7000</span><span class="token punctuation">,</span>    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面对属性描述符做一番简单介绍。</p><h4 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h4><p>指定属性是否可以在第一次设置后被修改、是否可以被删除。<br>比如，如下代码在严格模式下，会报错；在一般模式下，修改、删除无效。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Yank'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> person<span class="token punctuation">.</span>ageconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除无效，结果仍为 &#123;name: 'Yank', age: 20&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><p>enumerable配置项用于描述属性是否可以被for in 或者Object.keys()的遍历（枚举）中。<br>当enumerable为false时，它不可以被上述两个语句遍历到。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> school <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'XiWang Primary School'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>school<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">55</span><span class="token punctuation">,</span>    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>school<span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'Hubei Province'</span><span class="token punctuation">,</span>    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 打印结果，只有address属性，而没有age属性</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>school<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  ['name', 'address']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><p>比较好理解，writable为false时，表示该属性是只读的，不可以被写，且在严格模式下，写操作会报错；一般模式下，写操作失效。</p><h4 id="get-set"><a href="#get-set" class="headerlink" title="get/set"></a>get/set</h4><p>get方法用于获取属性，而set方法用于设置属性。注意，设置了getter和setter之后，不可以再设置value和writable了，否则会报错。</p><p>一般地，使用第三方变量避免getter和setter反复无限调用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 错误写法</span>    <span class="token keyword">var</span> province <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Hubei'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>province<span class="token punctuation">,</span> <span class="token string">'centerCity'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用了getter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> province<span class="token punctuation">.</span>centerCity        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用了setter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            province<span class="token punctuation">.</span>centerCity <span class="token operator">=</span> val        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    province<span class="token punctuation">.</span>centerCity <span class="token operator">=</span> <span class="token string">'Wuhan'</span><span class="token comment">// 正确写法，另设了一个变量str</span><span class="token keyword">var</span> province <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Hubei'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>province<span class="token punctuation">,</span> <span class="token string">'centerCity'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用了getter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> str    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用了setter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Wuhan</span>        str <span class="token operator">=</span> val    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>province<span class="token punctuation">.</span>centerCity <span class="token operator">=</span> <span class="token string">'Wuhan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用Object.defineProperty()可以为对象新增属性，并且还可以细化地指定属性描述符，默认三个属性描述符（configurable、writable、enumerable）均为false；<br>而另一种直接的方式Object.prop即点运算符新增属性，则是默认三个属性描述符均为true。</p></blockquote><h3 id="属性描述符的分类"><a href="#属性描述符的分类" class="headerlink" title="属性描述符的分类"></a>属性描述符的分类</h3><ul><li>数据描述符：value和writable</li><li>存取描述符：get和set</li></ul><p>注意，两种描述符不可以同时使用。</p><h3 id="与Vue中的数据代理"><a href="#与Vue中的数据代理" class="headerlink" title="与Vue中的数据代理"></a>与Vue中的数据代理</h3><p>通过一个对象代理对另一个对象中属性的操作（读/写），叫做数据代理。<br>下面举一个很简单的栗子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"getter of obj2 is working!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj1<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setter of obj2 is working!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj1<span class="token punctuation">.</span>x <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个栗子中，我们就实现了obj1和obj2之间的数据代理。我们要想读取/修改obj1.x，只需要读取/修改obj2.x就好，因为会触发其getter/setter。</p><p>下面进入正题：Vue中的数据代理究竟是什么？</p><p>在vue2中，我们在构建vue实例对象时传入各项配置参数：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>姓名：&#123;&#123; name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>住址：&#123;&#123; address &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#root'</span><span class="token punctuation">,</span>        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'胡图图'</span><span class="token punctuation">,</span>        <span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'翻斗花园'</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在浏览器中查看执行结果，在控制台输出vm，可以发现name、address都已经变成了vm实例自身的属性了，并且都有自己的getter/setter。<br>但是数据代理在vue中是如何体现的呢？首先我们需要知道的是，vm在拿到我们配置的属性name、address后，一定会将其保留下来。事实上，它们存在于vm的 _ data属性中了。也就是说，接下来，对 _ data中属性的修改，就相当于是对vm上属性的修改了（数据代理）。</p><p>为了能够验证这一点，我们需要想方法拿到原始的配置对象（options）上的data参数，故作出如下修改：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>姓名：&#123;&#123; name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>住址：&#123;&#123; address &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token comment">// 小技巧，将data配置项单独全局声明，方便在控制台直接获取</span>    <span class="token keyword">var</span> myData <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'胡图图'</span><span class="token punctuation">,</span>        <span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'翻斗花园'</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#root'</span><span class="token punctuation">,</span>        <span class="token literal-property property">data</span><span class="token operator">:</span> myData<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myData<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">===</span> myData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 验证data配置项就是vm的_data属性，故下文中不对两者（配置项data属性与vm上的_data属性）作刻意区分</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在在浏览器控制台作出如下操作：<br><code>vm.name = &#39;hututu&#39;</code><br>我们就会发现姓名变成了‘hututu’。从数据代理角度来说，我们修改的是vm上的name属性，也就调用了其setter，从而改变了与之关联的data（ _ data）上的name。</p><p>现在对整个数据代理过程梳理一下：</p><ol><li>首先，我们书写了如下代码：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#root'</span><span class="token punctuation">,</span><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'胡图图'</span><span class="token punctuation">,</span><span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'翻斗花园'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在创建好的vm实例对象上，就会有一个准备好的 _ data属性，里面存放了options配置项中的data，大致如下：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// vm</span><span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token literal-property property">_data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'胡图图'</span><span class="token punctuation">,</span><span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'翻斗花园'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>到这里，还没有出现数据代理。但是，如果Vue仅仅到此为止的话，模板中的语法就应该这样书写了：<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>姓名：&#123;&#123; _data.name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>住址：&#123;&#123; _data.address &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">var</span> myData <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'胡图图'</span><span class="token punctuation">,</span>        <span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'翻斗花园'</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#root'</span><span class="token punctuation">,</span>        <span class="token literal-property property">data</span><span class="token operator">:</span> myData<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myData<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">===</span> myData<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>原因很简单，此时vm实例对象上还没有name、address属性，只有 _ data属性，通过它获取到数据。</li><li>数据代理，也就是再vm身上添加了相应的属性：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// vm</span><span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token literal-property property">_data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'胡图图'</span><span class="token punctuation">,</span><span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'翻斗花园'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token operator">...</span><span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>而这里两者之间就是通过Object.defineProperty()建立的数据代理关系：<br>通过这个方法，将data对象中的所有属性添加到vm上，同时为每一个属性指定一个getter/setter，在getter/setter内部去操作data对象中对应的属性。</li></ol><p>可见，数据代理，大大地简化了代码书写，也使得更加方便地操作data中的数据了。</p><h3 id="与数据劫持"><a href="#与数据劫持" class="headerlink" title="与数据劫持"></a>与数据劫持</h3><blockquote><p>数据劫持，就是对某一项数据进行访问、设置时，会触发相应的函数，并返回最后想要的结果（或返回属性值getter，或修改属性值setter）。当然，我们就可以在函数中另外做一些我们自己想要的操作了，这就是数据劫持。</p></blockquote><p>在vue2中，就是使用defineProperty()实现的数据劫持，当数据被修改时，就会通知该数据被修改了。通俗地理解，就是通过defineProperty()修改了属性的getter/setter，并且在其中增添了监视功能。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unusual Minesweeper</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/08/Unusual-Minesweeper/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/08/Unusual-Minesweeper/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题传送门<br><a href="https://codeforces.com/problemset/problem/1619/G">https://codeforces.com/problemset/problem/1619/G</a></p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>另类的“扫雷”游戏，给出若干个地雷的信息（横坐标、纵坐标、自动爆炸时间），另外规定，每一分钟，可以人为地指定任意一颗地雷爆炸，并且地雷爆炸会引发同行、同列所有距离k以内的地雷爆炸，从而产生连锁反应。试问引爆地图上所有地雷所需要的最少时间是多少。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先我们知道的是，每一颗地雷爆炸的形式有三种：</p><ul><li>到达一定时间自动爆炸</li><li>被其他的地雷引爆</li><li>人为引爆</li></ul><p>如果单纯一个一个考虑三个条件，将会使本题变得十分复杂。那么，我们可不可以将三个条件作出一定的简化，或者合并一下，从而使得问题处理起来更加简便而清晰呢？</p><p>当然是可以的。</p><ol><li>根据题意，地雷的连锁引爆无疑是本题的关键之处；这一部分的处理，需要用到深度优先搜索DFS；</li><li>任何一颗地雷的爆炸都不是单纯它一个的爆炸，还需要考虑它引发的所有地雷的爆炸；这样一来，这些被同一颗地雷引爆的所有地雷的爆炸时间全部都是一样的，可以将它们看作一个整体。</li><li>那么怎么找到这样的整体呢？事实上，这样的地雷群体，只要其中任意一个爆炸，整个群体都会爆炸，也就是说，对任何一颗地雷进行DFS，都可以牵扯出整个地雷群；</li><li>还需要另设一个标记，记录哪些地雷已经爆炸过。</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>由于地雷坐标实在太大，不方便直接使用二维数组存储相关信息，我们可以换一种方式存储：使用map容器，存储每一横行和每一纵列的地雷的坐标，这样也方便后续的DFS处理。<br>另外，设置容器记录每一颗地雷的爆炸时间以及是否爆炸；</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 存储指定坐标下，一整行（列）的地雷坐标map&lt;ll, vector&lt;ll&gt;&gt;mapX;map&lt;ll, vector&lt;ll&gt;&gt;mapY;map&lt;pair&lt;ll, ll&gt;, bool&gt;isBoo;map&lt;pair&lt;ll, ll&gt;, ll&gt;times;...while (i&lt;n)&#123;   scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;t);   alls[i++]&#x3D;make_pair(x, y);   mapX[x].push_back(y);   mapY[y].push_back(x);   times[&#123;x, y&#125;] &#x3D; t;&#125;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对所有地雷遍历，也就是上面说过的，任意一个地雷爆炸可以牵扯出整个地雷群，只需要求出这个地雷群的最短爆炸时间即可，用到DFS：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ll dfs(ll x, ll y)&#123;    &#x2F;&#x2F; 让&#123;x,y&#125;处地雷爆炸    ll minT &#x3D; times[&#123;x, y&#125;];    isBoo[&#123;x, y&#125;] &#x3D; true;    &#x2F;&#x2F; 连锁反应爆炸开始    auto i &#x3D; lower_bound(mapX[x].begin(), mapX[x].end(), y);    auto j &#x3D; lower_bound(mapY[y].begin(), mapY[y].end(), x);    &#x2F;&#x2F; 四个方向    if (++i !&#x3D; mapX[x].end() &amp;&amp; !isBoo[&#123;x, * i&#125;] &amp;&amp; abs(*i - y) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(x, *i);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    i--;    if (i !&#x3D; mapX[x].begin() &amp;&amp; !isBoo[&#123;x, * (--i)&#125;] &amp;&amp; abs(*i - y) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(x, *i);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    if (++j !&#x3D; mapY[y].end() &amp;&amp; !isBoo[&#123;*j, y&#125;] &amp;&amp; abs(*j - x) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(*j, y);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    j--;    if (j !&#x3D; mapY[y].begin() &amp;&amp; !isBoo[&#123;*(--j), y&#125;] &amp;&amp; abs(*j - x) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(*j, y);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    return minT;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，所有的地雷所需爆炸时间就会被分开，在数组中的每一个值都代表一个不同的地雷群的爆炸时间，也就是说，它们互不影响（地雷群之间不会因为爆炸而相互引爆了，否则两个地雷群会合成一个）。采用双指针对这个时间数组进行遍历，以时间为循环变量，直到双指针相遇即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;ll&gt; pres;&#x2F;&#x2F; 存储dfs的结果，得到的就是所有地雷群的爆炸时间for (int i&#x3D;0;i&lt;alls.size()-1;i++)&#123;   auto e &#x3D; alls[i];   if(!isBoo[e])       pres.push_back(dfs(e.first, e.second));&#125;&#x2F;&#x2F; 需要对pres进行升序排序，最后面的地雷当然需要每一次的人为引爆sort(pres.begin(), pres.end());&#x2F;&#x2F; 设置头指针sp，尾指针ep，ans就是最后的答案————爆炸完的最短时间ll ep &#x3D; pres.size() - 1, sp &#x3D; 0, ans &#x3D; 0;for (;; ans++)&#123;   while (pres[sp] &#x3D;&#x3D; ans)   sp++;   if (ep &lt;&#x3D; sp)  break;   ep--;&#125;cout &lt;&lt; ans &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; unusualmineSweeper.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。&#x2F;&#x2F;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;typedef long long ll;using namespace std;&#x2F;&#x2F; 存储指定坐标下，一整行（列）的地雷坐标map&lt;ll, vector&lt;ll&gt;&gt;mapX;map&lt;ll, vector&lt;ll&gt;&gt;mapY;map&lt;pair&lt;ll, ll&gt;, bool&gt;isBoo;map&lt;pair&lt;ll, ll&gt;, ll&gt;times;ll x, y, k, t;int q, n;ll dfs(ll x, ll y)&#123;    &#x2F;&#x2F; 让&#123;x,y&#125;处地雷爆炸    ll minT &#x3D; times[&#123;x, y&#125;];    isBoo[&#123;x, y&#125;] &#x3D; true;    &#x2F;&#x2F; 连锁反应爆炸开始    auto i &#x3D; lower_bound(mapX[x].begin(), mapX[x].end(), y);    auto j &#x3D; lower_bound(mapY[y].begin(), mapY[y].end(), x);    &#x2F;&#x2F; 四个方向    if (++i !&#x3D; mapX[x].end() &amp;&amp; !isBoo[&#123;x, * i&#125;] &amp;&amp; abs(*i - y) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(x, *i);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    i--;    if (i !&#x3D; mapX[x].begin() &amp;&amp; !isBoo[&#123;x, * (--i)&#125;] &amp;&amp; abs(*i - y) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(x, *i);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    if (++j !&#x3D; mapY[y].end() &amp;&amp; !isBoo[&#123;*j, y&#125;] &amp;&amp; abs(*j - x) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(*j, y);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    j--;    if (j !&#x3D; mapY[y].begin() &amp;&amp; !isBoo[&#123;*(--j), y&#125;] &amp;&amp; abs(*j - x) &lt;&#x3D; k)    &#123;        ll tm &#x3D; dfs(*j, y);        minT &#x3D; minT &gt; tm ? tm : minT;    &#125;    return minT;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;q);    while (q--)    &#123;        mapX.clear();        mapY.clear();        isBoo.clear();        scanf(&quot;%d%lld&quot;, &amp;n, &amp;k);        vector&lt;pair&lt;ll, ll&gt;&gt; alls(n+1);  &#x2F;&#x2F; 存放全部地雷的坐标对        int i &#x3D; 0;        while (i&lt;n)        &#123;            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;t);            alls[i++]&#x3D;make_pair(x, y);            mapX[x].push_back(y);            mapY[y].push_back(x);            times[&#123;x, y&#125;] &#x3D; t;        &#125;        for (auto item : mapX)        &#123;            sort(mapX[item.first].begin(), mapX[item.first].end());        &#125;        for (auto item : mapY)        &#123;            sort(mapY[item.first].begin(), mapY[item.first].end());        &#125;        vector&lt;ll&gt; pres;        for (int i&#x3D;0;i&lt;alls.size()-1;i++)        &#123;            auto e &#x3D; alls[i];            if(!isBoo[e])                pres.push_back(dfs(e.first, e.second));        &#125;        sort(pres.begin(), pres.end());        ll ep &#x3D; pres.size() - 1, sp &#x3D; 0, ans &#x3D; 0;        for (;; ans++)        &#123;            while (pres[sp] &#x3D;&#x3D; ans)   sp++;            if (ep &lt;&#x3D; sp)  break;            ep--;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web布局</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/07/Web%E5%B8%83%E5%B1%80/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/07/Web%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>通常，对于Web布局而言，需要指定两方面的内容：</p><ul><li>位置</li><li>大小</li></ul><p>首先，对于页面中的元素，分为三种类型：</p><ul><li>块级元素：自身占据一整行，大小受到width等属性控制</li><li>行内元素：自身并不占据一整行，大小由自身大小撑开，不受width属性控制</li><li>行内块元素：兼具上面两者特点，既不占据一整行，但是大小又受到width等属性的控制</li></ul><p>合理布局的作用：</p><ul><li>使内容更加清晰</li><li>页面载入更快</li><li>有利于搜索引擎爬取</li></ul><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>flex即flexbox，意为“弹性布局”，通常可以给任意一个容器加上flex属性，使之成为flex弹性盒。</p><h3 id="Flex容器"><a href="#Flex容器" class="headerlink" title="Flex容器"></a>Flex容器</h3><p>用于盛放flex布局元素的容器，就是Flex容器，通常可以具有一下属性：</p><ul><li>flex-direction：指定容器内元素排列顺序（四个，左右、上下）</li><li>flex-wrap：控制容器内元素换行</li><li>flex-flow：前两者的混合、</li></ul><h3 id="Flex元素"><a href="#Flex元素" class="headerlink" title="Flex元素"></a>Flex元素</h3><p>通常Flex元素上的属性包括：</p><ul><li>flex-grow：控制Flex容器的剩余空间的分配</li><li>flex-shrink：</li><li>align-items：控制元素在辅轴上的对齐方式</li><li>justify-content：控制元素在主轴上的对齐方式</li></ul><h3 id="Flex适用场景"><a href="#Flex适用场景" class="headerlink" title="Flex适用场景"></a>Flex适用场景</h3><ul><li>导航栏</li><li>拆分导航（名称居左，昵称居右，中间空白）</li><li>绝对底部（flex-grow将元素完全撑开）</li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义事件与全局通信</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%A8%E5%B1%80%E9%80%9A%E4%BF%A1/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%A8%E5%B1%80%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>vue3中使用全局事件总线，借助vuex管理全局变量，可以实现任意两个组件之间的通信。</p><blockquote><p>效果：<br>点击区域图或者条形图的地图块或者柱形，可以实现从Home组件到Result组件的跳转，并且直接选中对应的省份并进行筛选展示。</p></blockquote><h2 id="事件的定义与触发"><a href="#事件的定义与触发" class="headerlink" title="事件的定义与触发"></a>事件的定义与触发</h2><p>由此可以看出，涉及两个组件的通信：Home组件和Result组件。<br>而双方通信的数据是Result组件中的selectProvince（选中省份信息），因此在vuex中定义一个共享数据province。</p><h3 id="事件的定义"><a href="#事件的定义" class="headerlink" title="事件的定义"></a>事件的定义</h3><p>首先我们需要在Home组件定义一个自定义事件（event），命名为events_ClickMap，这个事件的回调将会是最后调用的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义自定义事件</span><span class="token function">useAppEvents</span><span class="token punctuation">(</span><span class="token string">'events_ClickMap'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">option</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'FILTER_UPTATE'</span><span class="token punctuation">,</span> option<span class="token punctuation">)</span>  <span class="token function">handleClick2FilterResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在事件的回调中，需要利用mutations中的方法对共享数据进行修改，并且实现路由跳转。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// filter.ts文件</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">FilterCondition</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">province</span><span class="token operator">:</span> string<span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token literal-property property">state</span><span class="token operator">:</span> FilterCondition <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">province</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">FILTER_UPTATE</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> FilterCondition<span class="token punctuation">,</span> <span class="token literal-property property">province</span><span class="token operator">:</span> string<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter"><span class="token keyword">void</span></span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    state<span class="token punctuation">.</span>province <span class="token operator">=</span> province  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">namespace</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  state<span class="token punctuation">,</span>  mutations<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事件的触发"><a href="#事件的触发" class="headerlink" title="事件的触发"></a>事件的触发</h3><p>触发事件直接在于点击图中的元素（地图块或者柱形），因此为每一个元素绑定上之前定义的自定义事件events_ClickMap即可。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 绑定自定义事件</span>  mapChart<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'mouseup'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">event</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">emitAppEvent</span><span class="token punctuation">(</span><span class="token string">'events_ClickMap'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>事件的event触发时会接收到参数，其中的name属性指向了点击元素的省份名。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Year&#39;s Problem</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/04/New-Year-s-Problem/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/04/New-Year-s-Problem/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><p>问题传送门<br><a href="https://codeforces.com/contest/1619/problem/D">https://codeforces.com/contest/1619/problem/D</a></p></blockquote></blockquote><h2 id="问题大意"><a href="#问题大意" class="headerlink" title="问题大意"></a>问题大意</h2><p>需要从m个商店给n位朋友买礼物，每人一个，从j号商店为i号朋友买礼物，得到joy值为矩阵元素 $ a_{i}{j} $<br>矩阵A记录的是joy值，m行n列，规定最多只能去n-1个商店买礼物，且最后每一个朋友都会得到一个joy值，求在所有情况下，n个朋友的joy值的最小值最大能为多少。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>经过一番分析，可以想到这个题目需要用到二分算法。具体怎么用，其实就是之前做过的二分答案。所谓二分答案，就是题目的答案只可能是某一个最大值和最小值之间的一个数，且通过不断地二分，从而确定答案。<br>模板如下，仅供参考：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int lower&#x3D;min, upper&#x3D;max;int mid, ans;while(lower&lt;&#x3D;upper)&#123;    mid &#x3D; lower+(upper - lower)&#x2F;2;    if(isOk(mid))    &#123;        &#x2F;&#x2F; 表示当前mid是符合条件的，但是不一定就是最终的答案，还需要从右边较大区间继续取数检验        ans &#x3D; mid;        lower &#x3D; mid+1;    &#125;    else    &#123;        &#x2F;&#x2F; 表示mid值过大了，从左边的区间取        upper &#x3D; mid-1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，本题的关键就在于，如何确定选中的mid值是符合条件的呢？<br>根据题意，我们可以得知，其实要满足题意，需要两个条件：</p><ol><li>至多去n-1个商店，也就是至少存在一个商店，在其中购买的礼物至少有两个（因为一共买n个礼物）；</li><li>每一个朋友有且仅有一个礼物。</li></ol><p>所以，在isOk()中，对矩阵进行遍历检验即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 判断两点：&#x2F;&#x2F; 1.至少有一个商店，在其中购买至少两件礼物；&#x2F;&#x2F; 2.每一个朋友都有且仅有一件礼物bool isOk(long long x, vector&lt;vector&lt;int&gt;&gt; all)&#123;    int flag &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    &#123;        int num &#x3D; 0;        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)        &#123;            if (all[i][j] &gt;&#x3D; x)            &#123;                num++;                fri[j] &#x3D; 1;            &#125;        &#125;        &#x2F;&#x2F;条件一满足，就置flag标志变量为1，否则一直为0        if (num &gt;&#x3D; 2)  flag &#x3D; 1;    &#125;    &#x2F;&#x2F; 检验条件二，是否每一个朋友都有礼物    int isAll &#x3D; 1;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)        isAll &#x3D; isAll &amp;&amp; fri[i];    return isAll &amp;&amp; flag;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，问题得以解决。</p>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MEX and Increments</title>
      <link href="/mid-lake-pavilion.github.io/2022/01/03/MEX-and-Increments/"/>
      <url>/mid-lake-pavilion.github.io/2022/01/03/MEX-and-Increments/</url>
      
        <content type="html"><![CDATA[<p>要知道，我们要想求出当前序列（i）的mex，需要有从0~i-1的所有数字，同时，将所有数字i自增1即可。记录上得到0~i-1每一个数至少一个所需要的操作数记作dp[i-1]，同时加上数字i出现的次数，就是答案了。<br>而在已经有0~i-1的基础上，如何得到i呢？（这就是本题的关键，即所谓的动态转移方程）：</p><ol><li>i本来就存在，这种情况最简单，此时dp[i]与dp[i-1]相等。</li><li>i不存在，需要借助0~i-1中的数生成（注意，用来生成i的数至少出现过2次，否则0~i-1每一个数至少出现一次的条件被打破）。</li></ol><p>为了节省时间，我们首先需要得到每一个数字出现次数的数组times[]，从times[1]开始分析，遇见大于2的数，需要将其入栈，同时记录下其出现次数（可以用pair记录，为了方便之后生成不存在的数，届时只需取出栈顶数，令其出现次数减一即可。）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int N &#x3D; 2e5 + 1 ;int all[N] ;typedef pair&lt;int ,int&gt; PII ;int main()&#123; int t; cin &gt;&gt;t ;while(t--) &#123;int  n ;cin&gt;&gt;n;map&lt;long long, long long&gt; p ;for(int i &#x3D; 0 ; i &lt; n; i ++ ) cin&gt;&gt;all[i] , p[all[i]] ++ ;long long  sum &#x3D; 0 , ch &#x3D; 0 ;if(!p[0]) &#123;cout&lt;&lt;&quot;0 &quot; ;for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) &#123;cout&lt;&lt;-1 &lt;&lt;&quot; &quot; ;&#125;cout&lt;&lt;endl;continue ;&#125;int ok &#x3D; 1 ;cout&lt;&lt;p[0] &lt;&lt;&quot; &quot; ;p[0] -- ;priority_queue&lt;PII&gt; q;if(p[0] !&#x3D; 0) q.push(&#123;0 , p[0]&#125;) ;for(int i &#x3D; 1 ; i &lt;&#x3D; n;i ++ ) &#123;if(ok &#x3D;&#x3D; 0) cout&lt;&lt;&quot;-1 &quot; ;else if(p[i] &#x3D;&#x3D; 0 ) &#123;cout&lt;&lt; ch &lt;&lt;&quot; &quot; ;if(q.size() !&#x3D; 0 )&#123;auto t &#x3D; q.top() ;q.pop();long long x &#x3D; t.first , y &#x3D;t.second;ch +&#x3D; i - x ;y -- ;if(y !&#x3D; 0 ) &#123;q.push(&#123;x , y &#125;) ;&#125;&#125;else &#123;ok &#x3D; 0 ;&#125;&#125;else &#123;cout&lt;&lt;ch + p[i] &lt;&lt;&quot; &quot; ;p[i] -- ;if(p[i])&#123;q.push(&#123;i , p[i]&#125;) ;&#125;&#125;&#125;cout &lt;&lt;endl;&#125;return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU的结构和功能</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/25/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/25/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><ul><li>指令控制</li><li>操作控制</li><li>时间控制</li><li>数据加工</li><li>中断处理</li></ul><h3 id="CPU的结构框图"><a href="#CPU的结构框图" class="headerlink" title="CPU的结构框图"></a>CPU的结构框图</h3><ul><li>运算器（ALU）</li><li>控制器（CU）</li><li>存放操作数的寄存器</li><li>中断系统</li></ul><h3 id="控制器CU的功能"><a href="#控制器CU的功能" class="headerlink" title="控制器CU的功能"></a>控制器CU的功能</h3><ul><li>取指令</li><li>分析指令</li><li>执行指令</li></ul><h3 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h3><ol><li>用户可见寄存器<br>通常CPU执行机器语言访问的寄存器为用户可见寄存器。按特征还可分为：<ul><li>通用寄存器<br>许多指定功能，如某种寻址方式所需的专用寄存器</li><li>数据寄存器<br>存放各种数据类型的操作数</li><li>地址寄存器<br>存放地址</li><li>条件码寄存器<br>存放条件码</li></ul></li></ol><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>区分三个概念：</p><ul><li>指令周期<ul><li>CPU从内存中读取一个指令字的最短时间</li><li>一条指令的取出阶段被定义为一个CPU周期时间</li><li>也称“机器周期”</li><li>一个完整的指令周期，包括取址、间址、执行和中断四个子周期。</li></ul></li><li>时钟周期<ul><li>是CPU处理操作的最基本单位</li><li>一个CPU周期由若干个时钟周期构成的</li></ul></li><li>指令周期<ul><li>CPU取出并执行一条指令所需的全部时间</li><li>包括取指令周期和执行指令周期。</li></ul></li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>取指令—-分析指令—-执行指令</p></blockquote><h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><ol><li>结构相关<br>不同指令将指令与数据保存在同一个寄存器中。</li><li>数据相关</li></ol><h3 id="尝试的解决技术"><a href="#尝试的解决技术" class="headerlink" title="尝试的解决技术"></a>尝试的解决技术</h3><ol><li>超级流水线巩固</li><li>超长指令字技术</li></ol><blockquote><p>理想情况下，n级流水的速度是不采用n级流水技术的n倍。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入/输出接口</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/24/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/24/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h2><blockquote><p>接口<br>接口是两个系统获两个部件之间的衔接部分，包括硬件接口和软件接口<br>I/O接口是连接主机与I/O设备之间的中间电路或部件，由硬件电路、相应的控制软件构成。<br>接口的功能：</p><ul><li>地址识别和设备选择</li><li>接收、保存CPU的I/O控制命令</li><li>反映外设的工作状态</li><li><p>信号转换<br>端口<br>端口是I/O电路中可通过编程寻址并进行读/写的寄存器<br>接口中包含端口</p></li><li><p>数据端口</p></li><li>控制端口</li><li>状态端口<br>不同场合下“端口”具有不同的含义：</li><li>I/O接口中的端口，实际上是指寄存器</li><li>上网端口</li><li>网络应用程序的标示</li></ul></blockquote><h2 id="I-O接口的组成与工作原理"><a href="#I-O接口的组成与工作原理" class="headerlink" title="I/O接口的组成与工作原理"></a>I/O接口的组成与工作原理</h2><p>I/O接口由数据缓冲寄存器、状态寄存器、命令寄存器、端口寄存器、控制逻辑和中断逻辑组成。<br>而I/O接口所进行的工作，都是通过接口中用户可见的寄存器————端口的“读写”来实现的。</p><h3 id="I-O接口的组成"><a href="#I-O接口的组成" class="headerlink" title="I/O接口的组成"></a>I/O接口的组成</h3><p>I/O接口由数据缓冲寄存器DBR、设备选择电路、设备状态标记、命令寄存器和命令译码器、控制逻辑电路五部分组成。</p><h3 id="I-O设备的编址方法"><a href="#I-O设备的编址方法" class="headerlink" title="I/O设备的编址方法"></a>I/O设备的编址方法</h3><ul><li>统一编址<br>I/O设备地址与内存统一进行编址，即在存储器中单独划定一片空间，存放I/O设备地址。</li><li>独立编址（不统一编址）<br>I/O地址与内存有各自独立的地址空间，互不干扰。需要设置专门的I/O指令。</li></ul><h3 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I/O设备与主机信息传送的控制方式"></a>I/O设备与主机信息传送的控制方式</h3><ul><li>程序查询方式</li><li>程序中断方式</li><li>DMA方式</li><li>通道方式</li><li>外围处理机</li></ul><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>由CPU通过程序不断查询I/O设备是否做好准备，从而控制I/O设备与主机交换信息。</p><p>特点：</p><ul><li>由CPU主动查询外设</li><li>CPU和I/O串行工作</li><li>CPU效率低下</li></ul><h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul><li>中断发生是随机的。</li><li>程序是否被中断，不影响其运行结果。</li><li>任何时刻，CPU只能为一个中断源的请求提供服务。</li></ul><h5 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h5><ol><li>中断请求</li><li>中断判优</li><li>中断响应<br>在CPU的EINT为“1”时，CPU在每条指令执行的末尾，扫描INTR引脚，若有中断请求，则“中断状态”触发器INT置为1，进入中断周期，执行“中断隐指令”。<blockquote><p>中断隐指令功能：<br>将程序断点、标志位寄存器压入堆栈<br>关中断<br>将中断处理程序的首地址送入PC</p></blockquote></li><li>中断服务<br>由预先编制的中断服务程序完成。<br>中断服务程序，说到底就是CPU去响应I/O外设的申请了，为中断源服务去了。<br>中断服务程序的处理流程是：<ul><li>保护现场<br>保护程序断点和CPU内部寄存器的内容</li><li>中断服务（设备服务，是中断服务程序的主体部分）</li><li>恢复现场<br>恢复程序断点和CPU内部寄存器的内容</li><li>（中断返回）</li></ul></li><li>中断返回</li></ol><h5 id="形成中断入口地址的方法"><a href="#形成中断入口地址的方法" class="headerlink" title="形成中断入口地址的方法"></a>形成中断入口地址的方法</h5><ul><li>软件查询法<br>采用一个中断管理程序，按照优先级从高到低，依次查询每一个中断源是否有中断请求。</li><li>硬件向量法<br>有硬件生成一个特定的地址————向量地址，然后将向量地址通过数据总线送给CPU，CPU再依据向量地址转去执行中断服务程序。</li></ul><h5 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h5><p>处理中断过程中，可能有新的、优先级更高的中断请求到来。若CPU转去处理新的中断请求，称为多重中断、中断嵌套，否则称为单重中断。</p><h5 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h5><p>CPU根据中断屏蔽字决定屏蔽掉某些级别中断的请求信号，使其不能进入排队器排队，从而间接改变中断响应顺序。</p><p>注意，优先级严格来说，包含响应优先级和处理优先级，而我们设置的中断屏蔽字，改变的是中断处理优先级。</p><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>DMA，即 Direct Memory Access，直接内存访问，指CPU暂时让出总线的控制权，由专用接口芯片DMAC————DMA控制器，全权控制存储器与I/O之间直接进行高速的数据传送。<br>在DMA的数据传输过程中，CPU不干预，从而提高了CPU的效率。</p><h3 id="DMAC的组成"><a href="#DMAC的组成" class="headerlink" title="DMAC的组成"></a>DMAC的组成</h3><p>DMA控制器由如下部件组成：</p><ul><li>主存地址寄存器(AR)</li><li>字计数器(WC)</li><li>数据缓冲寄存器(BR)</li><li>设备地址寄存器(DAR)</li><li>中断逻辑</li><li>控制/状态逻辑</li></ul><h3 id="DMA的工作过程"><a href="#DMA的工作过程" class="headerlink" title="DMA的工作过程"></a>DMA的工作过程</h3><ol><li>预处理<br>即CPU选择DMAC和I/O接口，将一下信息写入对应的寄存器：<ul><li>外设地址————DAR</li><li>数据块在主存中的首地址————AR</li><li>数据个数————WC</li></ul></li><li>数据传输<br>以数据块为单位，传送数据。</li><li>后处理<br>数据传输结束后，DMA发起中断请求，得到响应，CPU将停止原程序的执行，转去执行中断服务程序，做一些DMA的结束工作。</li></ol><h3 id="DMAC的数据传输过程"><a href="#DMAC的数据传输过程" class="headerlink" title="DMAC的数据传输过程"></a>DMAC的数据传输过程</h3><p>DMA的数据传送模式包括：</p><ul><li>单字传送</li><li>成组传送</li><li>请求传送</li></ul><h3 id="CPU与DMAC分享主存-系统总线的方式"><a href="#CPU与DMAC分享主存-系统总线的方式" class="headerlink" title="CPU与DMAC分享主存/系统总线的方式"></a>CPU与DMAC分享主存/系统总线的方式</h3><p>DMAC占用总线的方式，通常有三种：</p><ul><li>停止CPU使用总线<br>控制方式简单，但是CPU的工作会受到明显的延误。</li><li>周期挪用<br>DMAC在CPU不使用总线时，“窃取”若干个总线周期，来传送一个数据字，几乎不影响CPU工作，应用最为广泛。</li><li>交替使用<br>将CPU的工作周期分为两个子周期，由DMAC和CPU分别使用总线。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令系统</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/17/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/17/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><h3 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h3><p>指令由两个部分组成：</p><ul><li>操作码字段</li><li>地址码字段</li></ul><h4 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h4><p>前者反映机器做什么操作。其长度可固定，也可变化。</p><ul><li>长度固定：大中型计算机</li><li>长度不固定：微型机</li></ul><blockquote><p>扩展操作码技术<br>操作码的位数随地址数的减少而增加。</p></blockquote><h4 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h4><p>地址码用来指出操作数的地址，包括</p><ul><li>源操作数的地址</li><li>结果目的操作数的地址</li><li>下一条指令的地址</li></ul><p>按照操作数地址的数目可以分为：</p><ul><li>四地址指令</li><li>三地址指令</li><li>二地址指令</li><li>一地址指令</li><li>零地址指令</li></ul><p>下面分别介绍不同类型的地址指令：</p><h5 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h5><div class="table-container"><table><thead><tr><th>OP</th><th>A1</th><th>A2</th><th>A3</th><th>A4</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>OP是操作码，A1为第一操作数地址，A2为第二操作数地址，A3为结果数地址，A4为下一条指令地址。<br>需要访问存储器4次：取操作码，取操作数两次，存放结果</p><h5 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h5><p>由于PC可以记录下一条指令的地址，故在四地址指令基础上可以省略A4，得到三地址指令。<br>仍然需要访问存储器4次。</p><h5 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h5><p>运算的结果不存入存储器，而是存入CPU中的ACC，那么就可以节省一个地址字段A3。</p><h5 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h5><p>一个操作数也存放在ACC中，那么整个地址码只有一个字段，表示另一个操作数所在内存地址。</p><h5 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h5><p>有些操作不需要操作数，如停机、中断返回、空操作等。</p><h3 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h3><blockquote><p>机器字长：计算机一次能够处理的最长的二进制位数<br>存储字长：一个存储单元可存储的二进制代码的位数<br>指令字长：指令中包含的二进制代码的位数，等于操作码长度加上地址码长度</p></blockquote><h2 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h2><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>包括地址、数字、字符、逻辑数等。</p><h3 id="存储器中数据的存放"><a href="#存储器中数据的存放" class="headerlink" title="存储器中数据的存放"></a>存储器中数据的存放</h3><p>边界对准。</p><h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p>不同的机器操作类型不同，但是有以下几类通用操作。</p><ul><li>数据传送</li><li>算术逻辑操作</li><li>移位操作</li><li>转移<ul><li>无条件转移</li><li>条件转移</li><li>调用和返回</li><li>陷阱指令</li></ul></li><li>输入输出指令</li></ul><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>目的：用以确定本条指令的操作数地址和下一条欲执行指令的指令地址。<br>可分为：</p><ul><li>指令寻址</li><li>数据寻址</li></ul><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>分为</p><ul><li>顺序寻址<br>依靠程序计数器PC形成下一条指令的地址，顺序寻址</li><li>跳跃寻址<br>通过转移类指令实现，如JMP 7</li></ul><h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>通常，指令中的地址码不给出数据的有效地址（记作EA），而是给出一个形式地址（A）。</p><ol><li>立即寻址<br>形式地址A就是操作数，称为立即数；<br>但是形式地址A的位数限制了立即数的范围。</li><li>直接寻址<br>有效地址由形式地址直接给出；<br>但是，A的位数限制了指令操作数的寻址范围，且操作数的地址不易修改。</li><li>隐含寻址<br>操作数地址隐含在操作码中。</li><li>间接寻址<br>数据的有效地址由形式地址间接提供；<br>这样一来，可以扩大寻址范围，也便于编制程序。</li><li>寄存器直接寻址<br>有效地址即为寄存器编号。</li><li>寄存器间接寻址<br>有效地址在寄存器中，而操作数在存储器中。也就是说，与寄存器直接寻址相比，间接寻址还需要访问主存。</li><li>基址寻址<br>OP 寻址特征 基址寄存器 操作数地址<br>基址寄存器中的内容由操作系统确定，<br>在程序执行过程中，基址寄存器中的内容不变，而形式地址改变。<blockquote><p>基址寄存器有隐式和显式两种。<br>隐式无需用户指出，显式相当于在一组通用寄存器中，由用户明确指出哪一个作为基址寄存器。</p></blockquote></li><li>变址寻址<br>特点：EA = (IX) + A<br>其中，IX为变址寄存器，其内容由用户给定<br>在程序执行过程中，IX内容可变，形式地址A不变</li><li>相对寻址<br>公式：EA = (PC) + A<br>A是相对于当前指令的位移量（可正可负，补码形式）</li></ol><h2 id="RISC与CISC"><a href="#RISC与CISC" class="headerlink" title="RISC与CISC"></a>RISC与CISC</h2><p>RISC，采用组合逻辑控制器<br>CISC，采用微程序控制器</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/17/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/17/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><h3 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h3><ul><li>半导体存储器，如TTL、MOS，是易失性</li><li>磁表面存储器，如磁盘、磁带，非易失性</li><li>磁芯存储器，非易失性</li><li>光盘存储器，非易失性</li></ul><h3 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h3><ul><li>存取时间与物理地址无关<ul><li>随机存储器</li><li>只读存储器</li></ul></li><li>存取时间与物理地址有关<ul><li>顺序存取存储器</li><li>直接存取存储器</li></ul></li></ul><h3 id="按在计算机中的作用分类"><a href="#按在计算机中的作用分类" class="headerlink" title="按在计算机中的作用分类"></a>按在计算机中的作用分类</h3><ul><li>主存储器</li><li>Flash Memory（闪存）</li><li>高速缓冲存储器（Cache）</li><li>辅助存储器，如磁盘、磁带、光盘</li></ul><h2 id="存储器的存储结构"><a href="#存储器的存储结构" class="headerlink" title="存储器的存储结构"></a>存储器的存储结构</h2><p>三个主要特性：</p><ul><li>速度</li><li>容量</li><li>位价（价格/位）</li></ul><p>金字塔形说明图</p><h3 id="两个层次结构"><a href="#两个层次结构" class="headerlink" title="两个层次结构"></a>两个层次结构</h3><ul><li>缓存-主存层次：解决CPU和主存速度不匹配的问题</li><li>主存-辅存层次：解决存储系统的容量问题</li></ul><h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存概述"><a href="#主存概述" class="headerlink" title="主存概述"></a>主存概述</h3><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><ol><li>存储容量：主存中存放二进制代码的总位数</li><li>存储速度<ol><li>存取时间：存储器的访问时间</li><li>存取周期：存储器进行一次完整的读写操作所需的全部时间，即连续两次独立的存储器操作所需的最小间隔时间</li></ol></li><li>存储器带宽：单位时间内存储器存取的信息量</li></ol><blockquote><p>存取时间不等于存储周期，通常存储周期大于存储时间。这是因为对任何一种存储器，在读写操作之后，总要有一段时间恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，因为存储器中的信息读出后需要马上进行再生。</p></blockquote><h3 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h3><h4 id="半导体存储芯片的译码驱动"><a href="#半导体存储芯片的译码驱动" class="headerlink" title="半导体存储芯片的译码驱动"></a>半导体存储芯片的译码驱动</h4><p>驱动方式有两种：</p><ul><li>线选法</li><li>重合法</li></ul><h3 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h3><p>分为静态RAM和动态RAM。</p><h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><p>由于动态RAM用到了电容，电容会漏电，所以动态RAM需要“刷新”。</p><h4 id="动态RAM与静态RAM的比较"><a href="#动态RAM与静态RAM的比较" class="headerlink" title="动态RAM与静态RAM的比较"></a>动态RAM与静态RAM的比较</h4><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><ol><li>掩模ROM（MROM）</li><li>PROM：一次性编程的只读存储器</li><li>EPROM：可擦除可编程只读存储器<ol><li>紫外线照射擦除</li><li>电气方法擦除（电可擦写）</li></ol></li><li>EEPROM：电可擦写、局部擦写、全部擦写</li><li>闪速存储器</li></ol><h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><h4 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h4><p>包括三种扩展：</p><ul><li>位扩展</li><li>字扩展</li><li>字、位扩展</li></ul><h5 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h5><p>即增加存储字长。<br>以两块芯片为例，注意它们的数据引脚连接数据线，片选信号连接在一起（保证位扩展的两块存储芯片一起工作）。</p><h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p>即增加存储字的数量。<br>注意扩展的是存储字的数量，存储字长不变，也就是说，被扩展的两个存储芯片不可以一起工作，而是通过片选信号每次选中一块，从而使得两块芯片都可以工作。</p><h5 id="字、位扩展"><a href="#字、位扩展" class="headerlink" title="字、位扩展"></a>字、位扩展</h5><p>存储字长和存储字的数量同时扩展。</p><h4 id="连接做法"><a href="#连接做法" class="headerlink" title="连接做法"></a>连接做法</h4><p>存储器与CPU的连接，需要注意：</p><ul><li>地址线<br>CPU地址线往往比存储芯片地址线多，通常将CPU地址线的低位与存储芯片的地址线相连。</li><li>数据线<br>经位扩展之后，CPU和存储芯片数据线数量相等，直接相连即可。</li><li>读写命令线<br>按照要求相连即可。</li><li>片选线的连接（重要）<br>是CPU与存储芯片正确工作的关键。通常由CPU地址线高位来形成片选信号。</li><li>合理选择存储芯片</li></ul><h3 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h3><h3 id="提高主存储器访问带宽"><a href="#提高主存储器访问带宽" class="headerlink" title="提高主存储器访问带宽"></a>提高主存储器访问带宽</h3><p>解决方法：</p><ul><li>采用高速器件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构<ul><li>引入并行处理技术，如并行处理器，多端口RAM、多模块处理器等。</li></ul></li></ul><h4 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h4><p>具有两个独立的端口，分别具有各自的地址总线、数据总线和控制总线。</p><h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><ol><li>单体多字系统<br>由于程序访问存在着局部性，所以对相邻存储信息的使用往往是连续的。多个存储器共用一套地址逻辑，一个访存地址就可以把存储于多个存储器模块中相同地址单元的多个字一并读出。</li><li>多体并行系统<ol><li>高位交叉存储<br>体号 体内地址<br>即地位地址表示体内地址，高位地址表示体号。<br>特点：<ul><li>同一个存储体的地址空间连续</li><li>不利于并行处理</li><li>容易发生访存冲突</li><li>有着可靠性高的优点<br>本质上，由于局部性原理，相邻存储信息的使用往往连续，按照高位交叉存储方式，相邻存储信息一般保存在同一个存储器中了。</li></ul></li><li>低位交叉存储<br>体内地址 体号<br>它的特点与高位交叉存储的完全相反。<br>本质上，由于局部性原理，相邻存储信息的使用往往连续，按照低位交叉存储方式，相邻存储信息一般保存在不同的存储器中（体号连续）了。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRASP模式</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/17/GRASP%E5%8E%9F%E5%88%99/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/17/GRASP%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>GRASP模式，即“通用职责分配软件模式”，描述了对象设计和职责分配的基本原则，是面向对象系统的基础。<br>通俗地说，就是在一个面向对象的系统中，该添加什么方法（职责），给谁添加方法（职责），是值得我们深思的。<br>而GRASP模式，就给我们提供了指导。</p><p>GRASP模式，分为九种：</p><ul><li>信息专家模式</li><li>创造者模式</li><li>低耦合模式</li><li>高内聚模式</li><li>控制器模式</li><li>多态模式（层次类）</li><li>纯虚构模式</li><li>间接模式（另设中介类）</li><li>受保护模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象建模技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>Cache的出现，可以一定程度上解决以下三个方面的问题：</p><ul><li>解决DRAM主存与CPU速度之间的不匹配</li><li>解决CPU与I/O的访存冲突</li><li>避免CPU“空等”现象</li></ul><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>局部性原理（程序访问的局部性原理）</p><h3 id="Cache思想"><a href="#Cache思想" class="headerlink" title="Cache思想"></a>Cache思想</h3><p>Cache体现的是一种思想：“缓存”思想，即将经常被用到的东西，放到更加容易方便获取的地方。</p><h3 id="Cache的使用"><a href="#Cache的使用" class="headerlink" title="Cache的使用"></a>Cache的使用</h3><ul><li>CPU内部集成了两级Cache，即L1CACHE，L2CACHE</li><li>主板上有Cache</li><li>硬盘、打印机、CD-ROM（只读光盘）等外围设备都加上了Cache；</li><li>访问网站时都会在本地保存网站的cookie；</li></ul><h3 id="“块”"><a href="#“块”" class="headerlink" title="“块”"></a>“块”</h3><p>数据块————把若干存储单元称为一个数据块；<br>此外，内存与Cache之间是以数据块为单位进行交换的。</p><h3 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h3><h4 id="主存和缓存的编址"><a href="#主存和缓存的编址" class="headerlink" title="主存和缓存的编址"></a>主存和缓存的编址</h4><p>主存储器和缓存地址都分成了两段，</p><ul><li>主存：高m位表示主存块地址，低b位表示块内地址</li><li>缓存：高c位表示缓存的块号，低b位表示块内地址</li></ul><h4 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h4><p>缓存的高c位表示存放的是哪一个主存块，相当于主存块的块号，CPU在访问Cache时，用主存地址的m位与标记位比较，确定是否命中。</p><ul><li>命中，则主存块已经调入缓存，主存块与缓存块已经建立了对应关系。</li><li>未命中，则主存块未调入缓存，主存块与缓存块未建立对应关系。</li></ul><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><p>命中率是衡量Cache效率的主要指标。</p><script type="math/tex; mode=display">命中率 = \frac{CPU访问Cache的次数}{CPU访问内存和Cache的总次数}</script><p>可见，主存、缓存都用b位表示块内字数，即 $ 2^b $ 用以表示块的大小，称为块长。</p><h4 id="主存-Cache地址映像"><a href="#主存-Cache地址映像" class="headerlink" title="主存-Cache地址映像"></a>主存-Cache地址映像</h4><p>即将CPU送来的主存地址变换成Cache地址。依赖于主存Cache地址映像变换机构。<br>映射方式包括：</p><ul><li>直接映射</li><li>全相联映射</li><li>组相联映射</li><li>段相联映射</li></ul><h5 id="直接映射方式"><a href="#直接映射方式" class="headerlink" title="直接映射方式"></a>直接映射方式</h5><p>记Cache块号为i，主存块号为j，Cache总块数量为C，则映射为：</p><script type="math/tex; mode=display">i = j mod C</script><p>可以看出，每一个Cache块i可以对应多个主存块；<br>而每一个主存块j只能和一个Cache缓存块i对应。</p><p>但是，由于每一个Cache缓存块可以和 $ 2^{m-c}个主存块对应 $，故主存地址高位有t=m-c位为主存字块标记，Cache也有t位记录当前对应的是哪一个主存（块号）。</p><h5 id="全相联映射方式"><a href="#全相联映射方式" class="headerlink" title="全相联映射方式"></a>全相联映射方式</h5><p>即主存中的每一个字块映射到Cache中的任何一块位置上。<br>由于每一个Cache块对应全部的主存块，因此主存字块标记位有m=t+c位，Cache也有m位。</p><h5 id="组相联映射方式"><a href="#组相联映射方式" class="headerlink" title="组相联映射方式"></a>组相联映射方式</h5><p>即Cache分为Q组，每组R块，则主存块j与Cache组号i之间的映射为：</p><script type="math/tex; mode=display">i = j mod Q</script><p>可以看出，主存块与Cache之间是直接映射，主存块同Cache特定组内的块是全相联映射。</p><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><h4 id="何为替换"><a href="#何为替换" class="headerlink" title="何为替换"></a>何为替换</h4><p>当一个新的主存块需要拷贝到Cache中，而允许存放该新块的位置被其他的主存块占用时，就需要替换。<br>由硬件完成。</p><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><ol><li>先进先出算法<br>即将最先调入Cache的字块替换出去。</li><li>近期最少使用算法<br>即将近期内最少使用的字块替换出去。</li><li>随机法</li></ol><h3 id="写操作策略"><a href="#写操作策略" class="headerlink" title="写操作策略"></a>写操作策略</h3><blockquote><p>Cache应该与主存内容保持一致，而CPU对Cache的写入会改变Cache中的内容，因此如何保持Cache与内存内容的一致性，就需要采取策略。</p></blockquote><ol><li>写回法<ul><li>当CPU与Cache命中时，只修改Cache中的内容，而不立即写入主存，只有当该块被替换出时，才写回主存。</li><li>优点：减少了CPU访问主存的次数。</li><li>缺点：写内存与写Cache是异步进行的，故存在内存与Cache不一致的隐患。</li><li>注意：为了区别Cache中的块是否经过了修改，另设标志位，“清”表示未修改过，“浊”表示已修改过。</li></ul></li><li>全写法<br>写Cache命中时，数据既写入Cache，也写入主存。<br>未命中时，数据只直接写入内存。</li><li>只写主存法<ul><li>当写Cache命中时，信息只写入主存，同时将相应的Cache块置为失效，也就是说，下一次需要时，再重新调入。</li><li>这种写法效率低下。</li></ul></li></ol><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul><li>当前计算机系统中，三级结构的存储器系统：<ul><li>高速缓冲存储器</li><li>主存储器</li><li>虚拟存储器</li></ul></li></ul><p>三级不同的存储器存放的信息必须满足如下两个原则：</p><ul><li>一致性原则：同一个信息在几个级别的存储器中必须保持相同的值。</li><li>包含性原则：处在内层的存储器中的信息一定被包含在外层的各个存储器中。</li></ul><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>被传输N位，加入一位校验位，使得整个N+1位信息中“1”的个数为偶数（或者奇数），称为偶校验（奇校验）。</p><h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码是一种可以纠正一位差错的编码。</p><blockquote><p>纠错理论：L - 1 = D + C,<br>其中，L是编码的最小距离，D是检测错误位数，C是纠正错误的位数<br>也就是说，要想编制具有更多位纠错能力的编码，则要求L更大。</p></blockquote><p>汉明码的组成</p><ul><li>海明码的位数：海明码需增添k位检测位</li><li>海明码的位置<br>每一个增添的检测位，负责检测一个小组，通常一个小组包含位数较多。<br>组：1，3，5，7<br>组：2，3，6，7<br>组：4，5，6，7</li><li>海明码的取值</li></ul><p>汉明码的纠错</p><p>实际上，是对传送后的汉明码形成新的检测位P，根据P的状态，可以直接指出错误的位置。</p><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><h4 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h4><p>二进制数的运算</p><h4 id="CRC码的编码方法"><a href="#CRC码的编码方法" class="headerlink" title="CRC码的编码方法"></a>CRC码的编码方法</h4><p>k位校验码，位于原信息位的后面；<br>拿到题目给出的多项式G(x)，用多项式去除，拿到结果的余数，即为校验位。</p><h4 id="CRC码的检错与纠错"><a href="#CRC码的检错与纠错" class="headerlink" title="CRC码的检错与纠错"></a>CRC码的检错与纠错</h4><p>CRC码某一位出错，除以G(x)的结果必不为零。不同的出错位，其余数也不尽相同。<br>将不为零的余数补0继续模2除，得到下一信息位的出错余数；出错信息位对应的余数构成一个循环————“循环码”。</p><h2 id="字符的表示"><a href="#字符的表示" class="headerlink" title="字符的表示"></a>字符的表示</h2><ul><li>字符</li><li>EBCDIC码</li><li>ASCII码</li><li>汉字编码</li><li>Unicode码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML结构图</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/08/UML%E7%BB%93%E6%9E%84%E5%9B%BE/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/08/UML%E7%BB%93%E6%9E%84%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>UML，即统一建模语言，是软件行业主要的建模语言，用于分析、明确说明、设计软件系统。<br>UML12.0支持13种图，可以分为两类：结构图和行为图。</p><p>而UML结构图用于表示系统中元素的静态结构，结构图包括：包图、类图、构件图、部署图、对象图、组合结构图。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图用来描述系统的静态结构，用来描述不同的类以及它们之间的关系。<br>在UML类图中一共包含三种模型元素，分别是：</p><ul><li>类</li><li>接口</li><li>类之间的关系</li></ul><h3 id="单个类的UML表示方法"><a href="#单个类的UML表示方法" class="headerlink" title="单个类的UML表示方法"></a>单个类的UML表示方法</h3><p>通俗地讲，每一个类的UML分为三个由横线分隔的区域。</p><ol><li>标出类名，类名就是一个字符串</li><li>标出类中的属性，即类的成员变量，格式大体如下：<br>可见性 名称 :类型[= 默认值]</li><li>标出类中的操作，即类的成员方法，格式大体如下：<br>可见性 名称(参数列表) :返回类型</li></ol><blockquote><p>属性与操作的可见性：<br>+表示public</p><h1 id="表示protected"><a href="#表示protected" class="headerlink" title="表示protected"></a>表示protected</h1><p>-表示private<br>~表示默认，或者包内可见</p></blockquote><h3 id="类之间的六种关系"><a href="#类之间的六种关系" class="headerlink" title="类之间的六种关系"></a>类之间的六种关系</h3><p>类之间的关系大体可以分类如下：</p><ul><li>横向关系<ul><li>依赖</li><li>关联<ul><li>聚合</li><li>组合</li></ul></li></ul></li><li>纵向关系<ul><li>泛化</li><li>实现</li></ul></li></ul><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><p>表示类与类之间/接口与接口之间的一种继承关系，指定了子类如何特化父类的所有特征和行为。</p><ul><li>对于抽象方法和抽象类名，用斜体表示</li><li>使用带空心的三角箭头的实线表示，箭头指向父类</li><li>简记，箭头指向谁，就继承谁（宾语）</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现也是一种继承，表示类是接口所有特征和行为的实现。</p><ul><li>使用带三角箭头的虚线表示，箭头指向接口类。</li><li>简记，箭头指向谁，就实现谁（宾语）</li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>对于两个相对独立的对象，当一个对象构造另一个对象的实例时，这两个对象之间主要体现为依赖关系。</p><blockquote><p>依赖关系可以通过三种方式实现：<br>某一个类的方法使用另一个类的对象作为参数<br>在一个类的方法中将另一个类的对象作为其局部变量<br>在一个类的方法中调用另一个类的静态方法</p></blockquote><ul><li>使用带箭头的虚线，指向被使用者或者被创建者</li><li>可以将依赖关系理解为一种使用的关系，即“use-a”关系</li><li>这种使用的关系是一种具有偶然性、临时性的弱关系</li><li>简记，箭头指向谁，就依赖谁（宾语）</li></ul><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>两个相对独立的对象之间存在固定的对应关系时，它们之间为关联关系。<br>关联关系是两个类之间一种强的依赖关系，是长期性的，可以理解为“has-a”的关系。</p><ul><li>单向关联：类B作为了类A的成员变量<ul><li>使用带普通箭头的实心线表示，箭头指向被拥有者</li><li>简记，箭头指向谁，就拥有谁（宾语）</li></ul></li><li>双向关联：B中有A，A中有B<ul><li>使用带有两个箭头或者没有箭头的实心线表示</li></ul></li><li>自关联：自己包含自己</li></ul><p>每一种关联关系的连线表示，需要标注出关联名、关联端点名和关联重数</p><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>聚合属于关联，耦合度强于关联，仅仅在语义上有所区别。简单点说，聚合关系强调的是“整体”包含“部分”，但是“部分”可以脱离“整体”而单独存在。</p><ul><li>表示方式是带空心菱形的实线，菱形紧靠整体，另一端指向被拥有者。</li></ul><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>一种比聚合还强的关系，要求代表整体的对象负责代表部分的对象的生命周期。</p><ul><li>表示方式是带实心菱形的实线，菱形紧靠整体。</li></ul><h3 id="UML中的注释"><a href="#UML中的注释" class="headerlink" title="UML中的注释"></a>UML中的注释</h3><h3 id="UML中的限制"><a href="#UML中的限制" class="headerlink" title="UML中的限制"></a>UML中的限制</h3><h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><p>对象图用于呈现系统在特定时刻的对象（Object），以及对象之间的链接。</p><ul><li>对象图中仅仅声明类名也没有对象名，则称之为匿名对象；</li><li>对象图不显示操作，因为所有对象都有着相同的操作。</li></ul><h2 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h2><p>将相关的、欲放置在一起的东西打包成箱。<br>包的内部可以放置：包、用例图、类图、组件图等等。</p><ul><li>元素的导入：可以将包内的任意元素导入到另一个包中，需用到import关键字。</li></ul><h2 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h2><p>显示一组组件以及它们之间的相互关系。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象建模技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机中信息的表示与运算</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>计算机存储数值采取编码形式，常见的编码有四种：</p><ul><li>原码</li><li>补码</li><li>反码</li><li>移码</li></ul><h2 id="先导概念"><a href="#先导概念" class="headerlink" title="先导概念"></a>先导概念</h2><ul><li>真值：即真正的数值，是带有正负号的一种数，人类可以识别。</li><li>机器数：将符号数值化之后的结果，计算机可以识别。</li><li>定点数<ul><li>定点整数：默认小数点在数值最低位之后</li><li>定点小数：默认小数点在符号位与数值最高位之间</li><li>有符号数：最高位为符号位，次高位为数值位</li><li>无符号数：最高位就为数值位</li></ul></li></ul><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>最简单的一种码，即真值符号化的最简单的结果，极似真值。<br>求数的原码很简单：</p><ul><li>得到数的二进制表示形式</li><li>确定符号位，整数为0，负数为1</li><li>注意机器字长（寄存器位数），补零</li></ul><p>在书写上，若逗号，放在了符号位和数值最高位之间，则是一个定点整数；<br>若小数点.放在了符号位和数值最高位之间，则是一个定点小数。</p><h3 id="原码表示范围"><a href="#原码表示范围" class="headerlink" title="原码表示范围"></a>原码表示范围</h3><p>注意原码的表示范围。原码表示无符号数时，表示区间与有符号数有差异。</p><h3 id="0的原码"><a href="#0的原码" class="headerlink" title="0的原码"></a>0的原码</h3><p>另注意：<br>0的原码有俩，因为从真值上看，+0和-0都是0，但是其机器码（原码）却有差别：<br>+0 —- 0,0000000B<br>-0 —- 1,0000000B</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码的出现，首先就是为了找到一个等价于某一个数，以方便运算。</p><blockquote><p>补码计算公式<br>关于补码公式，教材上有完整的表述，此外注意二进制数的两种特殊形式：<br>2^n - 1 = 11…1<br>2^n = 100…0</p></blockquote><h3 id="补码的二义性"><a href="#补码的二义性" class="headerlink" title="补码的二义性"></a>补码的二义性</h3><p>由于补码对定点整数和定点小数的公式不同，因此，以-1为例，-1作为定点整数和定点小数时，会得到两种不同的结果！具体按公式来。</p><h3 id="补码和原码的对比现象"><a href="#补码和原码的对比现象" class="headerlink" title="补码和原码的对比现象"></a>补码和原码的对比现象</h3><p>一个负数的原码从它的低位算起，<br>    ①遇到第一个“1”时，原码与补码是相同的。<br>    ②超过这个“1”直至符号位之间的那段数位，原码与补码是相反的。</p><h3 id="求补码快捷方式"><a href="#求补码快捷方式" class="headerlink" title="求补码快捷方式"></a>求补码快捷方式</h3><ul><li>对于正数，其补码和原码一致</li><li>对于负数，其补码由原码除符号位外，各位取反，然后末尾加一，得到</li><li>已知某真值的补码，求其相反数的补码，则将包括符号位在内的补码，各位取反，末尾加一，得到</li></ul><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><h3 id="移码公式"><a href="#移码公式" class="headerlink" title="移码公式"></a>移码公式</h3><p>移码公式说白了，就是将真值往高位方向移动一定的数值，主要用于需要对数据进行大小比较的场合。<br>如果真值有n位，就在真值基础上加上100…0（n个0）即可。</p><h2 id="定点数与浮点数的表示"><a href="#定点数与浮点数的表示" class="headerlink" title="定点数与浮点数的表示"></a>定点数与浮点数的表示</h2><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>借助数学中的科学记数法，将浮点数转化为定点数。<br>一个浮点数可以表示为： N = M × R^E<br>其中，</p><ul><li>M称为尾数，一般取一个定点小数</li><li>R称为基值</li><li>E称为阶码</li></ul><h3 id="规格化表示"><a href="#规格化表示" class="headerlink" title="规格化表示"></a>规格化表示</h3><p>为了利用尾数所占的二进制数位来表示最多的有效数字，浮点数一般采用“规格化形式”：<br>也即尾数绝对值的最高位必须为1，即尾数绝对值必须大于或者等于1/R。</p><p>当规格化过程中，浮点数阶码小于最小阶码时，称发生“下溢”。</p><h3 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h3><p>以原码表示，分析即可。<br>最大正数<br>最小正数<br>最大负数<br>最小负数</p><h3 id="长实数与实数"><a href="#长实数与实数" class="headerlink" title="长实数与实数"></a>长实数与实数</h3><p>长实数：64位浮点数<br>实数：32位浮点数</p><h2 id="定点数的运算"><a href="#定点数的运算" class="headerlink" title="定点数的运算"></a>定点数的运算</h2><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><blockquote><p>明确两个概念：<br>算术移位：有符号数的移位<br>逻辑移位：无符号数的移位</p></blockquote><h4 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h4><h5 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h5><p>最首要的规则，就是符号位不变。</p><ul><li>对于正数，原码、补码、反码的移位只需补0即可</li><li>对于负数<ul><li>原码，左移右移均补0</li><li>补码，左移补0，右移补1</li><li>反码，左移右移均补1</li></ul></li></ul><h5 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h5><p>由于逻辑移位处理的是无符号数，所以相对而言比较简单，规则就是：<br>移出的空位均补0</p><h3 id="加法与减法运算"><a href="#加法与减法运算" class="headerlink" title="加法与减法运算"></a>加法与减法运算</h3><p>补码的引入，使得定点数的加、减运算都被统一成了加法运算，所以对于加减运算，我们都采取补码形式。<br>此外，补码运算也不需要单独处理符号位，它在运算过程中自然形成，这样一来大大简化了硬件设计。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>[X + Y]补 = [ X ]补 + [ Y ]补<br>[X - Y]补 = [ X ]补 + [ -Y ]补<br>对于整数，结果需要对2^(n+1)取模；<br>对于小数，结果需要对2取模。<br>也即对超出字长的数位丢弃。</p><blockquote><p>公式的证明<br>分四种情况来证明即可，分类讨论，注意运用补码公式（含取模）！</p></blockquote><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>导致溢出的原因，就是计算机字长是固定的，数值位最高位产生的进位1被字长最高位吸收，而这个“1”属性本来是数值，而现在却被当做了符号。</p><p>同号操作数相加时，可能“溢出”；<br>异号操作数相加时，绝对不会“溢出”。</p><h4 id="溢出的判断"><a href="#溢出的判断" class="headerlink" title="溢出的判断"></a>溢出的判断</h4><p>两个数符号相同，而结果的符号不同，这时一定发生了溢出。</p><blockquote><p>硬件实现：最高有效位的进位 和 符号位的进位作异或操作，若结果为1，则溢出了。</p></blockquote><p>双符号位判断法：符号位由原来的一位变成了两位，操作之后，若双符号位取值不同，表示发生了“溢出”。</p><h3 id="乘法操作"><a href="#乘法操作" class="headerlink" title="乘法操作"></a>乘法操作</h3><h4 id="笔算乘法的改进过程"><a href="#笔算乘法的改进过程" class="headerlink" title="笔算乘法的改进过程"></a>笔算乘法的改进过程</h4><p>首先，对于乘积式A×B，约定A为被乘数，B为乘数。<br>定义两种说法：部分积与单次乘数。<br>部分积：是指每一次乘法得到的结果，最后的积由每一个部分积累加而成。<br>单次乘数：每一次取B的一个数位，这个数位上的数就是单次乘数。</p><p>过程大致如下：</p><ol><li>初始状态，部分积为0；</li><li>取B的最低位作为乘数，与A相乘后的结果（要么是0要么是A）与部分积相加，更新部分积；</li><li>部分积连同B一起右移一位（即部分积的最低位移到乘数的最高位，乘数的最低位丢失），重复第2~3步即可。</li></ol><p>从硬件实现角度看，完成整个乘法需要三个寄存器（分别存放被乘数、乘积的高位、以及乘数和乘积的低位），一个全加器和其他相应的电路。</p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><p>符号位：被乘数和乘数的符号位作异或操作；<br>数值位：按照上述笔算乘法的改进过程即可。</p><h5 id="原码的二位乘法"><a href="#原码的二位乘法" class="headerlink" title="原码的二位乘法"></a>原码的二位乘法</h5><h5 id="补码的一位乘法"><a href="#补码的一位乘法" class="headerlink" title="补码的一位乘法"></a>补码的一位乘法</h5><p>乘数为正数时，两数积的补码等于补码的积。<br>这里的加、移位操作都必须按照补码的规则来！<br>乘数为负数时，公式有些许不同。<br>运算过程大体与之前的一致。</p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h4 id="原码的除法"><a href="#原码的除法" class="headerlink" title="原码的除法"></a>原码的除法</h4><ul><li>商的符号位单独处理（异或）</li><li>商的数值部分为绝对值相除</li></ul><p>对于A÷B，我们以下的被除数，除数都是在原题基础上不考虑符号位的无符号数。<br>不恢复余数法：</p><ol><li>初始状态商为0，被除数为A；</li><li>用被除数减去除数，也就是加上除数的相反数的补码，如果结果（即余数）为正，上商1，否则上商0（均在当前商的最低位）；</li><li>如果上一步得到的余数为负数，那么需要加上除数，以将余数恢复为一个正数，如果为正数直接进行下一步了；</li><li>将得到的余数逻辑左移，同时当前的商也左移，重复第2~4步。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML行为图</title>
      <link href="/mid-lake-pavilion.github.io/2021/12/03/UML%E8%A1%8C%E4%B8%BA%E5%9B%BE/"/>
      <url>/mid-lake-pavilion.github.io/2021/12/03/UML%E8%A1%8C%E4%B8%BA%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>UML行为图，是用来描述系统中元素的动态行为。例如对象的创建与销毁之类的。</p><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>是用户与系统交互的最简表示形式。便于理解，问问自己对于任何一个系统这三个问题：</p><ol><li>系统给谁用的？</li><li>系统有什么功能？</li><li>不同的用户分别用到什么功能？</li></ol><p>针对这样的基本问题，用例图给出了一定的描述，对应的用例图中元素为</p><ol><li>小人+名称（表示角色）</li><li>椭圆及内部文字表示用例</li><li>小人与椭圆之间的连线</li></ol><h3 id="用例描述"><a href="#用例描述" class="headerlink" title="用例描述"></a>用例描述</h3><p>用例是一个比较抽象的概念，用例图仅仅是较为直观的粗略反映了系统的功能。但是，这并不完整。因此，还需要对每一个用例进行文字描述，称之为用例描述。有以下注意点：</p><ul><li>做用例描述时，不必涉及系统内部的结构，而只是涉及到人与系统的交互细节。</li><li>大致按照人-系统交互，即人操作、系统反应的流程来进行用例描述。</li></ul><p>大致可分为：</p><ul><li>乐观流（正常流，一切顺利）</li><li>实际流（有异常出现）</li></ul><p>用例之间的关系：</p><ul><li>泛化关系（即子用例继承父用例）</li><li>包含关系（基础用例相当于调用者，内含用例相当于子程序）</li><li>扩展关系（用例功能的延伸，相当于添加一个附加功能）</li></ul><p>包含关系include和扩展关系extend都需要使用带箭头的直线来表示，前者的箭头指向内含用例，后者的箭头指向被延伸的用例。</p><h4 id="角色分离"><a href="#角色分离" class="headerlink" title="角色分离"></a>角色分离</h4><p>当一个人充当多个角色时，需要将角色从这个人身上分离<br>角色和用例之间，如果导航明确，可以绘制方向，箭头指向消息接收方。也可能箭头指向自己（此时角色接收用例执行的结果和数据）。</p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>大体来说，有点类似流程图，但是流程图几乎都是一个流，而活动图可以方便表示多个流的任务一起进行。<br>包括的节点类型：行动节点和控制节点。</p><ul><li>必须有初始节点、最终节点。</li><li>决策节点：类似于流程图中的判断框，在该节点会生出至少两个分支。具有一个内向流和几个外向流（通常带有保护条件），然后只选择其中一个外向流。</li><li>合并节点：多个事件不等待，不同步，先到达合并节点者先进入下一步。</li><li>分叉节点：分叉出不同的分支，然后并行。</li><li>汇合节点：当两个流的任务都完成后，才可以向下流。</li></ul><h2 id="状态机图"><a href="#状态机图" class="headerlink" title="状态机图"></a>状态机图</h2><p>状态机图表示的是，某一个对象在不同状态下的行为。</p><p>注意状态机图的图例：初始状态、最终状态等。</p><h3 id="完整的状态转换描述表示法"><a href="#完整的状态转换描述表示法" class="headerlink" title="完整的状态转换描述表示法"></a>完整的状态转换描述表示法</h3><p>触发器[监护条件]/转换行为<br>其中，每一个元素都是可选的。</p><ul><li>触发器 指能够引起转换的事件。</li><li>监护条件 允许或封锁转换的一个Boolean条件，若条件为真，则接受转换，否则封锁转换。</li><li>转换行为 转换发生时所执行的连续活动。</li></ul><h2 id="顺序图（时序图）"><a href="#顺序图（时序图）" class="headerlink" title="顺序图（时序图）"></a>顺序图（时序图）</h2><p>使用时序图最大的作用就是，可以清楚地表示按照时间顺序的消息传递。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象建模技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的基本使用</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/28/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/28/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Git基本理念"><a href="#Git基本理念" class="headerlink" title="Git基本理念"></a>Git基本理念</h2><p>首先，我们需要知道的是Git是一个版本管理工具，它为我们提供了大量实用的命令，帮助我们实现有效的多人协作开发。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>Git的工作流程一般大体如下：</p><ol><li>克隆Git资源作为我们自己的工作目录；</li><li>在克隆的资源上添加或修改文件；</li><li>如果其他人修改了克隆的资源，我们可以及时更新资源；</li><li>在提交之前查看修改；</li><li>提交修改；</li><li>在修改完成后，如果发现错误，可以撤回提交并且再次修改并提交。</li></ol><h3 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h3><ul><li>工作区：就是我们电脑里面能看到的目录。</li><li>暂存区（stage，index），一般存放在.git目录下的index文件，有时候也把暂存区称作索引（index）。</li><li>版本库（仓库，repository）：工作区有一个隐藏目录.git，它就是Git版本库。</li></ul><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p><code>git init   创建本地仓库</code><br><code>git add .  将文件添加到暂存区</code><br><code>git commit     将暂存区的内容添加到仓库中</code></p><p><code>git log    查看版本更改的历史记录</code><br><code>git reset  版本回退</code></p><h2 id="Git提交文件操作"><a href="#Git提交文件操作" class="headerlink" title="Git提交文件操作"></a>Git提交文件操作</h2><blockquote><p>如何提交提定文件更改到暂存区，如何提交特定文件夹更改到暂存区，如何提交全部文件更改到暂存区?</p></blockquote><p>git add readme.md   提交文件到暂存区<br>git add readme.md test.txt  提交多个文件到暂存区</p><h2 id="Git状态的掌握"><a href="#Git状态的掌握" class="headerlink" title="Git状态的掌握"></a>Git状态的掌握</h2><p>使用git status可以时刻掌握仓库当前的状态，<br>使用git diff可以查看difference，即两者的区别</p><h2 id="Git版本的回退与恢复"><a href="#Git版本的回退与恢复" class="headerlink" title="Git版本的回退与恢复"></a>Git版本的回退与恢复</h2><p>我们在开发项目时，少不了多次提交代码，这样也就有了许多个不同的版本了。但是我们有时候就需要回到特定的版本中处理一些代码。对此，我们首先要用到命令<br><code>git log</code><br>显示所有的版本信息，可以看见此时git显示了最近至远的各种版本，里面都包含了每一个版本的具体信息。在Git中，HEAD表示当前版本，上一个版本就是HEAD^，上上个就是HEAD^^，类推，往上50个就写作HEAD~50。<br>例如，回退到上一个版本，可使用如下命令：<br><code>git reset --hard HEAD^</code></p><p>那如果回退了之后，又想回到原来的新版本呢？别急，有如下命令：<br><code>git reflog</code><br>它将显示我们的每一次命令，然后我们就可以看到原来版本的commit id（假设就是14331a），再使用命令<br><code>git reset --hard 14331a</code><br>就可以回来辣。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>对文件的撤销修改，需用到命令：<br><code>git checkout -- 文件名</code><br>将文件在工作区的修改全部撤销（丢弃工作区的修改），即让该文件回到最近一次git commit或者git add时的状态。<br>这种情况有两种：</p><ul><li>文件修改后，还没有提交到暂存区；</li><li>文件提交到了暂存区，但是又作了修改，现在撤销修改就是回到添加到暂存区后的状态。</li></ul><p>若文件已经提交到暂存区了呢？那就需要这个命令了：<br><code>git reset HEAD &lt;file&gt;</code><br>它可以把暂存区的修改撤销掉，重新放回工作区<br>也就是说，git reset命令既可以将暂存区的修改回退到工作区，也可以回退版本。</p><h2 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h2><p>只从工作区删除了文件，工作区就会和版本库不太一致了。如果要彻底删除文件（以test.txt为例），执行如下命令：<br><code>git rm test.txt</code><br><code>git commit -m&quot;remove test.txt&quot;</code><br>即可实现test.txt的完全删除</p><p>如果只是删除错了文件，就使用<br><code>git checkout -- test.txt</code><br>这是因为版本库里面还存在这个文件，用版本库中的版本替换工作区中的版本即可（丢弃工作区的删除）。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>在本地仓库下运行命令，可以将本地仓库与远程仓库关联起来：<br><code>git remote add origin git@github.com:账户名...</code></p><p>在创建了远程仓库，并与本地仓库关联之后，就可以将本地仓库的所有内容全部推送到全程仓库中：<br><code>git push -u origin master</code><br>第一次推送时，加上了-u参数，本地的master分支还会和远程的master分支关联起来，简化以后的推送或者拉取命令。</p><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>准备好远程库后，使用git clone可以克隆一个本地</p><h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><h3 id="本地分支管理"><a href="#本地分支管理" class="headerlink" title="本地分支管理"></a>本地分支管理</h3><p><code>git branch     创建分支命令</code><br><code>git branch -X  创建分支，-X为分支名</code><br><code>git checkout -X  切换分支命令，切换到-X分支</code><br><code>git checkout -b branchname     创建分支并立即切换过去</code><br><code>git switch branchname      切换至已有的分支</code><br><code>git switch -c dev      创建并切换至已有分支</code><br><code>git branch -d branchname       删除本地分支</code></p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>将任何分支合并到当前分支中：<br><code>git merge      分支合并</code></p><ul><li>一种简单的情况，是将master分支与dev分支直接合并，假设我们已经在master分支上了：<br><code>git merge dev</code><br>便可直接将master和dev合并了</li></ul><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p><code>git branch -d &lt;branchname&gt;</code></p><p>如果要丢弃一个没有被合并过的分支，可以通过<br><code>git branch -D &lt;branchname&gt;</code><br>来强行删除。</p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当合并的两个分支产生冲突（一般是文件内容不同）时，必须首先解决冲突。只有解决完冲突后，才可以再提交，此时合并完成。<br>而解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>有时候我们在开发中遇见了bug，就需要另开一个分支去修复bug，但是这时候，可能我们手边正在开发的工作还没有提交，因此，就需要先将当前的工作存储下来。<br><code>git stash</code><br>该命令可以将当前工作现场“存储”起来，等以后恢复现场后继续工作。<br>接下来，就可以继续新建分支修复bug了…<br>修复bug完成后，也需要合并分支，当整个工作结束后，我们需要将工作现场还原。用到如下命令：<br><code>git stash list</code><br>恢复工作现场有两种命令：<br><code>git stash apply    恢复工作现场，同时不删除stash</code><br><code>git stash pop  恢复工作现场，同时删除stash</code></p><blockquote><p>此时master分支已经修复了bug，但是其他的开发分支，比如dev中bug仍然存在。能不能直接将本次针对修复bug的提交拿到开发分支dev上呢？</p></blockquote><p>命令<br><code>git cherry-pick 提交id</code><br>可以实现复制一个特定的提交到当前分支。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><h3 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h3><p>当我们从远程库克隆时，实际上Git就自动把本地的master分支和远程的master分支对应起来了，且远程仓库的默认名称是origin。</p><p>查看远程库信息：<br><code>git remote</code><br><code>git remote -v</code></p><p>在默认情况下，origin指向的就是用户在github上的远程仓库repository。</p><h3 id="与远程库建立关联"><a href="#与远程库建立关联" class="headerlink" title="与远程库建立关联"></a>与远程库建立关联</h3><p>与github上的仓库关联：<br><code>git remote add origin 地址</code><br>与gitee上的仓库关联：<br><code>git remote set-url --add origin 地址</code><br>进行如上的操作之后，本地的.git\config文件下就会显示关联的远程仓库的信息。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>即将该分支上的所有本地提交推送到远程库。推送时，需要指定本地分支，这样Git就会把该分支推送到远程库对应的远程分支上。<br><code>git push origin &lt;branchname&gt;</code><br>将本地分支branchname推送到远程仓库origin对应的远程分支上。</p><p>常见的四种分支：</p><ul><li>master分支是主分支，因此要时刻与远程同步；</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h3 id="多人抓取分支"><a href="#多人抓取分支" class="headerlink" title="多人抓取分支"></a>多人抓取分支</h3><p>当我们提交分支到远程分支时，首先需要确保自己的代码是最新状态。因此需要git pull拉取远程代码。<br>常见的情况是，首先git pull把最新的提交从origin/dev抓下来，然后再本地合并，并解决冲突，再推送。</p><p>而为了顺利git pull，首先需要指定本地dev分支和远程origin/dev分支的链接：<br><code>git branch --set-upstream-to=origin/dev dev</code><br>接着再pull：<br><code>git pull</code><br>接下来就是手动解决冲突的时间了。</p><p>解决完冲突后，就需要推送了，使用命令<br><code>git pull origin &lt;branchname&gt;</code><br>即可推送成功。</p><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>即常说的克隆。在github上随便逛的时候，瞧中了一个项目，拿到它的地址在本地git clone一下，它就被扒取到了。</p><h2 id="Codereview"><a href="#Codereview" class="headerlink" title="Codereview"></a>Codereview</h2><p>中文可以理解为代码评审，旨在保证代码的规范性，更好地促进团队的开发工作。</p><ul><li>When？每一次代码合并（Pull Request）的时候，就是codereview的最佳时机。另外，每一次提交合并请求都需要确保代码的粒度，也就是说，不要一次性提交大量的代码，而是要修改一次提交一次、实现了一个功能模块提交一次。</li><li>How？选用一些代码托管平台，比如github、gitlab等等，借助上面的代码codereview工具也可以进行评审。</li><li>What？对代码的规范性、完整性、正确性、健壮性、可扩展性等方面进行评审。</li></ul><h2 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h2><p>即pull request。请求合并代码。<br>我们在fork一个项目，并在本地做好修改、commit之后，想要将自己的这部分贡献推送给原项目，怎么办？<br>首先需要做一下同步，git rebase或者git merge拉取其他人做出的最新改动，然后在github上创建pull request合并请求，等待维护人管理通过即可。</p><h2 id="http模式与ssh模式"><a href="#http模式与ssh模式" class="headerlink" title="http模式与ssh模式"></a>http模式与ssh模式</h2>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本协同工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教材典型算法</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/27/%E6%95%99%E6%9D%90%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/27/%E6%95%99%E6%9D%90%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的遍历算法"><a href="#树的遍历算法" class="headerlink" title="树的遍历算法"></a>树的遍历算法</h3><ol><li>先序遍历</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Preorder(BiTree T, void (*visit)(TElemType&amp; e))&#123;    if(T)    &#123;        visit(T-&gt;data); &#x2F;&#x2F; 先访问根结点        &#x2F;&#x2F; 再递归访问左子树和柚子树        Preorder(T-&gt;lchild, visit);        Preorder(T-&gt;rchild, visit);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先序、中序、后序遍历算法思路几乎完全一致，不再赘述。</p><ol><li>中序遍历的非递归描述</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 对于中序遍历一棵二叉树，第一个要访问的根结点一定是最左边的结点&#x2F;&#x2F; 因此，GoFarLeft函数的功能就是对二叉树T，寻找最左边的结点&#x2F;&#x2F; 同时，用一个栈S保存每一次的根结点，它是中序遍历的中间访问者BiTNode *GoFarLeft(BiTree T, Stack *S)&#123;    &#x2F;&#x2F; 代表当前根结点不存在了，返回空    if(!T)  return NULL;    &#x2F;&#x2F; 当前根结点有左子树，往左继续寻找    while(T-&gt;lchild)    &#123;        Push(S, T);        T &#x3D; T-&gt;lchild;    &#125;    return T;&#125;&#x2F;&#x2F; 非递归的中序遍历算法void Inorder_I(BiTree T, void (*visit)(TelemType&amp; e))&#123;    Stack *S;    t &#x3D; GoFarLeft(T, S);    &#x2F;&#x2F; 寻找最左下边的结点    &#x2F;&#x2F; 每一次循环，访问一个结点    while(t)    &#123;        visit(t-&gt;data);        &#x2F;&#x2F; 如果t有柚子树，就得继续遍历柚子树，用相同的方式        if(t-&gt;rchild)            t &#x3D; GoFarLeft(t-&gt;rchild, S);        &#x2F;&#x2F; t没有柚子树，t本来就没有左子树，则应该访问其父结点了，S中存放了结点路径        else if(!StackEmpty(S))            t &#x3D; Pop(S);        else            t &#x3D; NULL;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归。</p><ol><li>求二叉树的深度</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int Depth(BiTree T)&#123;    if(!T)  depthval &#x3D; 0;    else     &#123;        depthLeft &#x3D; Depth(T-&gt;lchild);        depthRight &#x3D; Depth(T-&gt;lchild);        depthval &#x3D; (depthLeft &gt; depthRight ? depthLeft : depthRight) + 1;    &#125;    return depthval;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求深度。</p><ol><li>建树<br>已知一棵二叉树的先序遍历和中序遍历，还原这棵二叉树。</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CrtBT(BiTree&amp; T, char pre[], char ino[], int ps, int is, int n)&#123;    if(n &#x3D;&#x3D; 0)  T &#x3D; NULL;    else     &#123;        k &#x3D; Search(ino, pre[ps]);        if(k &#x3D;&#x3D; -1) T &#x3D; NULL;        else        &#123;            T &#x3D; (BiTNode*)malloc(sizeof(BiTNode));            T-&gt;data &#x3D; pre[ps];            if(k &#x3D;&#x3D; is) T-&gt;Lchild &#x3D; NULL;            else    CrtBT(T-&gt;Lchild, pre[], ino[], ps+1, is, k - is);            if(k &#x3D;&#x3D; is+n-1) T-&gt;Rchild &#x3D; NULL;            else    CrtBT(T-&gt;Rchild, pre[], ino[], ps+1+(k-is), k+1, n-(k-is)-1);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>555</p><ol><li>二叉树按层次遍历</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Status LevelOrderTravel(BiTree T)&#123;    Queue Q;    InitQueue(Q);    if(T)   Enqueue(Q, T);    while(!QueueEmpty(Q))    &#123;        Dequeue(Q, &amp;E);        visit(E);        if(E-&gt;lchild)   EnQueue(Q, E-&gt;lchild);        if(E-&gt;rchild)   EnQueue(Q, E-&gt;rchild);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void DFSTravel(Graph G)&#123;    for(v&#x3D;0; v &lt; G.Vexnum; ++v)    &#123;        visited[v] &#x3D; false;    &#125;    for(v&#x3D;0; v &lt; G.Vexnum; ++v)    &#123;        if(!visited[v]) DFS(G, v);    &#125;&#125;void DFS(Graph G, int v)&#123;    visited[v] &#x3D; true;    printf();    for(w&#x3D;0; w &lt; G.vexnum; w++)        if(G.arcs[v][w].adj !&#x3D; 0 &amp;&amp; !visited[w])            DFS(G, w);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 求各顶点入度void FindInDegree(ALGraph G, int indegree[])&#123;    int i;    ArcNode *p;    for(i&#x3D;0; i &lt; G.vexnum; i++)    &#123;        while(p)        &#123;            indegree[p-&gt;adjvex]++;            p &#x3D; p-&gt;next;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; final[]记录当前结点是否已经求出最短路径&#x2F;&#x2F; D[]记录当前所找的源点到每一个终点的最短路径长度&#x2F;&#x2F; P[]记录路径&#x2F;&#x2F; v0表示初始单源点起点void ShortestPath_DIJ(MGraph G, int v0, int &amp;P, float &amp;D)&#123;    int i&#x3D;0,j,v,w,min,final[N];    for(v&#x3D;0; v &lt; G.vexnum; ++v)    &#123;        final[v] &#x3D; FALSE;        D[v] &#x3D; G.arcs[v0][v];        P[v] &#x3D; -1;        if(D[v] &lt; INFINITY) P[v] &#x3D; v0;        final[v0] &#x3D; TRUE;        P[v0] &#x3D; -1;    &#125;    &#x2F;&#x2F; 确定下一次的出发点    for(i&#x3D;1; i &lt; G.vexnum; i++)    &#123;        &#x2F;&#x2F; 要找到当前还未确定最小路径长度的最小值        min &#x3D; INFINITY;        for(w&#x3D;0; w &lt; G.vexnum; ++w)        if(!final[w])            if(D[w] &lt; min)            &#123;                v &#x3D; w;                min &#x3D; D[w];            &#125;    &#125;    final[v] &#x3D; TRUE;    &#x2F;&#x2F; 一旦确定了最小值，那么源点到它的最短路径也就确定了    &#x2F;&#x2F; 以这次的顶点v为起始点，进行最短路径的更新    for(w&#x3D;0; w &lt; G.vexnum; ++w)    &#123;        if(!final[w] &amp;&amp; (min+G.arcs[v][w] &lt; D[w]))        &#123;            &#x2F;&#x2F; 对满足条件的顶点，更新需要更新最短路径和最短路径长            D[w] &#x3D; min + G.arcs[v][w].adj;            P[w] &#x3D; v;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void InsertionSort(SqList &amp;L)&#123;    int i,j;    &#x2F;&#x2F; 从第二项开始排序    for(i &#x3D; 2; i &lt;&#x3D; L.length; ++i)    &#123;        &#x2F;&#x2F; 每一次排序前面的都已经排序好了        if(L.r[i].key &lt; L.r[i-1].key)        &#123;            L.r[0] &#x3D; L.r[i];    &#x2F;&#x2F; 复制为监视哨            for(j &#x3D; i-1; L.r[0].key &lt; L.r[j].key; --j)            &#123;                L.r[j+1] &#x3D; L.r[j];  &#x2F;&#x2F; 记录后移            &#125;            L.r[j+1] &#x3D; L.r[0];  &#x2F;&#x2F; 插入到正确的位置        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int Partition(SqList &amp;L, int low, int high)&#123;    KeyType pivotkey;    L.r[0] &#x3D; L.r[low];    pivotkey &#x3D; L.r[low].key;    while(low &lt; high)    &#123;        &#x2F;&#x2F; 从高位开始遍历，确保元素都大于枢轴        while(low &lt; high &amp;&amp; L.r[high].key &gt;&#x3D; pivotkey)            --high;        L.r[low] &#x3D; L.r[high];        &#x2F;&#x2F; 从地位开始遍历，确保元素都小于枢轴        while(low &lt; high &amp;&amp; L.r[low].key &lt;&#x3D; povotkey)            ++low;        L.r[high] &#x3D; L.r[low];    &#125;    L.r[low] &#x3D; L.r[0];    return low; &#x2F;&#x2F; 返回枢轴最后的位置&#125;void QSort(SqList &amp;L, int low, int high)&#123;    int pivotloc;    if(low &lt; high)    &#123;        pivotloc &#x3D; Partition(L, low, high);        QSort(L, low, pivotloc-1);        QSort(L, pivotloc+1, high);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>筛选算法：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 调整堆结构void HeapAdjust(HeapType &amp;H, int s, int m)&#123;    int j;    RedType rc;    rc &#x3D; H.r[s];    &#x2F;&#x2F; 将堆顶元素暂存下来到rc    for(j&#x3D;2*s; j &lt;&#x3D; m; j*&#x3D;2)    &#123;        &#x2F;&#x2F; 横比，j初始值指向左孩子        if(j &lt; m &amp;&amp; H.r[j].key &lt; H.r[j+1].key)            j++;        &#x2F;&#x2F; 纵比，如果右孩子比父节点小，表示该堆不需要调整        if(rc.key &gt;&#x3D; H.r[j].key)    break;        H.r[s] &#x3D; H.r[j];        s &#x3D; j;        &#x2F;&#x2F; j*&#x3D;2,表示进入下一个堆结构    &#125;    H.r[s] &#x3D; rc;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Merge(RcdType SR[], RcdType &amp;TR[], int i, int m, in t n)&#123;    for(j &#x3D; m+1, k&#x3D;i; i &lt;&#x3D; m &amp;&amp; j &lt;&#x3D; n; ++k)    &#123;        if(SR[i].key &lt; SR[i].key)            TR[k] &#x3D; SR[i++];        else            TR[k] &#x3D; SR[j++];    &#125;    while(i &lt;&#x3D; m)   TR[k++] &#x3D; SR[i++];    while(j &lt;&#x3D; n)   TR[k++] &#x3D; SR[j++];&#125;void MSort(RcdType SR[], RcdType &amp;TR[], int s, int t)&#123;    if(s&#x3D;&#x3D;t)    TR[s] &#x3D; SR[s];    else    &#123;        m &#x3D; (s+t)&#x2F;2;        MSort(SR, TR2, s, m);        MSort(SR, TR2, m+1, t);        Merge(TR2, TR, s, m, t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h3><p>线性表是n个类型相同数据元素的有限序列，通常记作（a1, a2, a3,…, an）。</p><p>特点：</p><ul><li>必存在一个唯一的“第一元素”</li><li>必存在一个唯一的“最后元素”</li><li>除最后一个元素外，均有唯一的后继</li><li>除第一个元素外，均有唯一的前驱</li></ul><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct &#123;    ElementType *elem;  &#x2F;&#x2F; 存储空间基地址    int length; &#x2F;&#x2F; 当前长度    int listSize;   &#x2F;&#x2F; 当前分配的存储容量&#125; SqList;   &#x2F;&#x2F; 顺序表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>线性表的销毁：每一个结点都释放掉，该链表完全不可以再次使用；</li><li>线性表的清空：除头结点外的所有结点释放掉，该链表还可以继续使用。</li></ul><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>结构特点：单链表的逻辑次序和物理次序不一定相同<br>在链式存储结构中以第一个结点的存储地址作为线性表的基地址，通常称它为头指针。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：插入和删除操作不需要移动数据了<br>缺点：指针占用了存储空间，增加了内存负担；另外只能顺序查找。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单链表的最后一个结点的指针域（尾指针）指向了头指针，构成循环，称作循环链表。<br>为了方便地在循环链表中进行头插、尾插，设置一个指向表尾的尾指针。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>单链表的每一个结点再增设一个指针域，用于指向该结点的前驱，即每一个结点有一个数据域和俩指针域。</p><h2 id="一元多项式的表示"><a href="#一元多项式的表示" class="headerlink" title="一元多项式的表示"></a>一元多项式的表示</h2><h3 id="用顺序表存储"><a href="#用顺序表存储" class="headerlink" title="用顺序表存储"></a>用顺序表存储</h3><p>可能造成大量空间浪费</p><h3 id="用链式表存储"><a href="#用链式表存储" class="headerlink" title="用链式表存储"></a>用链式表存储</h3><p>一般选用链式表存储，更加节省内存</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/24/%E6%9F%A5%E6%89%BE/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/24/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>查找表：由同一类型的数据元素（或记录）构成的集合。</li><li>静态查找表：仅作查询和检索操作的查找表。</li><li>动态查找表：在查找时也可以进行插入、删除、修改操作。</li><li>主关键字：可以唯一的识别一个记录的数据项（字段）。</li><li>次关键字：关联若干项记录的数据项（字段）。</li><li>查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（记录）的过程。</li></ul><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>教材中，约定如下宏定义：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define EQ(a, b)((a) &#x3D;&#x3D; (b))#define LT(a, b)((a) &lt; (b))#define LQ(a, b)((a) &lt;&#x3D; (b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/23/%E5%9B%BE/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/23/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><ul><li>有向图</li><li><p>无向图</p></li><li><p>邻接点（边的两个顶点互为邻接点）</p></li><li><p>关联边（一条边的两个顶点关联这条边）</p></li><li><p>路径</p></li><li>回路</li><li>简单路径</li><li><p>简单回路</p></li><li><p>连通图（任意两个顶点之间都存在路径）</p></li><li>强连通图（对有向图，任意两个顶点之间都存在路径）</li><li>子图</li><li>连通分量（无向图中的极大联通子图）</li><li>强连通分量（有向图中的极大强连通子图）</li><li>网络（边带权图）</li><li>生成树（连通图的一个包含其所有顶点的子图是一棵树，这棵树就是生成树）</li></ul><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>一张图，要存储的信息至少有两方面：</p><ul><li>顶点的数据信息</li><li>顶点间的关系信息</li></ul><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>图的邻接矩阵是一个n阶矩阵，物理上是一个二维数组。<br>对无向图而言，</p><ul><li>其邻接矩阵是一个对称矩阵，且对角线元素均为零；</li><li>图的总度数就是矩阵中非零元素个数</li><li>图的边数就是非零元素个数的一半</li></ul><p>对有向图而言：</p><ul><li>第i个顶点的入度就是第i列非零元素个数</li><li>第i个顶点的出度就是第i行非零元素个数</li></ul><h4 id="类型实现"><a href="#类型实现" class="headerlink" title="类型实现"></a>类型实现</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct ArcCell &#123;    VRType agj;    Info *info; &#x2F;&#x2F; 存放相关信息的指针&#125; ArcCell, AdjMatrix[M][N];typedef struct &#123;    VertexType vexs[MAX];   &#x2F;&#x2F; 顶点信息    AdjMatrix arcs; &#x2F;&#x2F; 存储弧的信息    int vexnum, arcnum; &#x2F;&#x2F; 存储顶点数，弧数    GraphKind kind; &#x2F;&#x2F; 存储图的种类&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>空间复杂度比较高，为O(n^2)<br>插入边或弧都比较容易，但是插入顶点不容易</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表定义分为两部分：边链表和顶点表</p><ul><li>边链表：与顶点V关联的所有边组成一个链表，称为顶点V的边链表</li><li>顶点表：用顺序存储方式存储图的顶点表V1，V2，…，Vn，表示每一个顶点的结构。</li></ul><h4 id="邻接表的类型实现"><a href="#邻接表的类型实现" class="headerlink" title="邻接表的类型实现"></a>邻接表的类型实现</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct ArcNode &#123;    &#x2F;&#x2F; 边表的存储类型    int adjvex; &#x2F;&#x2F; 该弧所指向的顶点的位置    VRType adj;    struct ArcNode *nextarc;    &#x2F;&#x2F; 指向下一条弧的指针    InfoType *info; &#x2F;&#x2F; 该弧相关信息的指针&#125; ArcNode;typedef struct vnode &#123;  &#x2F;&#x2F; 顶点表的存储类型    vertexxtype data;   &#x2F;&#x2F; 存储该顶点的信息    ArcNode *firstArc;  &#x2F;&#x2F; 指向第一条依附于该顶点的弧，其实是一段边链表&#125; vNode, adjList[M];typedef struct &#123;    &#x2F;&#x2F; 图的邻接表存储类型    adjList vertices;   &#x2F;&#x2F; 邻接表的顶点表    int vexNum, arcNum;    int kind;   &#x2F;&#x2F; 存储图的种类标志&#125; ALGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><blockquote><blockquote><blockquote><p>概念————从图的某一个顶点出发，访问图中的所有顶点，且每一个顶点仅访问一次。一般可分为两种方法：广度优先搜索、深度优先搜索。</p></blockquote></blockquote></blockquote><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h4><ol><li>首先访问图中某一个顶点Vi，以该顶点为出发点；</li><li>任选一个与该顶点Vi【邻接】的【未被访问】的顶点Vj，访问之；</li><li>以Vj为新的出发点继续进行深度优先搜索，直到图中所有和Vi有路径的顶点均被访问到。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="对非连通图进行深度优先遍历"><a href="#对非连通图进行深度优先遍历" class="headerlink" title="对非连通图进行深度优先遍历"></a>对非连通图进行深度优先遍历</h4><p>首先将图中每一个顶点的访问标志设为FAlSE，之后搜索图中每一个顶点，如果未被访问，就以之为起始点进行深度优先搜索；否则继续检查下一顶点。</p><h4 id="深度优先搜索的应用"><a href="#深度优先搜索的应用" class="headerlink" title="深度优先搜索的应用"></a>深度优先搜索的应用</h4><ul><li>求深度优先生成树</li><li>判断图是否连通</li><li>求图的连通分量</li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ol><li>首先访问图中某一个指定的出发点Vi</li><li>然后依次访问Vi中的所有邻接点Vi1，Vi2，…，Vit；</li><li>再依次以这些邻接点为顶点，访问各个顶点未被访问的邻接点，以此类推，直到图中所有顶点均被访问为止。</li></ol><h4 id="广度优先代码实现"><a href="#广度优先代码实现" class="headerlink" title="广度优先代码实现"></a>广度优先代码实现</h4><h4 id="广度优先搜索的应用"><a href="#广度优先搜索的应用" class="headerlink" title="广度优先搜索的应用"></a>广度优先搜索的应用</h4><ul><li>求广度优先生成树</li><li>判断图是否连通</li><li>求图的连通分量</li></ul><h2 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h2><h3 id="无向图和有向图的连通性"><a href="#无向图和有向图的连通性" class="headerlink" title="无向图和有向图的连通性"></a>无向图和有向图的连通性</h3><p>通过广度优先搜索和深度优先搜索，都可以求出一张无向图的所有连通分量</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>对于网而言，各边权值（边长）总和最小的生成树称作最小生成树。<br>下面介绍几个求最小生成树的算法。</p><h4 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h4><p>从边入手，算法思路：</p><ol><li>算法开始时，设置U，T，U中存放初始顶点s，T为空集；</li><li>找到与初始顶点s邻接的顶点，且连通它们的边是最短的，将该顶点入集合U，边入集合T；</li><li>反复执行2，直到U=V时，算法终止。</li></ol><h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><ol><li>从图中取最短边e，如果e所关联的两个顶点不在T的同一个连通分量中，则将该边加入T；</li><li>从图中删除边e；</li><li>重复1和2，直到T中有n-1条边。</li></ol><h2 id="有向无环图的应用"><a href="#有向无环图的应用" class="headerlink" title="有向无环图的应用"></a>有向无环图的应用</h2><p>无环有向图被称作无环图，简称DAG图。<br>某些子工程必须在另外的一些子工程完成之后才能开始，对于整个工程与系统，人们主要关心的两方面问题：</p><ul><li>工程能否顺利进行 ———— &gt; 拓扑排序</li><li>完成整个工程所必须的最短时间 ———— &gt; 关键路径</li></ul><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>顶点活动网（AOV网）：将顶点表示活动，边表示活动之间的关系的网称为顶点活动网。</li><li>拓扑序列</li></ul><h4 id="拓扑排序特点"><a href="#拓扑排序特点" class="headerlink" title="拓扑排序特点"></a>拓扑排序特点</h4><ul><li>一个有向图的拓扑序列不一定唯一</li><li>通过构造拓扑序列，可判断AOV网是否存在环</li><li>有向无环图一定存在拓扑序列</li></ul><h4 id="拓扑排序基本思想"><a href="#拓扑排序基本思想" class="headerlink" title="拓扑排序基本思想"></a>拓扑排序基本思想</h4><ol><li>从有向图中选择一个入度为零的顶点输出</li><li>从图中删除该顶点及其所有出边</li><li>重复执行1和2，直到全部顶点均已输出，或者图中剩余顶点的入度均不为零（此时说明图中有回路）</li></ol><h4 id="拓扑排序算法概要"><a href="#拓扑排序算法概要" class="headerlink" title="拓扑排序算法概要"></a>拓扑排序算法概要</h4><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h3 id="关键路径相关概念"><a href="#关键路径相关概念" class="headerlink" title="关键路径相关概念"></a>关键路径相关概念</h3><ol><li>事件vi的最早发生时间<br>从源点v1到vi的最长路径长度，记作ve(i);</li><li>事件vk的最迟发生时间<br>即vn的最早发生时间ve(n)减去vk到vn的最长路径长度，记作vl(k)</li><li>活动<vi, vj>的最早开始时间，是vi的最早开始时间,<br>最晚开始时间，是vj的最迟开始时间减去<vi, vj>的持续时间，记作el(i)。</li></ol><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><h4 id="Dijkstra算法思想"><a href="#Dijkstra算法思想" class="headerlink" title="Dijkstra算法思想"></a>Dijkstra算法思想</h4><ul><li>按路径长度的递增次序，逐步产生最短路径</li><li>首先求出离源点路径长度最短的点，再参照它求出离源点次短的点，以此类推</li><li>注意：权值不能为负，否则该算法失效</li></ul><h4 id="Dijkstra算法概要"><a href="#Dijkstra算法概要" class="headerlink" title="Dijkstra算法概要"></a>Dijkstra算法概要</h4><ol><li>引入辅助数组D[]，D[i]表示当前找到的源点到每一个终点i的最短路径长度，<br>引入辅助数组final[]，final[i]=1表示顶点i的最短路径已求<br>出，初始状态下final[v0]置为1，其他置为0;</li><li>选择D[]中路径最小值的顶点v（final[v]必须为0），v就是当前求得的一条从v出发的最短路径的终点，并修改final[v]=1;</li><li>修改未求出最短路径的顶点的最短路径长度，对于顶点w，若<br>D[v]+G.arcs[v][w] &lt; D[w],<br>则修改 D[w]=D[v]+G.arcs[v][w],<br>同时修改P[w]=v;</li><li>重复操作2、3 n-1次，求得递增序列。</li></ol><h4 id="Dijkstra算法分析"><a href="#Dijkstra算法分析" class="headerlink" title="Dijkstra算法分析"></a>Dijkstra算法分析</h4><p>时间复杂度体现在修改距离值和最小值，为O(n^2),<br>空间复杂度体现在两个辅助数组，为O(n)。</p><h3 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h3><p>时间复杂度体现在三重循环，为O(n^3),<br>空间复杂度体现在使用了二维数组，为O(n^2)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/22/%E6%A0%91/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/22/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树的概述"><a href="#树的概述" class="headerlink" title="树的概述"></a>树的概述</h2><p>树是一种递归定义的数据结构</p><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><ul><li>节点的度：某一个节点的分支个数</li><li>树的度：树中所有节点的度的最大值</li><li>叶子结点：度为零的结点</li><li>分支结点：度大于零的结点</li></ul><h2 id="树的重要性质"><a href="#树的重要性质" class="headerlink" title="树的重要性质"></a>树的重要性质</h2><ul><li>性质1：二叉树的第i层上至多有2^i-1个节点</li><li>性质2：深度为k的二叉树上至多含2^i-1个节点</li><li>性质3：具有n个结点的完全二叉树的深度为[log2n]+1</li><li>性质4：对完全二叉树而言，2i &gt; n，则该结点没有左孩子；若2i &lt; n,则该结点没有右孩子。</li></ul><p>两类特殊的二叉树：</p><ul><li>满二叉树，每一层都满了</li><li>完全二叉树，树中所含的n个结点和满二叉树中编号为1至n的结点一一对应</li></ul><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>即用数组存储，虽然线性结构简单，但是很容易造成大量空间浪费</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>在基础链表的基础上，增加了一个指针域，即两个指针域，一个指向左孩子（左子树的根结点），另一个指向右孩子（柚子树的根结点）</p><h4 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h4><p>在二叉链表基础上，增加了一个指针域（指向其父结点parent）</p><h4 id="双亲链表"><a href="#双亲链表" class="headerlink" title="双亲链表"></a>双亲链表</h4><p>每一个结点由三部分组成，data（存放数据）、parent（指向父节点）、LRTag（表示该结点是左孩子还是右孩子）</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>就二叉树而言，可以有三条搜索路径：</p><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>按层次遍历</li></ul><p>二叉树的遍历算法的应用：</p><ul><li>统计二叉树中叶子节点的个数<br>每一次遍历一个结点时，判断其是否为叶子即可，另设一个计数器变量，存储当前叶子数量。</li><li>求二叉树的深度<br>某个根结点的二叉树的深度等于左子树和柚子树深度较大者加一，以此递归即可。需要用到后序遍历。</li><li>复制二叉树<br>基本操作就是不断生成新的结点，但是结点数据和原来一样。需要用到后序遍历（先生成两个分支结点，最后生成根结点）。</li><li>建立二叉树的存储结构<br>需要用到先序遍历。先创建根结点，然后在根结点的两边不断地添加分支结点（即构建左子树和柚子树）。</li></ul><blockquote><blockquote><blockquote><p>由二叉树的先序序列和中序序列建树<br>先序序列得到根结点，代入中序序列得到左子树和柚子树，不断重复这个过程（递归）可以还原整个二叉树。</p></blockquote></blockquote></blockquote><ul><li>二叉树的层次遍历<br>即自上而下依次遍历结点；<br>用到【队列】，使用队列存储每一次将要访问的结点，如果其有左孩子，就让其左孩子入队；如有右孩子，就让右孩子入队。<br>本质上，这就是图的深度优先算法（BFS）。</li></ul><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在原二叉树的基础上，给结点增加指向某种遍历下的前驱和后续指针作为线索，行成一棵新的二叉树。</p><p>当左子树为空时，就存储某种遍历下的前驱；<br>当柚子树为空时，就存储某种遍历下的后继。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct BiThrNode &#123;    TElemType data;    struct BiThrNode *lchild, *rchild;    PointerThr LTag, RTag;&#125; BiThrNode, *BiThrTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当当前结点没有孩子时，对应的Tag设为1，并将指针域设为前驱（左孩子）或后继（右孩子）；<br>有孩子时，对应的Tag设为0，存储的就是正常的左右孩子。</p><h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>每一个结点存储的不仅有数据data，还有其父节点parent的位置</p><h3 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h3><p>每一个结点存放数据data，父节点下标，和一条由其孩子组成的链表</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct CTNode &#123;    int child;    struct CTNode *next;&#125; *ChildPtr;typedef struct &#123;    Elem data;    ChildPtr firstChild;&#125; CTBox;typedef struct &#123;    CTBox nodes[MAX_TREE_SIZE];    int n,r;&#125; CTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="左孩子右兄弟表示法"><a href="#左孩子右兄弟表示法" class="headerlink" title="左孩子右兄弟表示法"></a>左孩子右兄弟表示法</h3><p>对每一个结点，左结点存放原树形结构的左孩子结点，右结点存放原树形结构的同一层的兄弟结点。</p><h2 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h2><p>森林的遍历有两种：</p><ul><li>先序遍历（从左向右依次对森林中的每一棵树进行先序遍历）</li><li>中序遍历（从左向右依次对森林中的每一棵树进行后序遍历）</li></ul><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="最优树"><a href="#最优树" class="headerlink" title="最优树"></a>最优树</h3><ul><li>结点的路径长度：从根结点到该结点的路径上分支的数目</li><li>树的路径长度：树中每一个结点的路径长度之和</li><li>树的帶权路径长度：树中所有叶子结点的帶权路径长度之和</li></ul><h3 id="最优树的构造————哈夫曼算法"><a href="#最优树的构造————哈夫曼算法" class="headerlink" title="最优树的构造————哈夫曼算法"></a>最优树的构造————哈夫曼算法</h3><p>算法思想：</p><ol><li>根据给定的n个权值，构造n棵二叉树的集合，其中每一棵二叉树左右子树均为空树；</li><li>在F中选取其根结点的权值为最小的两棵二叉树，分别作为左右子树构造一棵新的二叉树，并将根结点的权值置为左右子树根结点权值之和；</li><li>从集合F中删去这两棵树，加入新树；</li><li>重复2、3两步，直至F中只含有一棵树。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/21/%E6%8E%92%E5%BA%8F/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/21/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本节对排序的介绍、复习，均以升序排序为例进行说明。</p><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><p>稳定的排序：排序前后含相同关键字的记录相对位置保持不变<br>不稳定的排序：排序前后含相同关键字的记录相对位置变化</p><h3 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h3><p>内部排序，只使用计算机内存存放待排序记录。<br>外部排序，排序记录不能同时存放在计算机内存中，需要借助计算机外存。</p><h3 id="排序方法效率分析"><a href="#排序方法效率分析" class="headerlink" title="排序方法效率分析"></a>排序方法效率分析</h3><p>三个指标：</p><ol><li>时间复杂度（比较次数和移动次数）</li><li>空间复杂度（附加存储空间）</li><li>稳定性</li></ol><h2 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h2><p>以直接插入排序为例进行说明。</p><h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><ul><li>第一个记录看作有序</li><li>从第二个记录开始，按关键字大小将每一个记录插入到已排好序的序列中</li><li>一直进行到第n个记录</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>每次排序从第二个记录开始</li><li>直接插入排序第i趟后，前i+1个记录一定有序</li></ul><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>当原序列呈正序排列时，最省时间</li><li><p>当原序列呈反序排列时，最费时间</p></li><li><p>最好情况下，比较次数为 n-1，无需移动；</p></li><li><p>最坏情况下，比较次数、移动次数均为 o(n^2)</p></li><li><p>直接插入排序是稳定的排序方法</p></li></ul><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>思想与直接插入排序类似，只不过，在查找插入位置时，使用了二分思想。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>本质上也是一种插入排序，只不过需要多次进行插入排序。</p><ul><li>需要确定增量d，然后每一次以不同的增量进行插入排序，直至最后一次排序的增量减为1，此时就是插入排序。</li><li>完成增量为d的排序后，序列以d为步长呈现有序特征。</li></ul><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p>冒泡排序一趟后，最大元素将位于它最终的位置上，即沉底（位于最后），以此类推。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是对冒泡排序的改进。每次会找一个记录的关键字作为“枢轴”，比它小的位于其左侧，比它大的位于其右侧，使得排序一趟后，无序序列将被分为两个部分。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>分治思想，在一段序列上快速排序时，首先选定枢轴量，然后设置左右双指针，分别依次从最右、从最左开始，找出右边小于枢轴量的数，与枢轴量互换；找出左边大于枢轴量的数，与枢轴量互换；如此循环直至左指针不小于右指针。</p><h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><p>快速排序是一种不稳定的排序方法。<br>最好情况下时间复杂度为O(nlogn)，最坏情况下退化为冒泡排序，为O(n^2)<br>从空间复杂度看，快速排序是一个递归过程，因此需要一个栈的附加空间，其平均深度为O(logn)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dominant Character</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/17/Dominant-Character/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/17/Dominant-Character/</url>
      
        <content type="html"><![CDATA[<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="https://codeforces.com/contest/1605">https://codeforces.com/contest/1605</a></p><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>给定一个仅由a，b，c组成的字符串，找出这样的最小长度的子串：</p><ul><li>子串长度至少为2</li><li>子串中a的个数严格大于b的个数和c的个数</li></ul><p>并输出该最小长度。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先我们容易想到，要找出这样的字符串，无非就需要找出两个a之间的b、c的个数是否满足上述条件。因此，需要开数组存储b、c的个数：<br>b[i]表示字符串中第i号位置及其以前的b的个数总数，c[i]类似。</p><p>思路很直接，但是字符串中a的位置可能很多，总不可能任意两个都来验证一遍吧。下面就是关键了：<br>仔细分析后，可以发现，如果有这样的子串，那么子串内部的a的个数至多为3，至少为2。</p><blockquote><p>以四个a为例来简单证明：<br>有满足条件的子串，形如 a…a…a…a，约定1、2、3号空位，B为b的个数，C为c的个数，<br>B_1+B_2+B_3 &lt; 4, C_1+C_2+C_3 &lt; 4 这俩条件必须成立<br>而B_1&gt;1, C_1&gt;1; B_2&gt;1, C_2&gt;1; B_3&gt;1, C_3&gt;1这三组条件中每组至少有一个成立，显然与上一个条件矛盾了</p></blockquote><p>也就是说，我们只需要验证相邻两个a之间、相隔一个a的两个a之间即可，即可以存储当前a的位序和上一个a、上上个a的位序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define N 1000005using namespace std;int b[N], c[N];char str[N];int t, n;int seekString()&#123;    &#x2F;&#x2F; 约定：i为当前a位置，la为上一个a位置，lla为上上个a位置    int la &#x3D; 0, lla &#x3D; 0;    int res &#x3D; -1;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        if (str[i] &#x3D;&#x3D; &#39;a&#39;)        &#123;            if (la !&#x3D; 0 &amp;&amp; b[i] - b[la] &lt; 2 &amp;&amp; c[i] - c[la] &lt; 2 &amp;&amp; (res &#x3D;&#x3D; -1 || res &gt; i - la +1))            &#123;                res &#x3D; i - la + 1;            &#125;            if (lla !&#x3D; 0 &amp;&amp; b[i] - b[lla] &lt; 3 &amp;&amp; c[i] - c[lla] &lt; 3 &amp;&amp; (res &#x3D;&#x3D; -1 || res &gt; i - lla + 1))            &#123;                res &#x3D; i - lla + 1;             &#125;            &#x2F;&#x2F; 位置更新            lla &#x3D; la;            la &#x3D; i;        &#125;    &#125;    return res;&#125;int main()&#123;    cin &gt;&gt; t;    for (int i &#x3D; 1; i &lt;&#x3D; t; i++)    &#123;        cin &gt;&gt; n;        scanf(&quot;%s&quot;, str + 1);        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)        &#123;            b[j] &#x3D; b[j - 1] + (str[j] &#x3D;&#x3D; &#39;b&#39;);            c[j] &#x3D; c[j - 1] + (str[j] &#x3D;&#x3D; &#39;c&#39;);        &#125;        cout &lt;&lt; seekString() &lt;&lt; endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swing组件</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/14/Swing%E7%BB%84%E4%BB%B6/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/14/Swing%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h3 id="普通按钮"><a href="#普通按钮" class="headerlink" title="普通按钮"></a>普通按钮</h3><p>构造方法：<br><code>public JButton();</code><br><code>public JButton(String text);</code></p><h3 id="切换按钮"><a href="#切换按钮" class="headerlink" title="切换按钮"></a>切换按钮</h3><ul><li>切换按钮有两种状态，即选中状态和未选中状态。</li><li>通过isSelected()方法可以获知当前按钮状态。<br>构造方法：<br>JToggleButton(String text, boolean selected);</li></ul><h3 id="单选按钮与多选按钮"><a href="#单选按钮与多选按钮" class="headerlink" title="单选按钮与多选按钮"></a>单选按钮与多选按钮</h3><p>单选按钮JRadioButton<br>多选按钮JCheckButton</p><h2 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h2><p>组合框是一个下拉式菜单，有两种形式：不可编辑与可编辑式。常见方法有：<br>JComboBox();<br>JComboBox(object[] items);<br>public void addItem(Object anObject);<br>public void removeItem(Object anObject);</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>可供用户进行一系列的选择。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> listData<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">&#125;</span><span class="token class-name">JList</span> j1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JList</span><span class="token punctuation">(</span>listData<span class="token class-name">Vector</span> listData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MenuDemo</span> <span class="token keyword">extends</span> <span class="token class-name">JFrame</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">JMenuBar</span> menuBar<span class="token punctuation">;</span>   <span class="token comment">// 菜单栏组件</span>    <span class="token class-name">JMenu</span> menu<span class="token punctuation">,</span> submenu<span class="token punctuation">;</span>    <span class="token comment">// 一级菜单组件</span>    <span class="token class-name">JMenuItem</span> menuItem<span class="token punctuation">;</span>     <span class="token comment">// 菜单子项组件</span>    <span class="token class-name">JTextField</span> tf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MenuDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"Menu Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        menuBar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JMenuBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setJMenuBar</span><span class="token punctuation">(</span>menuBar<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        建立File菜单</span>        menu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JMenu</span><span class="token punctuation">(</span><span class="token string">"File"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        menu<span class="token punctuation">.</span><span class="token function">setMnemonic</span><span class="token punctuation">(</span><span class="token class-name">KeyEvent</span><span class="token punctuation">.</span>VK_F<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置快捷键</span>        menuBar<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>menu<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将File菜单放到菜单栏上</span><span class="token comment">//        设置File中的菜单子项</span>        menuItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JMenuItem</span><span class="token punctuation">(</span><span class="token string">"Open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem<span class="token punctuation">.</span><span class="token function">setMnemonic</span><span class="token punctuation">(</span><span class="token class-name">KeyEvent</span><span class="token punctuation">.</span>VK_O<span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem<span class="token punctuation">.</span><span class="token function">setAccelerator</span><span class="token punctuation">(</span><span class="token class-name">KeyStroke</span><span class="token punctuation">.</span><span class="token function">getKeyStroke</span><span class="token punctuation">(</span><span class="token class-name">KeyEvent</span><span class="token punctuation">.</span>VK_O<span class="token punctuation">,</span> <span class="token class-name">ActionEvent</span><span class="token punctuation">.</span>ALT_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 注册事件监听器</span>        menu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>menuItem<span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JMenuItem</span><span class="token punctuation">(</span><span class="token string">"Save"</span><span class="token punctuation">,</span> <span class="token class-name">KeyEvent</span><span class="token punctuation">.</span>VK_S<span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 注册事件监听器</span>        menu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>menuItem<span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JMenuItem</span><span class="token punctuation">(</span><span class="token string">"Close"</span><span class="token punctuation">,</span> <span class="token class-name">KeyEvent</span><span class="token punctuation">.</span>VK_C<span class="token punctuation">)</span><span class="token punctuation">;</span>        menuItem<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 注册事件监听器</span>        menu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>menuItem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tf<span class="token punctuation">,</span> <span class="token class-name">BorderLayout</span><span class="token punctuation">.</span>SOUTH<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span><span class="token class-name">JFrame</span><span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">JMenuItem</span> item <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JMenuItem</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tf<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getActionCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MenuDemo</span> menuDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MenuDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的图形用户界面设计</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/14/Java%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/14/Java%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="AWT和Swing"><a href="#AWT和Swing" class="headerlink" title="AWT和Swing"></a>AWT和Swing</h2><h3 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h3><p>重量级控件，实际上是在利用操作系统所提供的图形库。</p><h3 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h3><p>轻量级控件，用纯粹的Java代码实现的。</p><h3 id="AWT与Swing的区别"><a href="#AWT与Swing的区别" class="headerlink" title="AWT与Swing的区别"></a>AWT与Swing的区别</h3><p>AWT是基于本地方法的C/C++程序，而Swing是基于AWT的Java程序；<br>Swing组件在实现时不包含任何本地代码。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>提到容器，首先就需要提到一个很重要的概念————组件。组件可以分为</p><ul><li>基本组件</li><li>容器组件<ul><li>顶层容器</li><li>中间容器</li></ul></li></ul><h3 id="顶层容器"><a href="#顶层容器" class="headerlink" title="顶层容器"></a>顶层容器</h3><p>指可以独立使用的容器，包括JFrame（独立窗口，带标题和控制按钮），JDialog（对话框），JWindow（独立窗口，不带标题行和控制按钮）。</p><h3 id="内容窗格"><a href="#内容窗格" class="headerlink" title="内容窗格"></a>内容窗格</h3><p>每一个顶层容器都有一个内容窗格。将组件放入内容窗格有两种方法：</p><ol><li>通过顶层容器的getContentPane()方法获取默认的内容窗格，然后向其中添加组件。</li><li>创建新的内容窗格取代顶层容器默认的内容窗格。</li></ol><h3 id="面板（panel）"><a href="#面板（panel）" class="headerlink" title="面板（panel）"></a>面板（panel）</h3><p>面板JPane属于中间容器，不能独立存在但可以嵌套。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>容器中放置组件，而组件的布局（位置和大小）通常由布局管理器负责安排。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取JFrame容器默认的内容窗格</span><span class="token class-name">Container</span> contentPane <span class="token operator">=</span> frame<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 为默认内容窗格设置FlowLayout布局管理器</span>contentPane<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FlowLayout</span><span class="token punctuation">(</span><span class="token class-name">FlowLayout</span><span class="token punctuation">.</span>LEFT<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="FlowLayout布局管理器"><a href="#FlowLayout布局管理器" class="headerlink" title="FlowLayout布局管理器"></a>FlowLayout布局管理器</h4><p>组件逐个放置，一行放满另起一行。</p><h4 id="BorderLayout布局管理器"><a href="#BorderLayout布局管理器" class="headerlink" title="BorderLayout布局管理器"></a>BorderLayout布局管理器</h4><p>容器被划分为North，South，West，East，Center五个区域，每一个区域都可以加入一个组件。</p><p>构造方法：<br><code>public BorderLayout(int hgap, int vgap);</code></p><h4 id="GridLayout布局管理器"><a href="#GridLayout布局管理器" class="headerlink" title="GridLayout布局管理器"></a>GridLayout布局管理器</h4><p>容器空间被划分为若干行×若干列的网格，组件依次放入其中。</p><p>构造方法：<br><code>public GridLayout(int rows, int cols, int hgap, int vgap);</code></p><h4 id="CardLayout布局管理器"><a href="#CardLayout布局管理器" class="headerlink" title="CardLayout布局管理器"></a>CardLayout布局管理器</h4><p>将容器中的组件看作一些列卡片，卡片的顺序由组件在容器中放置的顺序决定，每一次只能从这些卡片中选择一张来显示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Container</span> parent<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token class-name">Container</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token class-name">Container</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token class-name">Container</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">last</span><span class="token punctuation">(</span><span class="token class-name">Container</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BoxLayout布局管理器"><a href="#BoxLayout布局管理器" class="headerlink" title="BoxLayout布局管理器"></a>BoxLayout布局管理器</h4><p>构造方法：<br><code>public BoxLayout(Container target, int axis);</code></p><p>axis指明组件的排列方向。BoxLayout.X_AXIS，BoxLayout.Y_AXIS分别表示水平方向排列和垂直方向排列。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>每个事件发生时，该事件都用一个事件对象来表示，而事件对象都有对应的事件类。</p><p>每一类事件还对应一个监听程序接口，规定了接收并处理该类事件的方法规范。</p><p>事件源：产生事件的组件就是事件源。<br>事件监听器类：检查事件是否发生，如果发生就激活事件处理器并且进行处理的类。<br>事件监听器类必须实现事件监听器接口或者继承事件监听器适配器类。<br>前者定义了处理事件必须实现的方法；后者是对事件监听器接口的简单实现。</p><h3 id="事件监听器的注册"><a href="#事件监听器的注册" class="headerlink" title="事件监听器的注册"></a>事件监听器的注册</h3><p>在事件源上注册事件监听器，以在事件被激活时事件处理器进行相应的处理。</p><p>事件监听器类必须包括一下两部分内容：</p><ul><li>类的声明中指定要实现的监听器接口名</li><li><p>实现监听器接口中的事件处理方法</p><p>然后，在一个或者多个组件上可以进行监听器类实例的注册<br><code>组件对象.addXXXListener(MyListener对象);</code></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ActionEventDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">JFrame</span> frame <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"ActionEvent Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        事件源是一个按钮</span>        <span class="token class-name">JButton</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JButton</span><span class="token punctuation">(</span><span class="token string">"Press me"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        注册事件监听器</span>        b<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ButtonHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token class-name">BorderLayout</span><span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 事件监听器类</span><span class="token keyword">class</span> <span class="token class-name">ButtonHandler</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">&#123;</span><span class="token comment">//    事件处理器，出现ActionEvent事件时（接收事件），该方法被调用</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>单击鼠标事件监听器类（实现监听器类）<br>public class MouseClickHandler implements MouseListener {<br>  public void mouseClicked(MouseEvent e) {<pre><code>  //...</code></pre>  }<br>  // 其他方法，仍然需要给出实现<br>  public void mousePressed(MouseEvent e) {}<br>  // …<br>}</li><li>单击鼠标事件监听器类（继承适配器）<br>class MouseClickHandler1 extends MouseAdapter {<br>  public void mouseClicked(MouseEvent e) {<pre><code>  // 处理代码...</code></pre>  }<br>}</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络功能</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/12/Java%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/12/Java%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="概述网络"><a href="#概述网络" class="headerlink" title="概述网络"></a>概述网络</h2><h3 id="ISO-OSI网络参考模型"><a href="#ISO-OSI网络参考模型" class="headerlink" title="ISO/OSI网络参考模型"></a>ISO/OSI网络参考模型</h3><p>分为7层。</p><h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h3><p>模型分为五个层次：</p><ul><li>应用层</li><li>传输层 传输层协议包括TCP和UDP</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>一些基本概念：</p><ul><li>IP地址</li><li>端口号</li><li>套接字</li></ul><h2 id="使用InetAddress"><a href="#使用InetAddress" class="headerlink" title="使用InetAddress"></a>使用InetAddress</h2><p>类InetAddress是Java的IP地址封装类，通常用它提供的静态方法来获取。<br><code>public static InetAddress getLocalHost();</code></p><h2 id="统一资源定位器"><a href="#统一资源定位器" class="headerlink" title="统一资源定位器"></a>统一资源定位器</h2><h2 id="Socket接口"><a href="#Socket接口" class="headerlink" title="Socket接口"></a>Socket接口</h2><p>Socket类是基于TCP协议实现网络通信的类，有客户端Socket类和服务端ServerSocket类</p><p>通信的一般步骤为：</p><ul><li>先在服务端生成一个ServerSocket实例对象，通过accept方法随时监听客户端的连接请求；</li><li>客户端在需要连接时，相应地生成一个Socket实例对象，并发出连接请求；</li><li>服务端通过accept方法接收客户端请求后，开启一个接口与之连接，并生成I/O数据流；</li><li>客户端和服务端的通信通过一对InputStream和OutputStream进行。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token class-name">String</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Socket</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 接收并返回该连接的Socket对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/12/%E7%BA%BF%E7%A8%8B/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/12/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h2><p>进程一般是对操作系统而言的；线程一般是对某程序而言的。<br>比如，打开word的同时打开outlook接收邮件，我们说这是两个进程；而打开outlook收取新邮件的同时查看已下载的邮件，我们就说这是两个进程。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Java的线程是通过类Thread来实现的，生成一个Thread类的对象之后，就产生了一个线程；Thread类对象内部的run()方法会执行代码，被称为线程体。</p><p>新建—就绪—运行—阻塞—死亡</p><ul><li>新建状态：使用new关键字创建一个Thread线程对象，此时线程已有自己的内存空间，但是并不是活着的。</li><li>就绪状态：调用start()方法</li><li>运行状态：执行run()方法</li><li>阻塞状态：调用join()、sleep()、wait()方法。</li><li>死亡状态</li></ul><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>一般有两种方法创建线程：</p><ul><li>继承Thread方法</li><li>实现Runnable接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadInterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 线程实现体</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建接口实现类的实例对象</span><span class="token class-name">Runnable</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadInterfaceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建一个Thread类的对象，并将上步中创建的对象作为参数传递给Thread类的构造函数</span><span class="token class-name">Thread</span> threadObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*或者简写为：Thread threadObject = new Thread(new ThreadInterfaceImpl())*/</span><span class="token comment">// 用start()方法启动线程</span>threadObject<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程调度策略"><a href="#线程调度策略" class="headerlink" title="线程调度策略"></a>线程调度策略</h3><p>Java采用抢占式策略，高优先级的线程抢占CPU。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> newPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重置线程优先级</span><span class="token keyword">int</span> <span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 给其他同等优先级的线程一个运行机会</span><span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使线程休眠一段时间</span><span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待某个线程结束后再开始执行另一个线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程的基本控制"><a href="#线程的基本控制" class="headerlink" title="线程的基本控制"></a>线程的基本控制</h3><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><p>关于join()方法，它的使用举一个栗子：<br>设置三个线程，线程1用于生成一群随机数，线程2用于计算随机数之和，线程3用于输出这个和，要求线程1、线程2、线程3依次运行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>myThread</span><span class="token punctuation">;</span><span class="token comment">//线程三，输出结果</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PrintTask</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//            让接收的线程对象执行完，本线程才运行</span>            thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sum="</span><span class="token operator">+</span><span class="token class-name">JoinDemo</span><span class="token punctuation">.</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>myThread</span><span class="token punctuation">;</span><span class="token comment">//线程1，用于产生随机数</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//    线程体</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>myThread</span><span class="token punctuation">;</span><span class="token comment">//线程2,计算线程一产生的随机数的和</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span><span class="token comment">//    构造方法，接收一个数组和一个线程对象</span>    <span class="token keyword">public</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> arr<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//    线程体</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//            让接收的线程执行完，本线程才会执行</span>            thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始计算..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        计算数组中所有元素之和</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">JoinDemo</span><span class="token punctuation">.</span>sum<span class="token operator">=</span>sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>myThread</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//        先启动线程一，生成一群随机数</span>        <span class="token class-name">Thread</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        后启动线程二，计算线程一生成的随机数之和</span>        <span class="token class-name">Thread</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> producer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        worker<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        最后启动线程三，输出结果</span>        <span class="token class-name">Thread</span> printTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintTask</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printTask<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        等待printTask线程对象执行完，程序才继续运行</span>        printTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sum1<span class="token operator">+=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> sum1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"验证通过！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"验证失败！"</span><span class="token operator">+</span><span class="token string">" sum="</span><span class="token operator">+</span>sum<span class="token operator">+</span><span class="token string">", sum1="</span><span class="token operator">+</span>sum1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结束线程与中断线程"><a href="#结束线程与中断线程" class="headerlink" title="结束线程与中断线程"></a>结束线程与中断线程</h3><p>run()线程体运行结束时，该线程自然死亡；<br>stop()方法可以强制停止线程执行（不推荐使用）</p><p>使用interrupt()方法可以使线程中断执行。<br>一般地，在程序中调用interrupt()方法后，通常需要在run()方法中使用isInterrupt()进行判断，根据判断结果执行相应操作。</p><h3 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h3><p>设置三个线程类，通信的双方线程作为辅类线程，都将数据流连接到主类中的管道流中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>commuThread</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataInput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PipedInputStream</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyReader1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span><span class="token comment">//    创建管道输入流</span>    <span class="token keyword">private</span> <span class="token class-name">PipedInputStream</span> pis<span class="token punctuation">;</span><span class="token comment">//    创建数据输入流</span>    <span class="token keyword">private</span> <span class="token class-name">DataInputStream</span> dis<span class="token punctuation">;</span><span class="token comment">//    接收数据</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> messages<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyReader1</span><span class="token punctuation">(</span><span class="token class-name">PipedInputStream</span> pis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pis <span class="token operator">=</span> pis<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//        将数据输入流与管道输入流联系起来</span>        dis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>pis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> dis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            messages <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 读数据</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>messages<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                messages<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Read:"</span><span class="token operator">+</span>messages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>commuThread</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataOutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PipedOutputStream</span><span class="token punctuation">;</span><span class="token comment">//写线程</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWriter1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span><span class="token comment">//    创建管道输出流</span>    <span class="token keyword">private</span> <span class="token class-name">PipedOutputStream</span> pos<span class="token punctuation">;</span>    <span class="token comment">// 创建数据输出流</span>    <span class="token keyword">private</span> <span class="token class-name">DataOutputStream</span> dos<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token comment">//    要写的数据源</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> messages<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Mon"</span><span class="token punctuation">,</span> <span class="token string">"Tues"</span><span class="token punctuation">,</span> <span class="token string">"Wednes"</span><span class="token punctuation">,</span> <span class="token string">"Thur"</span><span class="token punctuation">,</span> <span class="token string">"Fri"</span><span class="token punctuation">,</span> <span class="token string">"Satur"</span><span class="token punctuation">,</span> <span class="token string">"Sun"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyWriter1</span><span class="token punctuation">(</span><span class="token class-name">PipedOutputStream</span> pos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> pos<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//        用 管道输出流 和 写线程的数据输出流 联系起来</span>        dos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            dos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>messages<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>messages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Writte:"</span><span class="token operator">+</span>messages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            dos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">package</span> <span class="token namespace">hitwh<span class="token punctuation">.</span>hitwh<span class="token punctuation">.</span>commuThread</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PipedInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PipedOutputStream</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PipeThread</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PipeThread</span> thisPipe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipeThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thisPipe<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PipedInputStream</span> inputStream<span class="token punctuation">;</span>        <span class="token class-name">PipedOutputStream</span> outputStream<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//            建立管道输入流与管道输出流之间的连接</span>            outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedInputStream</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            读线程与写线程一起运行</span>            <span class="token keyword">new</span> <span class="token class-name">MyWriter1</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">MyReader1</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><h4 id="线程间的资源互斥"><a href="#线程间的资源互斥" class="headerlink" title="线程间的资源互斥"></a>线程间的资源互斥</h4><p>在多个线程共享同一资源的情况下，如果不加以任何控制，就有可能产生访问冲突和数据不一致。<br>为了解决这样的问题，就需要给多个线程共享的资源加锁。当一个线程访问共享资源时，就会被共享资源加锁，其他线程就不能访问被加了锁的资源，直到共享资源的锁被释放。这就是线程同步。<br>在Java中，用关键字synchronize来保证线程同步。当它作用于方法时，称方法同步；作用于语句块时，称为语句块同步。</p><h3 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h3><h4 id="等待集合"><a href="#等待集合" class="headerlink" title="等待集合"></a>等待集合</h4><p>每一个类的对象实例都有一个等待集合，当在实例上调用方法wait后，线程都会进入到该实例的等待集合中，除非发生下列情况：</p><ul><li>其他线程调用了方法notify()或者notifyAll();</li><li>其他线程调用了方法interrupt()中断该线程</li><li>方法wait()的等待时间结束</li></ul><ol><li>wait()<br>wait（）方法是类Object中的方法。当线程调用了方法wait()后，当前线程就会进入休眠状态，并且释放对象同步锁的控制权。</li><li>notify()<br>线程不能一直停留在等待集合中，notify可以从将某个对象的等待集合中选择一个等待的线程进行唤醒。</li><li>notifyAll()<br>唤醒所有等待的线程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据流</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/11/Java%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/11/Java%E6%95%B0%E6%8D%AE%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="数据流的基本概念"><a href="#数据流的基本概念" class="headerlink" title="数据流的基本概念"></a>数据流的基本概念</h2><h3 id="Java的输入输出"><a href="#Java的输入输出" class="headerlink" title="Java的输入输出"></a>Java的输入输出</h3><p>输入：计算机从其他设备读取数据的操作；<br>输出：计算机向其他设备写出数据的操作。</p><h3 id="数据流传输模式"><a href="#数据流传输模式" class="headerlink" title="数据流传输模式"></a>数据流传输模式</h3><p>Java采用了数据流的概念</p><h3 id="基本字节数据流"><a href="#基本字节数据流" class="headerlink" title="基本字节数据流"></a>基本字节数据流</h3><h4 id="字节输入流：InputStream"><a href="#字节输入流：InputStream" class="headerlink" title="字节输入流：InputStream"></a>字节输入流：InputStream</h4><p>字节输入流分为多种，有文件输入流、对象输入流、管道输入流等等。</p><h4 id="字节输出流：OutputStream"><a href="#字节输出流：OutputStream" class="headerlink" title="字节输出流：OutputStream"></a>字节输出流：OutputStream</h4><h3 id="文件数据流"><a href="#文件数据流" class="headerlink" title="文件数据流"></a>文件数据流</h3><p>用于打开一个文件：FileInputStream和FileOutputStream。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inputStream1</span><span class="token punctuation">(</span><span class="token class-name">String</span> fileName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//            声明一个文件数据流</span>            <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c<span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>fis<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//                每次读出一个字符，默认返回0-255的整数</span>                c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件字节数："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">inputStream1</span><span class="token punctuation">(</span><span class="token string">"D:/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关方法有：</p><ul><li>int read();</li><li>int read(byte[] b, int off, int len);</li><li>void write();</li><li>int available();</li><li>void close();</li></ul><h3 id="过滤器数据流"><a href="#过滤器数据流" class="headerlink" title="过滤器数据流"></a>过滤器数据流</h3><p>过滤器数据流在创建时与一个已经存在的数据流相连。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TubeStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//            初始化文件输入流对象</span>            <span class="token class-name">FileInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            初始化一个缓存区数据输入流</span>            <span class="token class-name">InputStream</span> bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            初始化文件输出流</span>            <span class="token class-name">FileOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:/saver.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            初始化一个缓存区数据输出流</span>            <span class="token class-name">OutputStream</span> bout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> c<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> bin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                bout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token comment">//            关闭缓冲区输出流之前，强制输出剩余数据</span>            bout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            关闭文件数据流和缓冲区数据流</span>            in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bout<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据数据流"><a href="#数据数据流" class="headerlink" title="数据数据流"></a>数据数据流</h4><p>文件流和缓冲区流的处理对象是字节和字节数组，利用数据输入输出流则可以实现对文件的不同数据类型的读写。</p><p>常见方法：<br>byte readByte();<br>int readInt();<br>long readLong();<br>double readDouble();<br>boolean readBoolean();<br>String readUTF();</p><p>void writeByte();<br>void writeLong();<br>void writeDouble();<br>void writeBoolean();<br>void writeUTF();</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataStream</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addBooks</span><span class="token punctuation">(</span><span class="token class-name">String</span> fileName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//            创建一个文件输出流</span>            <span class="token class-name">FileOutputStream</span> fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            创建一个数据数据流，与文件输出流建立联系</span>            <span class="token class-name">DataOutputStream</span> dos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            创建Scanner输入对象</span>            <span class="token class-name">Scanner</span> in1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Scanner</span> in2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Scanner</span> in3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入图书信息："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"书号："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> number <span class="token operator">=</span> in1<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"书名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> name <span class="token operator">=</span> in2<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"价格："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">double</span> price <span class="token operator">=</span> in3<span class="token punctuation">.</span><span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//                使用数据数据流，写入信息</span>                dos<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>                dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                dos<span class="token punctuation">.</span><span class="token function">writeDouble</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否继续输入，1表示继续，0表示退出？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>in1<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addBooks</span><span class="token punctuation">(</span><span class="token string">"D:/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="管道数据流"><a href="#管道数据流" class="headerlink" title="管道数据流"></a>管道数据流</h4><p>管道数据流主要用于线程间的通信，指一个线程的PipedInputStream对象从另一个线程中互补的PipedOutputStream对象中接收输入。<br>这两个类必须一起使用，来建立一个通信通道。</p><h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><p>能够输入输出对象的流，称为对象流。它通过ObjectInputStream和ObjectOutputStream两个类实现对象流。</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言中的异常</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/10/Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/10/Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常，是正常程序流程所不能处理或者没有处理的异常情况或者异常事件。</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p>按照异常在编译时是否被检测来分，异常可分为</p><ul><li>受检异常</li><li>非受检异常</li></ul><h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><ul><li>异常对象 程序运行时，如果发生异常，就会生成一个异常事件，相应地生成异常对象。</li><li>抛出异常 生成异常对象并把它提交给运行时系统的这一过程称为抛出一个异常。</li><li>捕获 Java运行时系统将异常对象交给方法处理的过程。</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>方式：捕获异常和转移异常</p><ul><li>捕获异常：通过try-catch-finally结果处理，格式为</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">// 此处为抛出具体异常的代码</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ExceptionType1</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 抛出异常时要执行的代码</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ExceptionType2</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 抛出异常时要执行的代码</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTypek</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 必须执行的代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>转移异常：不在当前方法中处理异常，而是把异常抛出到调用方法中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进一步讨论对象和类（2）</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/09/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB-1/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/09/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB-1/</url>
      
        <content type="html"><![CDATA[<p>再介绍几个类的特殊用法。</p><h2 id="内部类-接口"><a href="#内部类-接口" class="headerlink" title="内部类/接口"></a>内部类/接口</h2><p>也称嵌套类/接口，是在一个类或接口内部声明的类/接口。<br>内部类包括成员类，局部类，匿名类；而内部接口都是成员接口。</p><h2 id="成员类"><a href="#成员类" class="headerlink" title="成员类"></a>成员类</h2><p>成员类分为静态成员类和非静态成员类。<br>在非静态成员类中，有如下特征需要注意：</p><ul><li>不能定义静态变量和方法</li><li>可以访问封装类的所有成员</li><li>访问与该成员类重名的封装类实例成员语法为：封装类类名.this.封装类实例成员名</li></ul><p>另外，在封装类之外创建非静态成员类实例时，需要先创建封装类的实例，然后使用如下语法：<br>封装类类名.非静态成员类类名 实例变量名 = 封装类实例成员名.new 非静态成员类类名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MemberClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 计数变量加一</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">InterClass</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mc<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//    非静态成员类</span>    <span class="token keyword">class</span> <span class="token class-name">InterClass</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//            访问重名属性，需要特定的语法格式</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id="</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">", name="</span><span class="token operator">+</span><span class="token class-name">MemberClass</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"counter="</span><span class="token operator">+</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//    静态成员类</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">NewInterClass</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 访问封装类的静态成员变量</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"counter="</span><span class="token operator">+</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MemberClass</span> ec1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemberClass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ec1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">MemberClass</span> ec2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemberClass</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ec2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">MemberClass</span> ec3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemberClass</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Dora"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        在封装类外部创建非静态成员类，需要创建实例对象</span>        <span class="token class-name">MemberClass<span class="token punctuation">.</span>InterClass</span> mc <span class="token operator">=</span> ec3<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mc<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        在封装类外部创建静态成员类实例，只需通过类名调用</span>        <span class="token class-name">MemberClass<span class="token punctuation">.</span>NewInterClass</span> newMc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemberClass<span class="token punctuation">.</span>NewInterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newMc<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>局部内部类是在封装类的方法中定义的内部类，典型用法是用局部类来实现接口，并在方法中返回接口类型。</p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>指没有名称的类，一般当某个类仅在程序中使用一次，且功能简单时，就可以用匿名类的方式来创建这个类的实例。<br>new 匿名类类名() {<br>    类体;<br>}<br>匿名类必须是一个具体的对象，不能是抽象类（abstract）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberInterface</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从外部实现了公有内部接口"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">OuterClassA</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        obj是InnerInterface内部接口的内部实现类的实例对象，具有innerMethod方法</span>        <span class="token class-name">OuterClassA<span class="token punctuation">.</span>InnerClass</span> obj <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">outerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">MemberInterface</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemberInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span><span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">OuterClassA</span> <span class="token punctuation">&#123;</span><span class="token comment">//    定义一个内部接口</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InnerInterface</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//    定义内部类实现内部接口</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token keyword">implements</span> <span class="token class-name">InnerInterface</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在内部实现了公有内部接口"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//    创建一个内部类实例对象</span>    <span class="token keyword">public</span> <span class="token class-name">InnerClass</span> <span class="token function">outerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>范型是对Java语言类型系统的一种扩展，支持创建可以按类型进行参数化的类、接口或方法。<br>将所操作的数据类型参数化，即该数据类型被声明为一个参数，声明的类型参数在使用时用具体地类型来替换。</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进一步讨论对象和类（1）</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/08/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/08/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>为抽象数据类型的对象定义相应的操作，即方法。<br>定义语法格式：<br>[访问符][修饰符列表]&lt;返回类型&gt; 方法名 ([参数列表]) {<br>    方法体<br>}</p><p>修饰符列表：</p><ul><li>static 表示该方法是一个静态方法，不需要创建实例对象来使用，可以直接通过类来访问。</li><li>final 表示该方法是一个终极方法，不可以在子类中被重写。</li><li>abstract 表示该方法是一个抽象方法，不可以用来创建实例对象。</li></ul><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在函数中，如果传入的参数是基本数据类型，那么函数体对形参的修改不会影响到实参；<br>而如果传入的参数是引用类型（对象、数组等），那么函数体对形参的修改会影响到实参。</p><h3 id="重载方法名"><a href="#重载方法名" class="headerlink" title="重载方法名"></a>重载方法名</h3><p>在一个类中写多个方法，对不同的参数进行同样的操作，此时需要重载方法名。<br>重载方法的方法名必须相同，参数列表必须不同（参数个数或者参数类型不同）。</p><h2 id="对象的构造与初始化"><a href="#对象的构造与初始化" class="headerlink" title="对象的构造与初始化"></a>对象的构造与初始化</h2><p>此处需要提到一个很重要的概念————构造方法。<br>Java中的构造方法，与C++中的构造函数几乎完全对应。</p><h2 id="子类与继承"><a href="#子类与继承" class="headerlink" title="子类与继承"></a>子类与继承</h2><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><p>当两个类A，B满足“A is a B”关系时，我们可以将A声明为B的一个子类。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>与C++类似，Java中也有继承概念。需要用到extends关键字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表示类A继承自B，此时，A是子类，B是父类。<br>一旦继承完成，子类将默认具有父类中的所有属性和方法。</p><p>Java只允许单重继承。Object类是Java程序中所有类的直接或者间接父类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性是指同一个名字的若干个方法，有着不同的实现。<br>通过重载、重写完成多态性。</p><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Graduate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Person!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Student!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Graduate</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>体会上述例子。Person、Student、Graduate均继承了Object的toString方法，却也都对其进行了重写。<br>而func()方法接收一个对象，动态调用对象本身的toString方法。我们称这种由Java虚拟机在运行时动态决定调用哪一个toString方法的能力为动态绑定。</p><h4 id="转换对象"><a href="#转换对象" class="headerlink" title="转换对象"></a>转换对象</h4><p>Java允许使用对象的父类类型的一个变量指示该对象，称为转换对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// notice that: Manager is an Employee.</span><span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Employee</span> e<span class="token punctuation">;</span><span class="token class-name">Manager</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>e <span class="token operator">=</span> m<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们称e是m的转换对象。相较于原对象m，转换对象e会丢失原对象相对于父类的新增方法、属性。实际应用中，我们可以判断该对象是否是子类的实例。如果是，就强制类型转换该对象（引用），使其恢复全部功能。</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类重写父类方法的情况：</p><ul><li>子类的方法内容与父类不同；</li><li>子类需要取消某个方法；</li><li>子类需要实现更复杂的方法</li></ul><p>关于方法重写的注意事项：</p><ul><li>当子类中重写了父类方法后，如果还想使用父类中被隐藏的方法，可以使用super关键字。</li><li>重写方法的允许访问范围不能小于原方法。</li><li>父类与子类的构造方法问题：Java要求一个父类的对象要在子类运行前完全初始化。</li></ul><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>让一个类的多个实例对象共享，实现多个对象之间的通信，或者用于记录所创建的对象的个数。这样的变量被称为静态变量或者类变量。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>如果需要在尚未创建类的实例对象时，就去引用该类的程序代码，就可以给相应的程序方法标记关键字static。这样的方法称为静态方法或者类方法。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h4><p>抽象类是指不能用来创建实例对象的类。通常可以通过关键字abstract将一个类定义为抽象类。<br>在抽象类中，每一个未被定义具体实现的方法也标记为abstract，称为抽象方法。<br>抽象类可以包含抽象方法和非抽象方法。</p><p>抽象类的存在，是强迫程序员必须在抽象类的子类中实现相应的抽象方法，以创建实例对象，否则子类仍然是抽象类，不能用来创建实例对象。</p><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口的最大特点：接口中所有的方法都是抽象方法体，可以将接口看成特殊的抽象类。</p><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Storage</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> storage<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口也具有数据成员和方法，但是数据成员都必须赋初值，并且方法必须是抽象方法。</p><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">StackStorage</span> <span class="token keyword">implements</span> <span class="token class-name">Storage</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> objectNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        storage<span class="token punctuation">[</span>point<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>        objectNum<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般，可以通过接口实现“多重继承”，接口的实现，实际上是实现类对接口中抽象方法的重写。</p><h4 id="接口回调"><a href="#接口回调" class="headerlink" title="接口回调"></a>接口回调</h4><p>接口变量，是用接口声明的变量，可以用来调用被类实现的接口方法。</p><h4 id="接口的多样性"><a href="#接口的多样性" class="headerlink" title="接口的多样性"></a>接口的多样性</h4><p>由接口产生的多态性是指不同的类在实现同一个接口时可能具有不同的实现方式，那么接口变量在回调接口方法时就可能具有多种形态。类似之前抽象类中的动态绑定。</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组、枚举、字符串和容器</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/08/%E6%95%B0%E7%BB%84%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/08/%E6%95%B0%E7%BB%84%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种数据结构，用来存储相同类型的数据，Java将数组作为对象来处理，也就是说，Object中定义的方法都可以用于数组对象。</p><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p><code>type arrayName[];</code><br>或者<br><code>type[] arrayName;</code><br>在数组定义中，不必在方括号[]中指出数组中元素的个数，即数组的长度。此时，仅仅是创建了一个指向数组的引用变量。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组经定义之后，系统并没有为其分配任何内存，因此，数组还必须经过初始化才可以应用数组的元素，这个过程就是数组的创建。</p><ul><li>静态初始化</li><li>动态初始化</li></ul><p>所谓静态初始化，就是在定义数组的同时，对数组元素进行初始化，比如<br><code>int intArray[] = &#123;1, 2, 4, 9&#125;; // 定义了含有4个元素的int型数组</code></p><p>而动态初始化，就是使用运算符new为数组分配空间，数组说明的方括号中的数字表示数组元素的个数。<br><code>type[] arrayName = new type[arraySize];</code><br>比如：<br><code>String[] names = new String[3];</code></p><h3 id="数组元素的引用"><a href="#数组元素的引用" class="headerlink" title="数组元素的引用"></a>数组元素的引用</h3><p>数组名加上方括号[]就可以访问数组元素。<br>另外，当创建一个数组时，每一个元素都会被初始化，比如，字符型数组的每一个值被初始化为0，boolean型数组被初始化为全false。</p><h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><ol><li>arraycopy()<br><code>arraycopy(sourceArray[], int index1, copyArray[], int index2, int length);</code><br>用于将数组sourceArray从索引index1开始后的length个元素中的数据复制到copyArray从索引index2开始的length个位置上。</li><li>copyOf()<br><code>public static type[] copyOf(type[] original, int newLength);</code><br>返回一个数组。</li><li>copyOfRange()<br><code>public static type[] copyOfRange(type[] original,int from, int to);</code></li></ol><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组的本质，是一维数组的每一个元素都是数组这种类型，反复嵌套而形成的一种特殊的数据结构。<br>其初始化分为静态初始化和动态初始化两种。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举类型的定义"><a href="#枚举类型的定义" class="headerlink" title="枚举类型的定义"></a>枚举类型的定义</h3><p>enum 枚举名<br>{<br>    常量列表<br>}</p><h3 id="枚举变量"><a href="#枚举变量" class="headerlink" title="枚举变量"></a>枚举变量</h3><p>声明一个枚举类型后，就可以用该枚举类型的枚举名声明一个枚举变量，该枚举变量只能取枚举类型中的常量：</p><h3 id="枚举类型的for循环和switch循环"><a href="#枚举类型的for循环和switch循环" class="headerlink" title="枚举类型的for循环和switch循环"></a>枚举类型的for循环和switch循环</h3><p>使用枚举类型的values()方法，可以得到一个对应的一维数组。<br>for循环可以用来遍历枚举类型常量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Weekday</span> b<span class="token operator">:</span> <span class="token class-name">Weekday</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Weekday</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Monday</span><span class="token punctuation">,</span>            <span class="token class-name">Tuesday</span><span class="token punctuation">,</span>            <span class="token class-name">Wednesday</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Weekday</span> week<span class="token punctuation">;</span>        week <span class="token operator">=</span> <span class="token class-name">Weekday<span class="token punctuation">.</span>Wednesday</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>week<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java包提供的java.lang中封装了两种类：</p><ul><li>String 用来处理不变的字符串</li><li>StringBuffer 用来处理可变字符串。</li></ul><h3 id="字符串处理常用方法"><a href="#字符串处理常用方法" class="headerlink" title="字符串处理常用方法"></a>字符串处理常用方法</h3><ul><li>length(),返回字符串长度</li><li>charAt(),返回字符串中index位置的字符</li><li>toLowerCase(), 将当前字符串中的所有字符转换为小写形式</li><li>toUpperCase(), 转换为大写形式</li></ul><h3 id="几个特殊处理"><a href="#几个特殊处理" class="headerlink" title="几个特殊处理"></a>几个特殊处理</h3><ol><li>字符串连接<br>对于String类对象，可以使用concat(String str)方法将str连接到当前字符串尾部；<br>此外，“+”也可以实现连接，append()方法也可以实现连接。</li><li>比较<br>compareTo(), equals(), equalslgnoreCase()等，还可以使用关系运算符“==”判定。</li></ol><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Collection容器<br>Collection接口的子接口包括：</p><ul><li>Set 数据对象没有顺序且不可以重复</li><li>List 数据对象有顺序且可以重复</li><li>Queue 按照排队规则来确定对象产生的顺序</li></ul><p>有四个常用容器：</p><ul><li>LinkedList 链表</li><li>ArrayList 数组</li><li>HashSet</li><li>HashMap</li></ul><p>接口中所定义的方法包括：</p><ul><li>boolean add(Object element)</li><li>boolean remove(Object element)</li><li>boolean contains(Object element)</li><li>int size()</li><li>boolean isEmpty()</li><li>void clear()</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个对象，它可以用来遍历并选择序列中的对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span> it <span class="token operator">=</span> courses<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    course <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Course</span><span class="token punctuation">)</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Iterator接口中的方法：<br>boolean hasNext(); 检查序列是否还有元素<br>Object next(); 获得序列中的下一个元素<br>void remove();  将迭代器中当前元素删除</p><h3 id="举例：List接口"><a href="#举例：List接口" class="headerlink" title="举例：List接口"></a>举例：List接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">✓ <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Object</span> element<span class="token punctuation">)</span> <span class="token comment">//增加元素</span>✓ <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Object</span> element<span class="token punctuation">)</span> <span class="token comment">//在指定位置增加元素</span>✓ <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token comment">//获取指定位置元素</span>✓ <span class="token class-name">Object</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Object</span> element<span class="token punctuation">)</span> <span class="token comment">//设置某一位置的元素</span>✓ <span class="token class-name">Object</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token comment">//移走某一位置的元素</span>✓ <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token comment">//返回元素的位置，如果没有该元素，返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基于List容器的排序算法"><a href="#基于List容器的排序算法" class="headerlink" title="基于List容器的排序算法"></a>基于List容器的排序算法</h3><p>对于基本数据类型的容器进行排序时，sort()可以直接实现。但是对于类类型，则需要人为实现Comparable接口。</p><p>何为Comparable接口？<br>Comparable接口中只有一个方法：<br><code>public int compareTo(Object obj);</code><br>该方法返回一个int型数值，<br>当this==obj时，返回0；<br>当this &gt; obj时，返回正数；<br>当this &lt; obj时，返回负数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment">// 实现从小到大排序</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Student</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">-</span> person<span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式和流程控制语句</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/07/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/07/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>一些基本的运算符，比如算术运算符、关系运算符、逻辑运算符等等<br>算术运算符<br>关系运算符<br>逻辑运算符<br>移位运算符</p><h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>常量、变量、方法调用等</p><ul><li>常量</li></ul><p>利用final关键字来进行常量定义：<br><code>final double PI = 3.1415926</code><br>final &amp; static final<br>final关键字可以修饰类、方法、普通变量<br>修饰类：表示当前类是终极类，不能再派生出子类，一般功能比较完善了；<br>修饰方法：表示该方法不可以被重写；<br>修饰普通变量：表示该变量不可以被修改，是只读的。</p><ul><li>变量</li></ul><h3 id="表达式的提升与转换"><a href="#表达式的提升与转换" class="headerlink" title="表达式的提升与转换"></a>表达式的提升与转换</h3><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>Java中的数学函数包：java.math</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><ul><li>分支语句</li><li>循环语句</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标识符和数据类型</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/07/%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/07/%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java程序结构"><a href="#Java程序结构" class="headerlink" title="Java程序结构"></a>Java程序结构</h2><ul><li>package语句</li><li>import语句</li><li>public型的class定义</li><li>class定义</li><li>interface定义</li></ul><h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>boolean 布尔类型</li><li>char 字符类型</li><li>byte，short，int，long 整数类型（1，2，4，8）</li><li>float，double 浮点型<br>如果要表示一个长整型常量，需要在数后面写出字母L，如：</li><li>2L 十进制长整型</li><li>077L 八进制长整型</li><li>0xBABEL 十六进制长整型</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>自动类型转换</li><li>强制类型转换</li></ul><h2 id="类和对象初步介绍"><a href="#类和对象初步介绍" class="headerlink" title="类和对象初步介绍"></a>类和对象初步介绍</h2><h3 id="与类定义有关的关键字"><a href="#与类定义有关的关键字" class="headerlink" title="与类定义有关的关键字"></a>与类定义有关的关键字</h3><h4 id="限定访问权限修饰符"><a href="#限定访问权限修饰符" class="headerlink" title="限定访问权限修饰符"></a>限定访问权限修饰符</h4><ul><li>public 公有的，可以被任何对象访问</li><li>private 只能被这个类本身访问，类外不可见</li><li>protected 保护，只可以被同一包及其子类的实例对象访问</li><li>没有访问修饰符，表示friendly，可以被所在包中的各类访问</li></ul><h4 id="存储方式修饰符"><a href="#存储方式修饰符" class="headerlink" title="存储方式修饰符"></a>存储方式修饰符</h4><p>static 即可以修饰类的属性，也可以修饰类的方法</p><h4 id="与继承相关的关键字"><a href="#与继承相关的关键字" class="headerlink" title="与继承相关的关键字"></a>与继承相关的关键字</h4><ul><li>extends 继承关系的关键字</li><li>final 终极类，表示当前类不能再派生子类</li><li>abstract 既可以修饰类，也可以修饰方法。表示被修饰的成分是抽象的。类似C++中的纯虚函数。</li></ul><h4 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h4><ul><li>this 指代本类</li><li>super 指代父类</li></ul><h3 id="类类型变量的创建"><a href="#类类型变量的创建" class="headerlink" title="类类型变量的创建"></a>类类型变量的创建</h3><h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>类名 变量名<br>此时仅在内存中为其建立一个引用，并置初值为null，表示不指向任何内存空间。</p><h4 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h4><p>变量名 = new 类名(参数列表)<br>申请相应的内存空间，并将该段内存的首地址赋给刚才建立的引用。</p><h4 id="对象说明"><a href="#对象说明" class="headerlink" title="对象说明"></a>对象说明</h4><p>类名 变量名 = new 类名(参数列表)</p><h4 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h4><p>Java将类类型变量看作引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java概论</title>
      <link href="/mid-lake-pavilion.github.io/2021/11/07/Java%E6%A6%82%E8%AE%BA/"/>
      <url>/mid-lake-pavilion.github.io/2021/11/07/Java%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Java语言起源"><a href="#Java语言起源" class="headerlink" title="Java语言起源"></a>Java语言起源</h2><p>Java语言前身是Oak语言。<br>第一个浏览器是Mosaic，开启了一个新时代。<br>2004年9月，Java发布重要版本，更名为Java SE5.0<br>Oracle公司宣布今后每隔6个月更新一次版本<br>Java之父：James Gosling</p><h2 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h2><ul><li>简单性</li><li>平台无关性</li><li>面向对象</li><li>分布式</li><li>安全性</li><li>多线程</li></ul><h2 id="Java运行机制"><a href="#Java运行机制" class="headerlink" title="Java运行机制"></a>Java运行机制</h2><p>Java虚拟机（JVM），JRE（运行环境），JDK（开发工具包）</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/mid-lake-pavilion.github.io/2021/10/30/git/"/>
      <url>/mid-lake-pavilion.github.io/2021/10/30/git/</url>
      
        <content type="html"><![CDATA[<h2 id="玩转git三剑客"><a href="#玩转git三剑客" class="headerlink" title="玩转git三剑客"></a>玩转git三剑客</h2><h3 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h3><h3 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h3><p>在安装好git后，我们首先需要配置一下user信息：<br><code>git config --global user.name &#39;&#39;</code><br><code>git config --global user.email &#39;&#39;</code><br>这样在团队协作开发时，你所做的每一次提交，都会更加明晰。<br>—global 是对当前用户所有的仓库有效；<br>—local 只对当前用户的当前仓库有效<br>运行<br><code>git config --global --list</code><br>可以查看当前的配置信息</p><h3 id="创建一个git仓库"><a href="#创建一个git仓库" class="headerlink" title="创建一个git仓库"></a>创建一个git仓库</h3><p><code>cd 某一个文件夹</code><br><code>git init your_project #在当前路径下创建和项目名称同名的文件夹</code><br><code>cd your_project</code></p><p><code>git commit -m&#39;xxx&#39;</code>提交本次作出的修改，xxx中填写一些说明信息，比如<br><code>git commit -m&#39;新增了readme文件&#39;</code></p><p><code>git add readme</code> 将文件添加到暂存区中，这样为commit做好准备</p><h3 id="往git仓库中添加文件"><a href="#往git仓库中添加文件" class="headerlink" title="往git仓库中添加文件"></a>往git仓库中添加文件</h3><p>git提供了缓存区功能。我们在工作目录git add files后，可以将文件添加到暂存区，然后git commit就可以将暂存区中的内容提交</p><h3 id="git中文件地重命名"><a href="#git中文件地重命名" class="headerlink" title="git中文件地重命名"></a>git中文件地重命名</h3><p>常规地，对于已经提交的文件，以readme为例，我们现在要将其重命名为readme.md，则需要三步：</p><ul><li>mv readme readme.md</li><li>git add readme.md</li><li>git rm readme</li></ul><p>现在，有更加方便的做法，直接使用如下命令：<br>git mv readme readme.md<br>即可。</p><h3 id="查看git版本历史"><a href="#查看git版本历史" class="headerlink" title="查看git版本历史"></a>查看git版本历史</h3><p>命令 git log 可以快速查看所有版本git<br>介绍一个概念：分支（branch）<br><code>git branch</code>可以用来查看当前分支<br><code>git branch dev</code> 可以创建一个名为dev的分支<br><code>git branch -a</code> 可以用来查看所有分支<br><code>git checkout 分支名</code> 可以切换到指定分支<br><code>git log</code>默认查看当前分支的所有版本信息<br><code>git log --all</code> 可以查看所有分支的所有版本信息<br><code>git log --all --graph</code> 可视化查看所有分支的所有版本信息</p><h3 id="git文件的探秘"><a href="#git文件的探秘" class="headerlink" title=".git文件的探秘"></a>.git文件的探秘</h3><p>在指定的目录下使用git init命令后，会生成一个默认的.git文件夹。我们在仓库文件目录下，运行命令<br><code>cd .git</code><br><code>dir</code><br>然后显示文件结构，运行命令<br><code>type 文件名</code><br>可以显示文件内容</p><ul><li>HEAD 它是一个引用，指向了当前正在工作的分支。实际上它最终指向到一个commit上了。</li><li>config文件，它存储了git仓库的一些配置信息，比如之前的user配置信息，user.name以及user.email等等。</li><li>refs 存储了heads和tags</li><li>objects</li></ul><h3 id="git对象关系"><a href="#git对象关系" class="headerlink" title="git对象关系"></a>git对象关系</h3><p>commit、tree、blob三者之间的关系</p><h3 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h3><p>分离头指针，是指某些情况下，当前的commit没有和任何分支绑定在一起，可能会被git当做垃圾清理掉，造成一些损失。<br>注意：如果只是做一些尝试性工作，分离头指针也许并不是一件坏事；<br>如果在开发过程中，做了一些重要的更改，那么就一定要将它和特定的分支绑定在一起。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本协同工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="/mid-lake-pavilion.github.io/2021/10/28/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
      <url>/mid-lake-pavilion.github.io/2021/10/28/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h2><h3 id="为什么使用总线"><a href="#为什么使用总线" class="headerlink" title="为什么使用总线"></a>为什么使用总线</h3><p>现代计算机至少由三个部分组成，而计算机总线则将各个部分连接起来。计算机使用总线结构便于增减外设，同时减少了信息传输线的条数。</p><h3 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h3><p>从本质上说，总线就是电导线，属于计算机硬件。</p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><ul><li>片内总线：芯片内部的总线</li><li>系统总线：计算机各部件之间的信息传输线<ul><li>数据总线</li><li>地址总线</li><li>控制总线</li></ul></li><li>通信总线：用于计算机系统之间或者计算机系统与其他系统之间的通信</li></ul><h2 id="总线特性和性能指标"><a href="#总线特性和性能指标" class="headerlink" title="总线特性和性能指标"></a>总线特性和性能指标</h2><h3 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h3><ol><li>机械特性<br>尺寸、形状、管脚数、排列顺序等</li><li>电气特性<br>传输方向和有效的电平范围</li><li>功能特性<br>指每一根传输线的功能，分为地址线、数据线、控制线</li><li>时间特性<br>即信号的时序关系</li></ol><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><ul><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>总线复用：地址线和数据线的复用（减小芯片的面积）</li><li>总线控制方式</li></ul><h3 id="总线的标准"><a href="#总线的标准" class="headerlink" title="总线的标准"></a>总线的标准</h3><p>AGP总线，显卡专用的局部总线</p><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><p>所谓的总线结构包括单总线结构、双总线结构、三总线结构。<br>三总线结构的计算机，总线包括：I/O总线、主存总线和DMA总线。<br>还有一种形式是局部总线、系统总线和扩展总线三部分组成。<br>四总线结构在三总线结构上还有进一步优化，包括局部总线、系统总线、高速总线、扩展总线。计算机将一些访问速度较慢的设备与扩展总线相连，高速总线连接速度较快的设备，实现了不同部件访问速度的分类放置。</p><h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><p>总线上连接多个设备，那么不可避免地需要解决两个问题：<br>总线的判优控制：多个设备向总线发起控制申请，究竟谁能获得总线控制权?<br>总线和通信控制：拿到了总线控制权，总线和设备怎么通信？</p><h3 id="总线的判优控制"><a href="#总线的判优控制" class="headerlink" title="总线的判优控制"></a>总线的判优控制</h3><p>总线判优控制有两种：集中式和分布式；其中集中式会是我们介绍的重点，包括三种：链式查询、计数器查询、独立请求。</p><h4 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h4><p>对于所有的设备而言，BR线负责传输设备对总线的控制请求，而BS是总线忙的状态线；而链式查询特征就体现在BG线上。</p><h4 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h4><p>名称来源自</p><h3 id="总线的通信控制"><a href="#总线的通信控制" class="headerlink" title="总线的通信控制"></a>总线的通信控制</h3><h4 id="总线传输周期"><a href="#总线传输周期" class="headerlink" title="总线传输周期"></a>总线传输周期</h4><ul><li>申请分配阶段：主模块申请，总线仲裁决定</li><li>寻址阶段：主模块向从模块给出地址和命令</li><li>传数阶段：主模块和从模块交换数据</li><li>结束阶段：主模块撤销有关信息</li></ul><h4 id="总线通信四种方式"><a href="#总线通信四种方式" class="headerlink" title="总线通信四种方式"></a>总线通信四种方式</h4><ul><li>同步通信：主模块和从模块采用统一时标控制数据传送。（时钟定宽定距）</li><li>异步通信：不采用统一的时标，而是采用应答方式。<ul><li>不互锁</li><li>半互锁</li><li>全互锁</li></ul></li><li>半同步通信：有定宽定距的时钟，却允许不同速度的模块协调工作</li><li>分离式通信<ul><li>各个模块都有权申请占用总线</li><li>采用同步方式通信</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论</title>
      <link href="/mid-lake-pavilion.github.io/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/mid-lake-pavilion.github.io/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机的软硬件概念"><a href="#计算机的软硬件概念" class="headerlink" title="计算机的软硬件概念"></a>计算机的软硬件概念</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>即计算机的实体，包括主机、外设、总线等。</p><blockquote><p>何为主机？<br>处理器和主存统称为主机；实际上，主机可以包括CPU、主存、I/O接口、总线。<br>何为外设？<br>把输入输出设备统称为外部设备。</p></blockquote><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>由各类特殊功能的信息（程序）组成</p><ul><li>系统软件 用于管理整个计算机系统，比如语言处理程序、操作系统、服务性程序、数据库管理系统、网络软件</li><li>应用软件 按任务需要编制成的各种软件。</li></ul><h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><h3 id="冯·诺依曼计算机的特点"><a href="#冯·诺依曼计算机的特点" class="headerlink" title="冯·诺依曼计算机的特点"></a>冯·诺依曼计算机的特点</h3><p>冯·诺依曼是最早提出“存储程序”概念</p><p>冯·诺依曼计算机有一些特点。首先，冯诺依曼计算机以运算器为中心，由五大部分组成：</p><ul><li>存储器<ul><li>主存：主板上的存储器是可以被处理器直接访问的，故称“主存储器”，简称主存</li><li>辅存</li></ul></li><li>控制器 CU</li><li>运算器 ALU</li><li>输入设备</li><li>输出设备</li></ul><p>通常将CU和ALU集成在一起（实际上，还要加上一些寄存器），构成处理单元PU（也称处理器），一台计算机只有一个PU，那么它必定是计算机的核心部件之一，故称CPU（中央处理器）；输入设备和输出设备统称IO设备。</p><blockquote><p>哈佛体系结构<br>哈佛大学Aiken在研制了机电计算机Mark I之后，继续研制了后继的机电计算机Mark II 以及电子管计算机Mark III和Mark IV, Mark III和Mark IV与同期的EDVAC、EDSAC。<br>与这些使用单一存储器存放指令和数据的计算机相比，最大的不同是使用分离的存储器存放指令和数据。<br>当时冯·诺依曼体系结构已经普遍被接受，所以这种机器被认为是异端的，并被称为哈佛体系结构。</p></blockquote><h2 id="计算机体系结构简介"><a href="#计算机体系结构简介" class="headerlink" title="计算机体系结构简介"></a>计算机体系结构简介</h2><ul><li>计算机组成：计算机体系结构的逻辑实现</li><li>计算机实现：计算机组成的物理实现</li><li>计算机软件/硬件的等价性原理<br>硬件和软件在逻辑功能上是等价的。软件的功能在原理上可以由硬件或固件来实现，硬件的功能在原理上也可以由软件的模拟来实现。</li></ul><h2 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h2><p>主存储器由存储体、MAR、MDR组成。</p><p>与存储相关的术语：</p><ul><li>存储单元 存取一串二进制代码</li><li>存储字 存储单元中二进制代码的组合</li><li>存储字长 存储单元中二进制代码，每个存储单元赋予一个地址</li></ul><p>MAR 即存储器地址寄存器，反映存储单元的个数；<br>MDR 即存储器数据寄存器，反映存储字长。</p><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><h2 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h2><h3 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h3><p>即CPU一次能够处理数据的位数，一般等于CPU中的寄存器位数。</p><h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><ul><li>主频<br>主频的倒数即为时钟周期。</li><li>吉普森法计算机器运行速度</li><li>核数 每一个核支持的线程数</li><li>CPI 即执行一条指令需要的时钟周期数</li><li>MIPS 每秒执行的指令的平均条数</li><li>FLOAPS 浮点运算次数每秒，即Floatint Point Operation Per Second</li></ul><h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><ul><li>主存容量<ul><li>存储单元个数×存储字长，如 1K × 8位</li><li>直接用字节数表示，如 1KB = $ 2^13 $ b</li></ul></li><li>辅存容量<ul><li>用字节数表示</li></ul></li></ul><blockquote><p>计算机系统主存储器的最大存储单元个数取决于处理器地址总线的线数（宽度）（也即MAR的位数，MAR与处理器地址总线相连）<br>存储字长是由CPU中的MDR的位数反映。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序逻辑电路</title>
      <link href="/mid-lake-pavilion.github.io/2021/10/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
      <url>/mid-lake-pavilion.github.io/2021/10/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="时序逻辑电路的分析"><a href="#时序逻辑电路的分析" class="headerlink" title="时序逻辑电路的分析"></a>时序逻辑电路的分析</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>分析一个时序逻辑电路，步骤往往分为如下几步：</p><ol><li>根据电路图，写出输出方程（时序逻辑电路有可能没有输出，此时该步骤省略）</li><li>根据电路图，写出驱动方程（输入方程）</li><li>根据已经得到的驱动方程和已知触发器的次态方程，得到每一个触发器的状态方程</li><li>根据状态方程，得出状态表（类似真值表，输入变量包括真实的输入、现态，输出变量包括输出、次态）</li><li>根据得到的状态表，绘制状态转化图</li><li>在这些都已经求得的基础上，分析该时序逻辑电路的功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数字逻辑设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学课程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
