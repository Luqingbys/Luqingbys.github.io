<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>浏览器 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="宏观视角下的浏览器浏览器最开始是美国网景公司开发的，自诞生之日起，地位一直只增不减。  C&#x2F;S    client、server，即客户端、服务端B&#x2F;S    browser、server，即浏览器、服务端  浏览器工作原理重要性 了解浏览器如何工作，能够让我们更准确地决策是否可以采用Web来开发项目 站在更高的角度审视前端页面 在技术快速迭代的时代把握本质  进程与线程进程：">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器">
<meta property="og:url" content="https://luqingbys.github.io/mid-lake-pavilion.github.io/2022/02/10/%E6%B5%8F%E8%A7%88%E5%99%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="宏观视角下的浏览器浏览器最开始是美国网景公司开发的，自诞生之日起，地位一直只增不减。  C&#x2F;S    client、server，即客户端、服务端B&#x2F;S    browser、server，即浏览器、服务端  浏览器工作原理重要性 了解浏览器如何工作，能够让我们更准确地决策是否可以采用Web来开发项目 站在更高的角度审视前端页面 在技术快速迭代的时代把握本质  进程与线程进程：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-10T05:13:11.000Z">
<meta property="article:modified_time" content="2022-03-03T07:04:47.733Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/mid-lake-pavilion.github.io/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/mid-lake-pavilion.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/mid-lake-pavilion.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/mid-lake-pavilion.github.io/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/mid-lake-pavilion.github.io/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/mid-lake-pavilion.github.io/">Home</a>
        
          <a class="main-nav-link" href="/mid-lake-pavilion.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/mid-lake-pavilion.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://luqingbys.github.io/mid-lake-pavilion.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-浏览器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2022/02/10/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2022-02-10T05:13:11.000Z" itemprop="datePublished">2022-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      浏览器
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a>宏观视角下的浏览器</h2><p>浏览器最开始是美国网景公司开发的，自诞生之日起，地位一直只增不减。</p>
<blockquote>
<p>C&#x2F;S    client、server，即客户端、服务端<br>B&#x2F;S    browser、server，即浏览器、服务端</p>
</blockquote>
<h3 id="浏览器工作原理重要性"><a href="#浏览器工作原理重要性" class="headerlink" title="浏览器工作原理重要性"></a>浏览器工作原理重要性</h3><ol>
<li>了解浏览器如何工作，能够让我们更准确地决策是否可以采用Web来开发项目</li>
<li>站在更高的角度审视前端页面</li>
<li>在技术快速迭代的时代把握本质</li>
</ol>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程：就是内存中正在运行的应用程序，包括如下特点：</p>
<ul>
<li>进程在内存中独占一个内存空间</li>
<li>进程与进程之间是隔离的，比如手机玩王者荣耀（进程），如果王者荣耀崩溃了，这个进程就终止了，但是手机中的其他应用（比如微信）不会受到影响（进程之间隔离）</li>
</ul>
<p>线程：进程的最小执行单位。它也有一定的特点：</p>
<ul>
<li>一个进程是由多个线程组成的</li>
<li>每一个线程之间也是相互隔离的（比如微信可以和多个人聊天，也互不干扰）</li>
</ul>
<p>一个页面启动的时候，至少启动了4个进程：</p>
<ul>
<li>浏览器主进程</li>
<li>渲染进程</li>
<li>网络进程</li>
<li>GPU进程</li>
</ul>
<p>如果安装了插件，还会运行插件进程。<br>下面逐个简介这些进程：</p>
<ul>
<li>浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能；</li>
<li>渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中；</li>
<li>网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，现在已经独立成为单独一个进程；</li>
<li>GPU进程：GPU，即图像处理单元，其使用初衷是为了实现3D、CSS的效果，后来网页等界面都采用了GPU来绘制。</li>
<li>插件进程：主要负责插件运行，由于插件容易崩溃，于是该进程与其他进程隔离开来，防止插件的崩溃影响到浏览器和页面。</li>
</ul>
<h2 id="计算机网络的七层模型"><a href="#计算机网络的七层模型" class="headerlink" title="计算机网络的七层模型"></a>计算机网络的七层模型</h2><p>从下往上的顺序为：</p>
<ol>
<li>物理层：使用一定的物理介质来进行计算机之间的连接，以电信号0、1进行传输；</li>
<li>数据链路层：MAC地址，对物理层的0、1信号进行封装，封装成比特；</li>
<li>网络层：IP地址</li>
<li>传输层：涉及UDP（用户数据包协议）&#x2F;TCP（传输控制协议）</li>
<li>会话层：断点续传</li>
<li>表示层：解决不同系统之间数据传输的问题</li>
<li>应用层：HTTP</li>
</ol>
<blockquote>
<p>UDP：只管发，不管收<br>TCP：具有重传机制、排序机制</p>
</blockquote>
<p>也可以表示为四层：</p>
<ul>
<li>物理层：物理层、数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层：会话层、表示层、应用层</li>
</ul>
<h2 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h2><p>浏览器发送HTTP请求的大致请求流程如下：</p>
<ol>
<li>构造请求行</li>
<li>查找缓存</li>
<li>准备IP地址和端口号</li>
<li>等待TCP队列，一个域名最多只能和建立6个TCP连接</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
</ol>
<p>服务器处理HTTP请求的流程：</p>
<ol>
<li>返回请求内容</li>
<li>断开连接</li>
</ol>
<h2 id="从进程角度看浏览器"><a href="#从进程角度看浏览器" class="headerlink" title="从进程角度看浏览器"></a>从进程角度看浏览器</h2><p>从用户在url地址栏到浏览器显示页面，这个过程中到底发生了什么。<br>主要涉及了浏览器主进程、网络进程、渲染进程。</p>
<ol>
<li>用户在浏览器主进程中输入url地址；</li>
<li>浏览器主进程将url请求派发给网络进程；</li>
<li>在网络进程中，发送url请求，获取响应头数据，解析响应头数据；</li>
<li>网络进程将解析出来的数据转发给浏览器主进程；</li>
<li>浏览器主进程接收到网络进程的响应数据，发送“提交文档”（HTML数据）消息给渲染进程；</li>
<li>在渲染进程中，接收到消息之后，准备接收HTML数据，接收数据的方式是直接和网络进程之间建立数据管道。</li>
<li>文档数据传输完毕，渲染进程将会返回“确认提交”消息给浏览器主进程。</li>
<li>在浏览器主进程中，收到渲染进程后“确认提交”消息后，便开始移除旧文档，更新浏览器进程状态。</li>
</ol>
<h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h2><p>以一个很简单的.html文件为例，进行说明：</p>
<ol>
<li>构建DOM树——使用html解析器（ParseHTML）将html页面转化为浏览器能够理解的DOM树；<br>因为浏览器无法直接理解和使用html，因此需要将html转化为浏览器能够理解的结构——DOM树。</li>
<li>将css解析成浏览器能够识别的CSS树</li>
<li>样式计算</li>
<li>由DOM树、CSS树得到布局树</li>
<li>根据布局树生成图层树（只有某些具有特殊属性的节点才会单独占据一个图层）</li>
<li>绘制</li>
<li>组合图层，生成最终的页面<blockquote>
<p>图层：在html页面中，虽然网页是二维的，但是实际上相当于一个“俯视图”，也就是说，实际上是存在“图层”的，以下html元素可以作为一个单独的图层：</p>
<ol>
<li>具有3d效果的元素</li>
<li>fixed固定定位的元素</li>
<li>视频播放元素video</li>
<li>绘图画板canvas</li>
<li>css动画节点</li>
</ol>
</blockquote>
</li>
</ol>
<p>浏览器每次最多可以接收64Kb资源。</p>
<h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><p>图层是在布局的基础上,为了进一步显示一些复杂的3D变换、页面滚动等效果，也产生的一种渲染结果。</p>
<h3 id="哪些节点会被渲染为新的层"><a href="#哪些节点会被渲染为新的层" class="headerlink" title="哪些节点会被渲染为新的层"></a>哪些节点会被渲染为新的层</h3><p>当然了，并不是布局树的每一个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。以下两种情况的节点会被单独提升为一个图层：</p>
<ol>
<li>拥有层叠上下文属性的元素<br>比如，fixed固定定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等。</li>
<li>需要剪裁（clip）的地方也会被创建为图层。</li>
</ol>
<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><h4 id="得到绘制列表"><a href="#得到绘制列表" class="headerlink" title="得到绘制列表"></a>得到绘制列表</h4><p>图层树构建完成后，渲染引擎会对图层树中的每一个图层进行绘制，大体步骤是把每一个图层的绘制拆分成很多个小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表，称为绘制列表。</p>
<blockquote>
<p>在浏览器开发者工具的Layers（图层）选项中，可以清楚地看到，当点击一个图层进行分析，会出现诸如drawRect、drawPaint等小绘制指令。</p>
</blockquote>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，也就是说，接下来的工作将由合成线程完成。</p>
<h4 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h4><p>合成线程并不会一下子绘制出所有图层内容，因为这样花销太大。它转而会将图层划分为图块（tile，是栅格化执行的最小单位），并且按照视口附近的图块来优先生成位图。<br>所谓栅格化，就是将图块转换为位图，会在线程池内执行，该线程池称为栅格化线程池。</p>
<h4 id="合成、显示"><a href="#合成、显示" class="headerlink" title="合成、显示"></a>合成、显示</h4><p>上述提到的栅格化如果对所有图块都进行完毕，合成线程就会生成一个绘制图块的命令——DrawQuad，然后将该命令提交给浏览器进程，由其中的viz组件接收命令，将页面内容绘制到内存中，最后将内存显示在屏幕上。</p>
<h3 id="重排、重绘、合成"><a href="#重排、重绘、合成" class="headerlink" title="重排、重绘、合成"></a>重排、重绘、合成</h3><p>在厘清这三者之前，我们首先强调浏览器渲染流水线：</p>
<ol>
<li>DOM（生成浏览器可以识别的DOM树）</li>
<li>Style（生成CSS树、样式计算）</li>
<li>Layout（得到布局树）</li>
<li>Layer（得到图层树）</li>
<li>Paint（绘制）</li>
<li>合成操作</li>
</ol>
<p>上述1~5都是需要主线程参与的，而只有最后一步合成不需要主线程参与，需要非主线程（合成线程）参与。</p>
<h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>如果，我们通过JavaScript或者CSS修改元素几何位置属性，比如改变元素宽度、高度等，会引发浏览器重新布局——此之谓“重排”。<br>重排需要更新完整的渲染流水线，所以开销很大。</p>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>现在情况变了，我们通过JavaScript更改某些元素的背景颜色，很显然，由于几何位置不变，布局不会受到影响，因此渲染流水线中的Layout（布局）阶段不会重新进行，而是直接进入绘制（Paint）阶段，然后再执行其子阶段——此之谓“重绘”。<br>相较于重排，重绘省去了布局和分层阶段，所以执行效率会比重排操作更高一些。</p>
<h4 id="合成（直接合成）"><a href="#合成（直接合成）" class="headerlink" title="合成（直接合成）"></a>合成（直接合成）</h4><p>也即跳过了渲染流水线的布局、绘制，只执行后续合成操作——此之谓“合成”。<br>相比于重排、重绘，合成可以大大提高绘制效率，因为它根本没有占用主线程的资源。</p>
<h2 id="浏览器中JavaScript的执行"><a href="#浏览器中JavaScript的执行" class="headerlink" title="浏览器中JavaScript的执行"></a>浏览器中JavaScript的执行</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>首先我们需要明白的是，在JavaScript中何为声明，何为赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">&#x27;奇异博士&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的语句等价于两句，声明、赋值分离开来写为</span></span><br><span class="line"><span class="keyword">var</span> myName</span><br><span class="line">myName = <span class="string">&#x27;奇异博士&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是一个完整的函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是一个变量声明、赋值，只不过赋值了一个函数</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，我们可以得到变量提升的定义：<br>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<h4 id="何为执行上下文"><a href="#何为执行上下文" class="headerlink" title="何为执行上下文"></a>何为执行上下文</h4><p>我们从如下一段JavaScript代码分析起：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName)</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&#x27;朱由榔&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;showName被调用!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过浏览器的JavaScript引擎的编译后，会生成两部分内容：</p>
<ul>
<li>执行上下文（Execution context）</li>
<li>可执行代码</li>
</ul>
<p>所谓执行上下文，是JavaScript执行一段代码时的运行环境，在执行上下文终存在一个变量环境的对象，它保存了变量提升的内容。</p>
<p>以上面的代码为例，逐句分析：</p>
<ul>
<li>第1、2句并不涉及变量声明，JavaScript引擎不作处理；</li>
<li>第3句，JavaScript引擎会在环境对象中创建一个名为myName的属性，并使用undefined对其初始化；</li>
<li>第4句，JavaScript将函数showName定义存储到堆（HEAP）中，并在环境对象中创建了一个showName属性，并用该属性值指向堆中函数的位置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行上下文</span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;showName被调用!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可执行代码</span></span><br><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName)</span><br><span class="line">myName = <span class="string">&#x27;朱由榔&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，如果变量和函数名相同，那么在编译阶段，变量的声明会被忽略。换言之，函数提升优于变量提升，导致变量声明被忽略。</p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>调用栈，就是用来管理函数调用关系的一种数据结构。<br>通俗地说，每一个函数都对应一个函数上下文，在整个代码片段中，调用栈中保存的都是执行上下文，故又称执行上下文栈。</p>
<p>当然，调用栈也是有大小的，当入栈的执行上下文超过一定数目时，JavaScript引擎就会报错，这种错误就叫栈溢出。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在JavaScript中，有两种作用域是ES6之前支持的：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
</ul>
<p>此外，ES6之前的JavaScript不支持块级作用域（即使用大括号包裹的区域单独形成一个作用域）。</p>
<h4 id="变量提升带来的副作用"><a href="#变量提升带来的副作用" class="headerlink" title="变量提升带来的副作用"></a>变量提升带来的副作用</h4><p>变量提升会带来一些让常人觉得匪夷所思的问题。我们从一个栗子看起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> myname = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showName</span>()</span><br></pre></td></tr></table></figure>

<p>上面代码的运行结果都是undefined。和其他语言（如C）不同，它们都有块级作用域，在此处的打印结果为“ 极客时间 ”。<br>原因就是变量提升以及调用栈。showName函数提升后，会创建执行上下文，即showName的函数执行上下文，它入调用栈，压在全局执行上下文上面。当执行showName函数时，就会在调用栈顶的函数执行上下文中寻找myname变量，它的初始值为undefined，于是打印undefined。</p>
<p>下面的一个栗子也可以说明问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>上述代码的运行结果为7，原因很简单，是因为在创建执行上下文时，变量i会提升，而for循环虽然结束，但是函数并未结束，变量i仍然存在（或者更准确地说，for循环本应该形成一个单独的块级作用域，但是在此处JavaScript并不支持块级作用域）。</p>
<h3 id="ES6的对块级作用域的优化"><a href="#ES6的对块级作用域的优化" class="headerlink" title="ES6的对块级作用域的优化"></a>ES6的对块级作用域的优化</h3><p>JavaScript通过执行上下文来创建作用域（函数执行上下文对应函数作用域、全局执行上下文对应全局作用域），为了进一步说明ES6对作用域的优化，我们进一步分析<strong>执行上下文的组成</strong>：</p>
<ul>
<li>变量环境</li>
<li>词法环境</li>
</ul>
<p>然后，我们给出如下结论：</p>
<ul>
<li>函数内部，通过var声明的变量，在编译阶段全都存放到变量环境中去了</li>
<li>通过let声明的变量，在编译阶段会被存放到词法环境中</li>
<li>在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中</li>
</ul>
<p>其实，在词法环境内部，也维护了一个小型栈结构，栈底是函数最外层的变量，每进入一个作用域块，就会将当前作用域块内部的变量压入栈顶；当作用域执行完毕，该作用域的信息就会从栈顶弹出。这就是词法环境。</p>
<p>最后总结一句话：<strong>JavaScript中的块级作用域就是通过词法环境的栈结构来实现的</strong>。</p>
<p>下面有一个思考题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myname= <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myname) </span><br><span class="line">  <span class="keyword">let</span> myname= <span class="string">&#x27;极客邦&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：报错。<br>let声明的变量提升，并不是创建、初始化（声明）全部被提升，而是仅仅创建被提升，在初始化之前，会形成一个暂时性死区。</p>
<blockquote>
<p>与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。</p>
</blockquote>
<ul>
<li>var的创建和初始化被提升，赋值不会被提升。</li>
<li>let的创建被提升，初始化和赋值不会被提升。</li>
<li>function的创建、初始化和赋值均会被提升。</li>
</ul>
<h2 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a>浏览器中的页面循环系统</h2><h3 id="消息队列与页面循环"><a href="#消息队列与页面循环" class="headerlink" title="消息队列与页面循环"></a>消息队列与页面循环</h3><p>消息队列是一种数据结构，可以存放要执行的任务，符合队列“先进先出”的特点：在队列尾部添加新任务，在队列头部取出任务。</p>
<p>其实，页面线程所有执行的任务都来自于消息队列，鉴于其“先进先出”的属性，有如下两个问题需要解决：</p>
<ul>
<li>如何处理高优先级的任务——宏任务与微任务</li>
<li>如何解决单个任务执行时间过长的问题——JavaScript的回调功能</li>
</ul>
<h3 id="探究setTimeout"><a href="#探究setTimeout" class="headerlink" title="探究setTimeout"></a>探究setTimeout</h3><p>上面提到过，事件循环系统中存在一个消息队列，并按顺序执行消息队列中的任务，而setTimeout是一个定时器，需要延迟一定时间再执行任务，因此不能直接将要延迟执行的任务放入消息队列中。<br>事实上，在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟的任务列表，包括定时器。当定时器被创建时，渲染进程将定时器的回调任务添加到延迟队列中。</p>
<h4 id="定时器的注意事项"><a href="#定时器的注意事项" class="headerlink" title="定时器的注意事项"></a>定时器的注意事项</h4><ol>
<li>如果当前任务执行时间过久，会影响迟到期定时器任务的执行</li>
<li>如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒</li>
<li>未激活的页面，setTimeout执行最小间隔是1000毫秒</li>
<li>延时执行时间有最大值<br>如果setTimeout设置的延迟值大于2147483647毫秒（Chrome以32位来存储延迟值，最大为2^32-1</li>
<li>setTimeout设置的回调函数中的this指向问题<br>如果setTimeout推迟执行的回调函数是某一个对象的方法，那么<strong>该方法中的this指向全局环境window，而不是定义时方法所在的那个对象</strong>。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">showName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title class_">MyObj</span>.<span class="property">showName</span>, <span class="number">1000</span>); <span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>

<p>在上面的栗子中，由于showName函数内部的this指向window，而window上并没有name属性，因此呢，控制台输出undefined。<br>对此，一般的解决方法有两种：</p>
<ul>
<li>将showName放到另一个匿名函数中执行（箭头或者ES5写法都行）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">showName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">MyObj</span>.<span class="title function_">showName</span>()</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">MyObj</span>.<span class="title function_">showName</span>()</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用bind方法，将showName绑定到MyObj对象上</li>
</ul>
<blockquote>
<p>bind()方法会创建一个新的函数，在bind()被调用时，这个新函数的this会被指定为bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">showName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用MyObj对象的showName方法的bind()，将该函数中的this设置为MyObj</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title class_">MyObj</span>.<span class="property">showName</span>.<span class="title function_">bind</span>(<span class="title class_">MyObj</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><ul>
<li>宏任务：页面中大部分任务（渲染事件、用户交互、网络请求完成等）都是在主线程上执行的，这些消息队列中的任务被称为宏任务。</li>
<li>微任务：<br>其实JavaScript在执行一段脚本的时候，V8引擎在创建全局执行上下文的同时创建一个微任务队列，用于存放微任务，这样每一个宏任务都会关联一个微任务队列。</li>
</ul>
<p>当宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是用来处理异步任务的，以XML网络请求为例，我们先来看看一般的异步操作写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//makeRequest 用来构造 request 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeRequest</span>(<span class="params">request_url</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> request = &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;Get&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: request_url,</span><br><span class="line">        <span class="attr">headers</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">body</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">credentials</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">sync</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">responseType</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">        <span class="attr">referrer</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org/?category&#x27;</span>),</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">          <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org/column&#x27;</span>),</span><br><span class="line">              <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">                  <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org&#x27;</span>)</span><br><span class="line">                      <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">                          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">                      &#125;, <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">                          <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">                      &#125;)</span><br><span class="line">              &#125;, <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">              &#125;)</span><br><span class="line">      &#125;, <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码完成的大概是三次嵌套请求，混乱不堪，难以入目，总结起来问题有两个：</p>
<ul>
<li>嵌套调用，回调函数内部再次执行回调函数</li>
<li>任务具有不确定性，每一个请求任务都有两种可能的结果</li>
</ul>
<p>而Promise就解决了这两个问题。</p>
<p>Promise构造函数语法如下：</p>
<p><code>Promise(function(resolve, reject) &#123;&#125;)</code></p>
<p>其中，resolve是成功的回调函数，reject是失败的回调函数。使用Promise来对上述代码进行优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">XFetch</span>(<span class="params">request</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, request.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>, <span class="variable language_">this</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> error = &#123;</span><br><span class="line">                        <span class="attr">code</span>: <span class="variable language_">this</span>.<span class="property">status</span>,</span><br><span class="line">                        <span class="attr">response</span>: <span class="variable language_">this</span>.<span class="property">response</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_">reject</span>(error, <span class="variable language_">this</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，调用XFetch()函数会返回一个Promise对象，然后就可以使用Promise.then()方法继续发起请求了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x1 = <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org/?category&#x27;</span>))</span><br><span class="line"><span class="keyword">var</span> x2 = x1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://www.geekbang.org/column&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> x3 = x2.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line">x3.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="深入Promise"><a href="#深入Promise" class="headerlink" title="深入Promise"></a>深入Promise</h4><p>Promise用法大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    ...</span><br><span class="line">    <span class="title function_">reject</span>()</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>按照Promise的语法，resolve()函数的调用会触发p.then()方法，因此，可以推测<strong>resolve函数内部调用了p.then()设置的回调函数</strong>，但是，如果真的是我们所猜测的这样，resolve()执行的时候，p.then()还没有绑定回调函数，这又应当作何解释呢？</p>
<p>答案就是<strong>Promise采用了回调函数延迟绑定技术</strong>，即在执行resolve函数时，由于回调函数还没有绑定到then()上，因此只能推迟回调函数的执行。</p>
<p>下面我们简单自己实现一个支持延时回调的类Promise对象（Bromise）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Bromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> onResolve_ = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> onReject_ = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 给Bromise对象绑定一个then方法，类似于Promise对象的then方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolve, onReject</span>) &#123;</span><br><span class="line">        onResolve_ = onResolve</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在resolve内部必定要执行demo.then()绑定的onResolve()函数，因此让resolve中的onResolve_()函数延后执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">onResolve_</span>(value)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// onResolve_(value)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> <span class="title class_">Bromise</span>(executor)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">demo.<span class="title function_">then</span>(onResolve)</span><br></pre></td></tr></table></figure>

<p>实际上，由于定时器的效率不是很高，因此Promise将这个定时器改造成了微任务，进一步提升了代码执行效率。</p>
<h3 id="async与await——同步代码书写异步操作"><a href="#async与await——同步代码书写异步操作" class="headerlink" title="async与await——同步代码书写异步操作"></a>async与await——同步代码书写异步操作</h3><p>先来看一段Promise异步操作代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org/test&#x27;</span>)</span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<p>虽然和回调地狱相比，Promise已然改进了不少了，但是promise.then()方法的链式调用也显得代码有一点凌乱。因此，我们引入ES7的新语法特性——async&#x2F;await——它支持我们在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response1)</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org/test&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response2)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>



<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>在进一步学习async&#x2F;await之前，我们需要先了解生成器函数。</p>
<blockquote>
<p>生成器函数：</p>
<ol>
<li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li>
<li>外部函数可以通过 next 方法恢复函数的执行。</li>
</ol>
<p>为了理解生成器函数的实现原理，这里简单介绍一个概念——协程。简单而言，协程是跑在线程上的任务，是一种比线程更加轻量级的存在。虽然一个线程上可以存在多个协程，但是同时只能执行一个协程。</p>
</blockquote>
<p>通过生成器配合Promise改造代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response1);</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org/test&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行foo函数的代码，创建gen协程</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">foo</span>()</span><br><span class="line"><span class="comment">// 继续执行foo函数，将主线程控制权交给gen协程</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGenPromise</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gen.<span class="title function_">next</span>().<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getGenPromise</span>(gen).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getGenPromise</span>(gen)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其实，async、await的底层原理就是生成器与Promise。</p>
<h4 id="神奇的语法糖"><a href="#神奇的语法糖" class="headerlink" title="神奇的语法糖"></a>神奇的语法糖</h4><p>async、await两个关键字其实是语法糖，虽然看起来很简洁，实际上它们完成的工作量并不小。</p>
<ul>
<li>async：修饰函数，使之成为async函数，该函数通过异步执行并<strong>隐式返回Promise</strong>作为结果</li>
<li>await：顾名思义，它将“等待”一个Promise对象（或者其他值），如果是Promise对象，就返回其处理结果，如果是其他值，就返回其本身。<strong>await将会暂停当前async函数的执行，等待Promise的处理完成，此时主线程控制权转交给父协程，同时Promise也会进行处理</strong>。</li>
</ul>
<p>请看下面一个简单的示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="number">100</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">/*运行结果为：</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>主线程中，0首先被打印；程序进入foo()，打印1，let a &#x3D; await 100，则当前async函数被停止，程序继续往下执行，即打印3，同时由于100并不是Promise对象，故a就是100本身，只不过会经过Promise处理，故在3打印后，100被打印，接着再继续执行foo，打印2。</p>
<h2 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a>浏览器中的页面</h2><h3 id="开发者工具——网络面板"><a href="#开发者工具——网络面板" class="headerlink" title="开发者工具——网络面板"></a>开发者工具——网络面板</h3><p>我们重点来了解一下网络面板的时间线面板（Timing）。</p>
<p>打开网络面板（Network），在详细列表中点击某一个任务，可以发现该项的详细信息（Headers、Preview、Response、Timing），打开Timing，我们会发现如下选项：</p>
<ul>
<li>Queueing：浏览器发起一个请求时，有多种原因导致其不能被立即执行而进入排队等待状态，比如<ul>
<li>页面中资源具有优先级，图片、视频等资源优先级就比较低；</li>
<li>浏览器为每一个域名最多维护6个TCP连接；</li>
<li>网络进程为数据分配磁盘空间时，新的HTTP请求需要短暂地等待磁盘分配结果</li>
</ul>
</li>
<li>Stalled：等待排队完成后、发起连接之前，可能有一些原因导致连接过程被推迟，这就是Stalled，停滞</li>
<li>Initial connection&#x2F;SSL：和服务器建立连接</li>
<li>Request sent：网络进程发送请求，这个阶段很快</li>
<li>Waiting（TTFB）：也称第一字节时间，是反映服务端响应速度的重要指标，指等待接收服务器第一个字节数据</li>
<li>Content Download：陆续接收完整数据</li>
</ul>
<h3 id="DOM树与JavaScript"><a href="#DOM树与JavaScript" class="headerlink" title="DOM树与JavaScript"></a>DOM树与JavaScript</h3><h4 id="DOM树的生成简介"><a href="#DOM树的生成简介" class="headerlink" title="DOM树的生成简介"></a>DOM树的生成简介</h4><p>我们知道，在使用浏览器访问网页时，是由浏览器先向服务器发起网络请求，拿到网页源代码，然后生成各式各样的网页，供给客户端查看。从进程角度看，这涉及了两个重要的进程——网络进程、渲染进程。</p>
<p>网络进程和渲染进程之间会建立一个共享数据的管道，网络进程将拿到的数据放进该管道，而另一边的渲染进程则从管道的另外一端不断地读取数据，将其丢给HTML解析器，由其生成DOM。</p>
<blockquote>
<p>其实，网络进程拿过来的数据是字节流形式的，可以理解为页面源代码，也就是说，HTML解析器拿到的第一手数据也是字节流，需要先将字节流转化为Token，再将Token转化为DOM节点，并添加到DOM树上。</p>
</blockquote>
<p>第一部分，HTML解析器会维护一个Token栈，用以保存当前解析到的标签。</p>
<ul>
<li>如果解析到的是StartToken，就将其入栈，同时为该Token创建一个DOM节点；</li>
<li>如果解析到的是一个TextToken，不用入栈，直接创建文本节点，加入到DOM树中；</li>
<li>如果解析到的是EndToken，此时与栈顶元素匹配，将栈顶元素（StartToken）弹出，表示该元素标签封闭，解析完成。</li>
</ul>
<h4 id="JavaScript会阻塞DOM的生成"><a href="#JavaScript会阻塞DOM的生成" class="headerlink" title="JavaScript会阻塞DOM的生成"></a>JavaScript会阻塞DOM的生成</h4><p>网络进程传输给渲染进程的字节流中不一定全部都是html代码，也可能包括JavaScript脚本代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="language-javascript">    div1.<span class="property">innerText</span> = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当HTML解析器解析到script标签时，会发现这是JavaScript代码，由于它有可能操作DOM，因此HTML解析器停止解析，转而由JavaScript引擎介入，在执行JavaScript代码（修改了文本节点的内容）后，HTML解析器恢复解析，继续工作。</p>
<p>那如果拿到的JavaScript代码以文件形式被引入呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;foo.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，JavaScript文件需要被下载，该下载过程会阻塞HTML的解析。Chrome对此做出的优化是，在渲染引擎收到字节流后，就会开启一个预解析线程，用于下载HTML中包含的JavaScript、CSS等相关文件。</p>
<h4 id="CSS样式表文件会阻塞JavaScript的执行"><a href="#CSS样式表文件会阻塞JavaScript的执行" class="headerlink" title="CSS样式表文件会阻塞JavaScript的执行"></a>CSS样式表文件会阻塞JavaScript的执行</h4><p>那接下来我们再来分析另外一种情况。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">src</span>=<span class="string">&#x27;theme.css&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="language-javascript">            div1.<span class="property">innerText</span> = <span class="string">&#x27;time.geekbang&#x27;</span> <span class="comment">// 需要 DOM</span></span></span><br><span class="line"><span class="language-javascript">            div1.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>  <span class="comment">// 需要 CSSOM</span></span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在script标签中，出现了操作css样式的JavaScript代码，也就是说在执行JavaScript之前，还需要解析所有的CSS样式。</p>
<p>但是实际上，JavaScript引擎在解析JavaScript之前，并不知道JavaScript是否操作了CSSOM，因此渲染引擎在遇到JavaScript脚本时，不论其是否操作CSSOM，都会执行CSS文件下载、解析CSS，然后再执行JavaScript脚本。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>如下代码，分析浏览器中的运行情况。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="language-javascript">    div1.<span class="property">innerText</span> = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div2 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)[<span class="number">1</span>]</span></span><br><span class="line"><span class="language-javascript">    div2.<span class="property">innerText</span> = <span class="string">&#x27;time.geekbang.com&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之前提到过，JavaScript会阻塞DOM树的生成，因此HTML解析器解析到script标签的时候，会停止解析，交给JavaScript引擎。而此时DOM树中仅有一个div节点，因此div1有值，div2并不会拿到值，进而拿不到它的innerText属性，会报错。</p>
<p>JavaScript引擎将JavaScript代码执行完毕后，HTML解析器继续执行，将剩余的div解析出来，但是文本内容就是test，不会被改变。</p>
<h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><h4 id="显示器显示图像"><a href="#显示器显示图像" class="headerlink" title="显示器显示图像"></a>显示器显示图像</h4><p>显示器每秒固定读取一定次数前缓冲区的图像到显示器上，而显卡的职责是合成新的图像，并将图像保存到后缓冲区中，之后系统会让后缓冲区和前缓冲区互换，保证显示器能够读取最新显卡合成的图像。这样一来，通常情况下，显卡的更新频率和显示器的刷新频率一致。</p>
<h4 id="帧与帧率"><a href="#帧与帧率" class="headerlink" title="帧与帧率"></a>帧与帧率</h4><p>我们把渲染流水线生成的每一幅图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率。</p>
<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>当DOM结构较为复杂时，不断地修改DOM树会导致重排、重绘等操作，给渲染器增加负担。因此，虚拟DOM的出现，就是想尽可能地减少对真实DOM的操作次数。</p>
<h4 id="虚拟DOM用来干什么"><a href="#虚拟DOM用来干什么" class="headerlink" title="虚拟DOM用来干什么"></a>虚拟DOM用来干什么</h4><p>虚拟DOM其实可以理解为真实DOM之前的一个存在，在页面数据发生变化时，先重新创建出新的虚拟DOM树，然后与旧的DOM树进行比较，将变化的节点一次性全部应用到真实DOM树上，完成修改。</p>
<h4 id="从双缓存视角看虚拟DOM"><a href="#从双缓存视角看虚拟DOM" class="headerlink" title="从双缓存视角看虚拟DOM"></a>从双缓存视角看虚拟DOM</h4><p>缓冲区其实是一个方便计算机快速处理的机制。但有时候，如果将数据一部分一部分地写入缓冲区，就会导致页面上的信息一块一块地显示出来，带给用户不良的体验。因此，<strong>双缓存</strong>发挥了优势：<br>先将计算的中间结果存放在另一个缓冲区中，待全部计算结束，缓冲区已经存储了完整的数据之后（比如完整的图像数据信息），一次性复制到显示缓冲区，这样就会使得整个数据输出十分稳定。<br>这里的虚拟DOM就是一种类似双缓存的机制。</p>
<h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><ul>
<li>M：model，模型，可以理解为数据</li>
<li>V：view，视图，可以理解为人眼看到的画面</li>
<li>C：controller，控制器，是连接model与view的枢纽</li>
</ul>
<p>通过MVC模式来看，</p>
<ul>
<li>虚拟DOM实际上是MVC的<strong>视图</strong>部分，因为它将涉及后续视图的更新</li>
<li>控制器用于监视DOM的变化，一旦DOM变化了，控制器就会通知模型，让其更新（update）数据</li>
<li>模型数据更新好后，控制器会通知视图，告知（notify）其数据模型已经变化</li>
<li>视图收到消息，会根据新的数据来生成新的虚拟DOM</li>
<li>新的虚拟DOM一旦生成，会与旧的虚拟DOM进行比较，将变化的节点应用到真实DOM上</li>
</ul>
<h3 id="WebComponent——组件化"><a href="#WebComponent——组件化" class="headerlink" title="WebComponent——组件化"></a>WebComponent——组件化</h3><p>组件可以理解为具有某一个特定功能的“工具”，它高内聚、低耦合，在多人协作开发中可以被方便地复用，极大地提高了开发效率。</p>
<p>对于大多数编程语言，都可以实现组件化——凭借其类、作用域等特性，实现模块的封装等等，JavaScript也不例外。但是，在前端开发中，仍然存在着阻碍组件化开发的因素。</p>
<ul>
<li>CSS对标签属性的控制：css代码的标签选择器对全局标签进行选择，并设置属性，这样一来，不同开发人员编写的某一元素的样式可能会被全部修改。</li>
<li>DOM的阻碍：全局DOM只有一个，但是任意一个地方都可以修改DOM。</li>
</ul>
<p>对此，WebComponent提出了解决思路，提供了对局部视图封装能力——Web Components技术，它由三项主要技术组成：</p>
<ul>
<li>自定义元素（Custom elements）：一组JavaScript API</li>
<li>影子DOM（Shadow DOM）：一组JavaScript API，将封装的影子DOM树附加到元素（与主文档DOM分开呈现），这样可以保持元素功能私有</li>
<li>HTML模板（HTML templates）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;geekbang-t&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-color</span>: brown;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>: coral;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-color</span>: bisque;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">border</span>: <span class="number">3px</span> solid chocolate;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>time.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>time1.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inner log&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">class</span> <span class="title class_">GeekBang</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">super</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 这里的content就是template下所有的html内容</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#geekbang-t&#x27;</span>).<span class="property">content</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> shadowDOM = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(shadowDOM);</span></span><br><span class="line"><span class="language-javascript">                shadowDOM.<span class="title function_">appendChild</span>(content.<span class="title function_">cloneNode</span>(<span class="literal">true</span>))</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        customElements.<span class="title function_">define</span>(<span class="string">&#x27;geek-bang&#x27;</span>, <span class="title class_">GeekBang</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">geek-bang</span>&gt;</span><span class="tag">&lt;/<span class="name">geek-bang</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>time.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>time1.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geek-bang</span>&gt;</span><span class="tag">&lt;/<span class="name">geek-bang</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要使用Web Component，通常要实现下面三个步骤：</p>
<ol>
<li><p>使用template属性来创建模板。实际上，模板元素内容并不会被渲染到页面上，也就是说template节点不会出现在布局树中。</p>
</li>
<li><p>创建一个GeekBang类。这个类的构造函数中完成三件事：</p>
<ul>
<li>查找模板内容</li>
<li>创建影子DOM</li>
<li>再将模板添加到影子DOM上</li>
</ul>
<blockquote>
<p>影子DOM，将模板中的内容与全局DOM和CSS进行隔离，实现元素和样式的私有化。</p>
</blockquote>
</li>
<li><p>上面两步实现后，就可以像正常使用HTML元素一样使用该元素，如&lt;geek-bang&gt;&lt;&#x2F;geek-bang&gt;</p>
</li>
</ol>
<h2 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a>浏览器中的网络</h2><h3 id="HTTP性能优化"><a href="#HTTP性能优化" class="headerlink" title="HTTP性能优化"></a>HTTP性能优化</h3><blockquote>
<p>HTTP是浏览器最重要且使用最多的协议，是浏览器和服务器之间的通信语言。随着互联网的发展，HTTP也在持续进化。</p>
</blockquote>
<h4 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h4><p>用途较为简单，主要用于学术交流，需求也很简单，只需要在网络之间传递HTML超文本内容，故称“超文本传输协议”。</p>
<ul>
<li>客户端根据IP地址、端口、服务器建立TCP连接，涉及TCP协议三次握手过程；</li>
<li>TCP连接建立完成后，发送应该GET请求行信息，如<code>GET /index.html</code>用来获取index.html；</li>
<li>服务器接收请求信息之后，读取对应的HTML文件，并将数据以ASCII字符流返回给客户端；</li>
<li>传输完成，连接断开。</li>
</ul>
<h4 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>万维网的高速发展带来了很多新需求，HTTP&#x2F;0.9已经不再适用于新的网络发展了。新的需求包括：</p>
<ul>
<li>浏览器中展示的不单单是HTML文件了，还有JavaScript、CSS、图片、音视频等不同类型的文件。</li>
<li>文件格式不仅仅局限于ASCII编码，还有很多其他类型编码的文件。</li>
</ul>
<p>为了<strong>支持对多种类型文件的下载</strong>，HTTP&#x2F;1.0引入了<strong>请求头和响应头</strong>，也就是说，在HTTP发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。</p>
<blockquote>
<p>HTTP&#x2F;1.0通过请求头、响应头支持多种不同类型的数据的原理：</p>
<p>HTTP在发起请求时候会通过HTTP<strong>请求头</strong>告诉服务器它期待服务器</p>
<ul>
<li>返回什么类型的文件</li>
<li>采取什么形式的压缩</li>
<li>提供什么语言的文件以及编码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accept</span>: text/html	<span class="comment">// 期望浏览器返回html类型文件</span></span><br><span class="line">accept-<span class="attr">encoding</span>: gzip, deflate, br	<span class="comment">// 期望浏览器采用gzip、deflate或者br压缩方式</span></span><br><span class="line">accept-<span class="title class_">Charset</span>: <span class="variable constant_">ISO</span>-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>	<span class="comment">// 期望返回的文件编码是UTF-8或者ISO-8859-1</span></span><br><span class="line">accept-<span class="attr">language</span>: zh-<span class="variable constant_">CN</span>,zh	<span class="comment">// 期望页面的优先语言是中文</span></span><br></pre></td></tr></table></figure>

<p>服务器接收到浏览器发送过来的请求头信息之后，就会根据请求头的信息准备响应数据，并将相关信息以响应头形式反馈给客户端浏览器（按要求做事情，并给出反馈）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content-<span class="attr">encoding</span>: br	<span class="comment">// 服务器采用了br压缩方法</span></span><br><span class="line">content-<span class="attr">type</span>: text/html; charset=<span class="variable constant_">UTF</span>-<span class="number">8</span>	<span class="comment">// 服务器返回html文件，编码类型为UTF-8</span></span><br></pre></td></tr></table></figure>

<p>拿到如上的服务器响应头信息后，最终浏览器需要根据响应头的信息来处理数据。</p>
</blockquote>
<p>此外，HTTP&#x2F;1.0还引入了很多其他的特性，比如</p>
<ul>
<li>状态码——通过响应行的方式通知浏览器，服务器最终处理情况</li>
<li>Cache机制——缓存已经下载过的数据，减轻服务器压力</li>
<li>用户代理字段——服务器需要统计客户端的基础信息</li>
</ul>
<h4 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>相比于HTTP&#x2F;1.0，1.1有如下方面的改进：</p>
<ul>
<li>改进持久连接</li>
</ul>
<p>在HTTP&#x2F;1.0中，一次HTTP通信，需要经历<strong>建立TCP连接、传输HTTP数据和断开TCP连接</strong>三个阶段。但是随着单个页面中文件数量增多，每一次下载文件都需要重复这三个步骤，无疑会增加大量开销。</p>
<p>对此，HTTP&#x2F;1.1中增加了持久连接，在应该TCP连接上可以传输多个HTTP请求，只要浏览器或者服务器没有断开连接，该TCP连接会一直保持。</p>
<p>另外，浏览器为每个域名最多同时维护6个TCP持久连接。</p>
<ul>
<li>不成熟的HTTP管线化</li>
</ul>
<p>TCP通道中一旦某个请求因为某些原因没有及时返回，就会阻塞后面的所有请求——队头阻塞问题。对此，HTTP&#x2F;1.1中试图引入管线化技术来解决队头阻塞问题。</p>
<ul>
<li>引入客户端Cookie与安全机制</li>
</ul>
<p>但是，HTTP&#x2F;1.1仍然有很大的不足，核心问题在于<strong>对带宽的利用率并不理想</strong>。</p>
<blockquote>
<p>带宽，是指每秒最大能够发送或者接收的字节数。每秒能够发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p>
</blockquote>
<p>原因主要有三点：</p>
<ol>
<li>TCP慢启动。TCP连接建立之后，会进入发送数据状态，刚开始TCP协议会采用应该非常慢的速度去发送数据。</li>
<li>同时开启多条TCP连接会竞争固定的带宽。</li>
<li>HTTP&#x2F;1.1的队头阻塞问题。</li>
</ol>
<h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>那么如何解决HTTP&#x2F;1.1的问题呢？</p>
<p>我们先分析上面的三点原因，会发现，第一条、第二条是TCP本身的机制引起的，第三条是HTTP&#x2F;1.1的机制导致的。</p>
<p>因此，HTTP&#x2F;2的思路就是<strong>一个域名只使用一个TCP长连接来传输数据</strong>，这样整个页面资源的下载过程只需要一次慢启动，也不会有多个TCP连接竞争问题。</p>
<p>此外，HTTP&#x2F;2最核心的功能是<strong>多路复用机制</strong>——引入二进制分帧层，实现了资源的并行传输。</p>
<p>当然，HTTP&#x2F;2还有一些其他特性，比如</p>
<ul>
<li>可以设置请求的优先级：在发送请求时，可以标上该请求的优先级</li>
<li>服务器推送：直接将数据提前推送到浏览器</li>
<li>头部压缩：对请求头和响应头都进行了压缩</li>
</ul>
<h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="Web页面安全"><a href="#Web页面安全" class="headerlink" title="Web页面安全"></a>Web页面安全</h3><p>Web页面安全的意义在于可以保障我们的隐私和数据的安全。</p>
<p>Web页面安全中最基础、最核心的安全策略——同源策略。</p>
<p>同源是针对URL而言的，<strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源</strong>。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//time.geekbang.org/?category=1</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>

<p>而同源策略就是，两个不同的源之间如果想要互相访问资源或者操作DOM，就会有一套基础的安全策略的制约。</p>
<p>同源策略会隔离不同源的DOM、页面数据和网络通信，进而实现Web页面的安全性。</p>
<p>但是，安全性和便利性是相互对立的。对此浏览器出让一些安全性来满足灵活性，以方便Web开发。浏览器出让了同源策略的哪些安全性呢？</p>
<ol>
<li>页面中可以嵌入第三方资源</li>
</ol>
<p>最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。最多的问题是，浏览器的首页内容会被一些恶意程序劫持，其中，最常见的是恶意程序通过各种途径往HTML文件中插入恶意脚本。</p>
<p>对此，我们引入了CSP策略来加以限制。</p>
<ol start="2">
<li>跨域资源共享和跨文档消息机制</li>
</ol>
<p>跨域资源共享，CORS，允许进行跨域访问控制；</p>
<p>跨文档消息机制，允许两个不同源的DOM之间进行通信。</p>
<h3 id="跨站脚本攻击——XSS攻击"><a href="#跨站脚本攻击——XSS攻击" class="headerlink" title="跨站脚本攻击——XSS攻击"></a>跨站脚本攻击——XSS攻击</h3><h4 id="XSS攻击以及危害"><a href="#XSS攻击以及危害" class="headerlink" title="XSS攻击以及危害"></a>XSS攻击以及危害</h4><p>首先我们需要知道什么是XSS。XSS，Cross Site Scripting，为了区分于CSS，故称XSS，意为“跨站脚本”。<strong>所谓XSS攻击，指黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段</strong>。</p>
<p>HTML文件中注入恶意代码会给用户带来很多危害。比如</p>
<ul>
<li><p>窃取Cookie信息。</p>
<p>恶意的JavaScript通过document.cookie来获取Cookie信息，然后通过XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器。恶意服务器一旦拿到用户的Cookie信息，也即掌握了用户的账户等隐私信息，几乎可以为所欲为。</p>
</li>
<li><p>监听用户行为。</p>
<p>恶意JavaScript通过addEventListener接口来监听键盘事件，比如可以获取用户输入的信用卡等信息。</p>
</li>
<li><p>伪造假的登录窗口。</p>
<p>恶意代码修改DOM，属于欺骗用户行为。</p>
</li>
<li><p>生成浮窗广告。</p>
</li>
</ul>
<h4 id="恶意脚本的注入"><a href="#恶意脚本的注入" class="headerlink" title="恶意脚本的注入"></a>恶意脚本的注入</h4><p>要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式：</p>
<ul>
<li>存储型XSS攻击</li>
<li>反射型XSS攻击</li>
<li>基于DOM的XSS攻击</li>
</ul>
<h5 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h5><ul>
<li>黑客首先利用站点漏洞，将一段恶意JavaScript代码提交到网站的数据库中</li>
<li>用户向网站请求包含了恶意JavaScript脚本的页面</li>
<li>用户浏览该页面，恶意脚本上传用户的Cookie等信息</li>
</ul>
<h5 id="反射型xss攻击"><a href="#反射型xss攻击" class="headerlink" title="反射型xss攻击"></a>反射型xss攻击</h5><p>恶意JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又把JavaScript脚本返回给用户了。</p>
<p><strong>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方</strong>。</p>
<h5 id="基于DOM的XSS攻击"><a href="#基于DOM的XSS攻击" class="headerlink" title="基于DOM的XSS攻击"></a>基于DOM的XSS攻击</h5><p>不牵涉页面Web服务器，具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如网络劫持等。</p>
<h4 id="阻止XSS攻击"><a href="#阻止XSS攻击" class="headerlink" title="阻止XSS攻击"></a>阻止XSS攻击</h4><p>无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。所以要阻止 XSS 攻击，<strong>我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现</strong>。</p>
<ul>
<li><p>服务器对输入脚本进行过滤或者转码</p>
</li>
<li><p>充分利用CSP</p>
<blockquote>
<p>CSP，Content Security Policy，即内容安全策略，其主要目标是减少和报告XSS攻击。其实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以被加载和执行（提供白名单）。</p>
</blockquote>
</li>
<li><p>使用HttpOnly属性</p>
<p>使用HttpOnly标记的Cookie只能使用在HTTP请求过程中，无法通过JavaScript来读取（document.cookie）。</p>
</li>
</ul>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF，Cross-site request forgery，又称“跨站请求伪造”，指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</p>
<h3 id="页面安全和操作系统安全"><a href="#页面安全和操作系统安全" class="headerlink" title="页面安全和操作系统安全"></a>页面安全和操作系统安全</h3><h4 id="初代浏览器的架构"><a href="#初代浏览器的架构" class="headerlink" title="初代浏览器的架构"></a>初代浏览器的架构</h4><p>最开始的阶段浏览器是单进程的，JavaScript执行、网络加载、UI绘制等过程都是在同一个进程中执行的，如此简单的结构却也带来了很多问题。首先，就是单进程架构的浏览器并不稳定。</p>
<p>浏览器进程中任意一个功能出现异常，都有可能影响到整个浏览器。而如果浏览器存在漏洞，黑客有可能通过恶意的页面向浏览器中注入恶意程序，不仅如此，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入以及读取硬盘上的文件内容。</p>
<h4 id="现代浏览器的两个核心模块"><a href="#现代浏览器的两个核心模块" class="headerlink" title="现代浏览器的两个核心模块"></a>现代浏览器的两个核心模块</h4><p>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程分离开来。浏览器被划分为</p>
<ul>
<li>浏览器内核<ul>
<li>网络进程</li>
<li>浏览器主进程</li>
<li>GPU进程</li>
</ul>
</li>
<li>渲染内核<ul>
<li>渲染进程</li>
</ul>
</li>
</ul>
<p>当我们打开一个页面时，这两个模块就会互相配合。</p>
<ul>
<li>首先，浏览器内核会下载所有的网络资源，下载后的资源会通过IPC将其提交给渲染进程（IPC是浏览器内核和渲染进程的通信通道）；</li>
<li>然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片；</li>
<li>这张生成的图片会被提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</li>
</ul>
<h4 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h4><p>渲染进程执行下载的各种网络资源时，需要十分小心，否则容易执行恶意程序，进而被黑客攻击。对此，我们需要在渲染进程和操作系统之间建立一道墙，即使渲染进程由于存在漏洞被黑客攻击，但由于这道墙的存在，黑客获取不到渲染进程之外的任何操作权限——这道墙就是安全沙箱。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2022/02/10/%E6%B5%8F%E8%A7%88%E5%99%A8/" data-id="cl17apw37003wicud4qfvdq3s" data-title="浏览器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/mid-lake-pavilion.github.io/2022/02/10/ES%E6%96%B0%E7%89%B9%E6%80%A71/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ES新特性1
        
      </div>
    </a>
  
  
    <a href="/mid-lake-pavilion.github.io/2022/02/06/Flask%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Flask基础</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/CF/">CF</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Java程序设计</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Web%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">Web前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/">前端之路</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E5%86%A5%E6%83%B3/">多一点冥想</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/">数字逻辑设计</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E8%8A%B1%E9%97%B4%E4%B8%80%E5%A3%B6%E9%85%92/">花间一壶酒</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF/">面向对象建模技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" rel="tag">大学课程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/mid-lake-pavilion.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" style="font-size: 20px;">大学课程</a> <a href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/hello/">hello</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">概念结构设计</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/24/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript的正则表达式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/mid-lake-pavilion.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/mid-lake-pavilion.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/mid-lake-pavilion.github.io/js/jquery-3.4.1.min.js"></script>



  
<script src="/mid-lake-pavilion.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/mid-lake-pavilion.github.io/js/script.js"></script>





  </div>
</body>
</html>