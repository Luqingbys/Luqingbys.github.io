<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>教材典型算法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="树树的遍历算法 先序遍历  12345678910void Preorder(BiTree T, void (*visit)(TElemType&amp; e))&amp;#123;    if(T)    &amp;#123;        visit(T-&gt;data); &#x2F;&#x2F; 先访问根结点        &#x2F;&#x2F; 再递归访问左子树和柚子树        Preorder(T-&gt;lchild, visi">
<meta property="og:type" content="article">
<meta property="og:title" content="教材典型算法">
<meta property="og:url" content="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/11/27/%E6%95%99%E6%9D%90%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="树树的遍历算法 先序遍历  12345678910void Preorder(BiTree T, void (*visit)(TElemType&amp; e))&amp;#123;    if(T)    &amp;#123;        visit(T-&gt;data); &#x2F;&#x2F; 先访问根结点        &#x2F;&#x2F; 再递归访问左子树和柚子树        Preorder(T-&gt;lchild, visi">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-27T01:32:47.000Z">
<meta property="article:modified_time" content="2021-11-27T04:58:30.340Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/mid-lake-pavilion.github.io/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/mid-lake-pavilion.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/mid-lake-pavilion.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/mid-lake-pavilion.github.io/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/mid-lake-pavilion.github.io/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/mid-lake-pavilion.github.io/">Home</a>
        
          <a class="main-nav-link" href="/mid-lake-pavilion.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/mid-lake-pavilion.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://luqingbys.github.io/mid-lake-pavilion.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-教材典型算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/11/27/%E6%95%99%E6%9D%90%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-11-27T01:32:47.000Z" itemprop="datePublished">2021-11-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      教材典型算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的遍历算法"><a href="#树的遍历算法" class="headerlink" title="树的遍历算法"></a>树的遍历算法</h3><ol>
<li>先序遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(BiTree T, <span class="type">void</span> (*visit)(TElemType&amp; e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;data); <span class="comment">// 先访问根结点</span></span><br><span class="line">        <span class="comment">// 再递归访问左子树和柚子树</span></span><br><span class="line">        <span class="built_in">Preorder</span>(T-&gt;lchild, visit);</span><br><span class="line">        <span class="built_in">Preorder</span>(T-&gt;rchild, visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序、中序、后序遍历算法思路几乎完全一致，不再赘述。<br>2. 中序遍历的非递归描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于中序遍历一棵二叉树，第一个要访问的根结点一定是最左边的结点</span></span><br><span class="line"><span class="comment">// 因此，GoFarLeft函数的功能就是对二叉树T，寻找最左边的结点</span></span><br><span class="line"><span class="comment">// 同时，用一个栈S保存每一次的根结点，它是中序遍历的中间访问者</span></span><br><span class="line"><span class="function">BiTNode *<span class="title">GoFarLeft</span><span class="params">(BiTree T, Stack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 代表当前根结点不存在了，返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!T)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 当前根结点有左子树，往左继续寻找</span></span><br><span class="line">    <span class="keyword">while</span>(T-&gt;lchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, T);</span><br><span class="line">        T = T-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归的中序遍历算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder_I</span><span class="params">(BiTree T, <span class="type">void</span> (*visit)(TelemType&amp; e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack *S;</span><br><span class="line">    t = <span class="built_in">GoFarLeft</span>(T, S);    <span class="comment">// 寻找最左下边的结点</span></span><br><span class="line">    <span class="comment">// 每一次循环，访问一个结点</span></span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">visit</span>(t-&gt;data);</span><br><span class="line">        <span class="comment">// 如果t有柚子树，就得继续遍历柚子树，用相同的方式</span></span><br><span class="line">        <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">            t = <span class="built_in">GoFarLeft</span>(t-&gt;rchild, S);</span><br><span class="line">        <span class="comment">// t没有柚子树，t本来就没有左子树，则应该访问其父结点了，S中存放了结点路径</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">            t = <span class="built_in">Pop</span>(S);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归。<br>3. 求二叉树的深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)  depthval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        depthLeft = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">        depthRight = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">        depthval = (depthLeft &gt; depthRight ? depthLeft : depthRight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depthval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求深度。<br>4. 建树<br>已知一棵二叉树的先序遍历和中序遍历，还原这棵二叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CrtBT</span><span class="params">(BiTree&amp; T, <span class="type">char</span> pre[], <span class="type">char</span> ino[], <span class="type">int</span> ps, <span class="type">int</span> is, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)  T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">Search</span>(ino, pre[ps]);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">            T-&gt;data = pre[ps];</span><br><span class="line">            <span class="keyword">if</span>(k == is) T-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">CrtBT</span>(T-&gt;Lchild, pre[], ino[], ps+<span class="number">1</span>, is, k - is);</span><br><span class="line">            <span class="keyword">if</span>(k == is+n<span class="number">-1</span>) T-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">CrtBT</span>(T-&gt;Rchild, pre[], ino[], ps+<span class="number">1</span>+(k-is), k+<span class="number">1</span>, n-(k-is)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>555<br>5. 二叉树按层次遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LevelOrderTravel</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">if</span>(T)   <span class="built_in">Enqueue</span>(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dequeue</span>(Q, &amp;E);</span><br><span class="line">        <span class="built_in">visit</span>(E);</span><br><span class="line">        <span class="keyword">if</span>(E-&gt;lchild)   <span class="built_in">EnQueue</span>(Q, E-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(E-&gt;rchild)   <span class="built_in">EnQueue</span>(Q, E-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTravel</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v &lt; G.Vexnum; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v &lt; G.Vexnum; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span>();</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][w].adj != <span class="number">0</span> &amp;&amp; !visited[w])</span><br><span class="line">            <span class="built_in">DFS</span>(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求各顶点入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final[]记录当前结点是否已经求出最短路径</span></span><br><span class="line"><span class="comment">// D[]记录当前所找的源点到每一个终点的最短路径长度</span></span><br><span class="line"><span class="comment">// P[]记录路径</span></span><br><span class="line"><span class="comment">// v0表示初始单源点起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G, <span class="type">int</span> v0, <span class="type">int</span> &amp;P, <span class="type">float</span> &amp;D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j,v,w,min,<span class="keyword">final</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span>[v] = FALSE;</span><br><span class="line">        D[v] = G.arcs[v0][v];</span><br><span class="line">        P[v] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[v] &lt; INFINITY) P[v] = v0;</span><br><span class="line">        <span class="keyword">final</span>[v0] = TRUE;</span><br><span class="line">        P[v0] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定下一次的出发点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要找到当前还未确定最小路径长度的最小值</span></span><br><span class="line">        min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">final</span>[w])</span><br><span class="line">            <span class="keyword">if</span>(D[w] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                v = w;</span><br><span class="line">                min = D[w];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span>[v] = TRUE;    <span class="comment">// 一旦确定了最小值，那么源点到它的最短路径也就确定了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以这次的顶点v为起始点，进行最短路径的更新</span></span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">final</span>[w] &amp;&amp; (min+G.arcs[v][w] &lt; D[w]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对满足条件的顶点，更新需要更新最短路径和最短路径长</span></span><br><span class="line">            D[w] = min + G.arcs[v][w].adj;</span><br><span class="line">            P[w] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">// 从第二项开始排序</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每一次排序前面的都已经排序好了</span></span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key &lt; L.r[i<span class="number">-1</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];    <span class="comment">// 复制为监视哨</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; L.r[<span class="number">0</span>].key &lt; L.r[j].key; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>] = L.r[j];  <span class="comment">// 记录后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>] = L.r[<span class="number">0</span>];  <span class="comment">// 插入到正确的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KeyType pivotkey;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">    pivotkey = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从高位开始遍历，确保元素都大于枢轴</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)</span><br><span class="line">            --high;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从地位开始遍历，确保元素都小于枢轴</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[low].key &lt;= povotkey)</span><br><span class="line">            ++low;</span><br><span class="line">        L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">// 返回枢轴最后的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotloc;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        pivotloc = <span class="built_in">Partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>筛选算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整堆结构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="type">int</span> s, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    RedType rc;</span><br><span class="line">    rc = H.r[s];    <span class="comment">// 将堆顶元素暂存下来到rc</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s; j &lt;= m; j*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 横比，j初始值指向左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; H.r[j].key &lt; H.r[j+<span class="number">1</span>].key)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="comment">// 纵比，如果右孩子比父节点小，表示该堆不需要调整</span></span><br><span class="line">        <span class="keyword">if</span>(rc.key &gt;= H.r[j].key)    <span class="keyword">break</span>;</span><br><span class="line">        H.r[s] = H.r[j];</span><br><span class="line">        s = j;</span><br><span class="line">        <span class="comment">// j*=2,表示进入下一个堆结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RcdType SR[], RcdType &amp;TR[], <span class="type">int</span> i, <span class="type">int</span> m, in t n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = m+<span class="number">1</span>, k=i; i &lt;= m &amp;&amp; j &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SR[i].key &lt; SR[i].key)</span><br><span class="line">            TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m)   TR[k++] = SR[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n)   TR[k++] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MSort</span><span class="params">(RcdType SR[], RcdType &amp;TR[], <span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t)    TR[s] = SR[s];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (s+t)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MSort</span>(SR, TR2, s, m);</span><br><span class="line">        <span class="built_in">MSort</span>(SR, TR2, m+<span class="number">1</span>, t);</span><br><span class="line">        <span class="built_in">Merge</span>(TR2, TR, s, m, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/11/27/%E6%95%99%E6%9D%90%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/" data-id="cl17apw2f0027icud5bn1d3q5" data-title="教材典型算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/mid-lake-pavilion.github.io/2021/11/28/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          git的基本使用
        
      </div>
    </a>
  
  
    <a href="/mid-lake-pavilion.github.io/2021/11/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">线性表</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/CF/">CF</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Java程序设计</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Web%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">Web前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/">前端之路</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E5%86%A5%E6%83%B3/">多一点冥想</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/">数字逻辑设计</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E8%8A%B1%E9%97%B4%E4%B8%80%E5%A3%B6%E9%85%92/">花间一壶酒</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF/">面向对象建模技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" rel="tag">大学课程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/mid-lake-pavilion.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" style="font-size: 20px;">大学课程</a> <a href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/hello/">hello</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">概念结构设计</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/24/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript的正则表达式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/mid-lake-pavilion.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/mid-lake-pavilion.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/mid-lake-pavilion.github.io/js/jquery-3.4.1.min.js"></script>



  
<script src="/mid-lake-pavilion.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/mid-lake-pavilion.github.io/js/script.js"></script>





  </div>
</body>
</html>