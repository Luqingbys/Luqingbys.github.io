<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://luqingbys.github.io/mid-lake-pavilion.github.io/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/mid-lake-pavilion.github.io/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/mid-lake-pavilion.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/mid-lake-pavilion.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/mid-lake-pavilion.github.io/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/mid-lake-pavilion.github.io/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/mid-lake-pavilion.github.io/">Home</a>
        
          <a class="main-nav-link" href="/mid-lake-pavilion.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/mid-lake-pavilion.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://luqingbys.github.io/mid-lake-pavilion.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-G2库的使用心得" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2022/01/06/G2%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" class="article-date">
  <time class="dt-published" datetime="2022-01-06T06:59:32.000Z" itemprop="datePublished">2022-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2022/01/06/G2%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">G2库的使用心得</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2022/01/06/G2%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" data-id="cl17apw1h0008icud646bdvxn" data-title="G2库的使用心得" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-自定义事件与全局通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2022/01/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%A8%E5%B1%80%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2022-01-05T04:09:07.000Z" itemprop="datePublished">2022-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2022/01/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%A8%E5%B1%80%E9%80%9A%E4%BF%A1/">自定义事件与全局通信</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>vue3中使用全局事件总线，借助vuex管理全局变量，可以实现任意两个组件之间的通信。</p>
<blockquote>
<p>效果：<br>点击区域图或者条形图的地图块或者柱形，可以实现从Home组件到Result组件的跳转，并且直接选中对应的省份并进行筛选展示。</p>
</blockquote>
<h2 id="事件的定义与触发"><a href="#事件的定义与触发" class="headerlink" title="事件的定义与触发"></a>事件的定义与触发</h2><p>由此可以看出，涉及两个组件的通信：Home组件和Result组件。<br>而双方通信的数据是Result组件中的selectProvince（选中省份信息），因此在vuex中定义一个共享数据province。</p>
<h3 id="事件的定义"><a href="#事件的定义" class="headerlink" title="事件的定义"></a>事件的定义</h3><p>首先我们需要在Home组件定义一个自定义事件（event），命名为events_ClickMap，这个事件的回调将会是最后调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自定义事件</span></span><br><span class="line"><span class="title function_">useAppEvents</span>(<span class="string">&#x27;events_ClickMap&#x27;</span>, <span class="function">(<span class="params">option: string</span>) =&gt;</span> &#123;</span><br><span class="line">  store.<span class="title function_">commit</span>(<span class="string">&#x27;FILTER_UPTATE&#x27;</span>, option)</span><br><span class="line">  <span class="title function_">handleClick2FilterResult</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在事件的回调中，需要利用mutations中的方法对共享数据进行修改，并且实现路由跳转。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter.ts文件</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">FilterCondition</span> &#123;</span><br><span class="line">  <span class="attr">province</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">state</span>: <span class="title class_">FilterCondition</span> = &#123;</span><br><span class="line">  <span class="attr">province</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="attr">FILTER_UPTATE</span>: (<span class="attr">state</span>: <span class="title class_">FilterCondition</span>, <span class="attr">province</span>: string): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    state.<span class="property">province</span> = province</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件的触发"><a href="#事件的触发" class="headerlink" title="事件的触发"></a>事件的触发</h3><p>触发事件直接在于点击图中的元素（地图块或者柱形），因此为每一个元素绑定上之前定义的自定义事件events_ClickMap即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定自定义事件</span></span><br><span class="line">  mapChart.<span class="title function_">on</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">(<span class="params">event: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">emitAppEvent</span>(<span class="string">&#x27;events_ClickMap&#x27;</span>, event.<span class="property">name</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>事件的event触发时会接收到参数，其中的name属性指向了点击元素的省份名。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2022/01/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%A8%E5%B1%80%E9%80%9A%E4%BF%A1/" data-id="cl17apw2r0038icuddntke9iw" data-title="自定义事件与全局通信" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-New-Year-s-Problem" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2022/01/04/New-Year-s-Problem/" class="article-date">
  <time class="dt-published" datetime="2022-01-04T12:56:23.000Z" itemprop="datePublished">2022-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/CF/">CF</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2022/01/04/New-Year-s-Problem/">New Year&#39;s Problem</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<blockquote>
<p>问题传送门<br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1619/problem/D">https://codeforces.com/contest/1619/problem/D</a></p>
</blockquote>
</blockquote>
<h2 id="问题大意"><a href="#问题大意" class="headerlink" title="问题大意"></a>问题大意</h2><p>需要从m个商店给n位朋友买礼物，每人一个，从j号商店为i号朋友买礼物，得到joy值为矩阵元素 $ a_{i}{j} $<br>矩阵A记录的是joy值，m行n列，规定最多只能去n-1个商店买礼物，且最后每一个朋友都会得到一个joy值，求在所有情况下，n个朋友的joy值的最小值最大能为多少。</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>经过一番分析，可以想到这个题目需要用到二分算法。具体怎么用，其实就是之前做过的二分答案。所谓二分答案，就是题目的答案只可能是某一个最大值和最小值之间的一个数，且通过不断地二分，从而确定答案。<br>模板如下，仅供参考：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lower=min, upper=max;</span><br><span class="line"><span class="type">int</span> mid, ans;</span><br><span class="line"><span class="keyword">while</span>(lower&lt;=upper)</span><br><span class="line">&#123;</span><br><span class="line">    mid = lower+(upper - lower)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isOk</span>(mid))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示当前mid是符合条件的，但是不一定就是最终的答案，还需要从右边较大区间继续取数检验</span></span><br><span class="line">        ans = mid;</span><br><span class="line">        lower = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示mid值过大了，从左边的区间取</span></span><br><span class="line">        upper = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，本题的关键就在于，如何确定选中的mid值是符合条件的呢？<br>根据题意，我们可以得知，其实要满足题意，需要两个条件：</p>
<ol>
<li>至多去n-1个商店，也就是至少存在一个商店，在其中购买的礼物至少有两个（因为一共买n个礼物）；</li>
<li>每一个朋友有且仅有一个礼物。</li>
</ol>
<p>所以，在isOk()中，对矩阵进行遍历检验即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两点：</span></span><br><span class="line"><span class="comment">// 1.至少有一个商店，在其中购买至少两件礼物；</span></span><br><span class="line"><span class="comment">// 2.每一个朋友都有且仅有一件礼物</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOk</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; all)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (all[i][j] &gt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">                fri[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//条件一满足，就置flag标志变量为1，否则一直为0</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">2</span>)  flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检验条件二，是否每一个朋友都有礼物</span></span><br><span class="line">    <span class="type">int</span> isAll = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        isAll = isAll &amp;&amp; fri[i];</span><br><span class="line">    <span class="keyword">return</span> isAll &amp;&amp; flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，问题得以解决。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2022/01/04/New-Year-s-Problem/" data-id="cl17apw1q000qicudcyjh9yqn" data-title="New Year&#39;s Problem" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MEX-and-Increments" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2022/01/03/MEX-and-Increments/" class="article-date">
  <time class="dt-published" datetime="2022-01-03T12:18:33.000Z" itemprop="datePublished">2022-01-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/CF/">CF</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2022/01/03/MEX-and-Increments/">MEX and Increments</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>要知道，我们要想求出当前序列（i）的mex，需要有从0<del>i-1的所有数字，同时，将所有数字i自增1即可。记录上得到0</del>i-1每一个数至少一个所需要的操作数记作dp[i-1]，同时加上数字i出现的次数，就是答案了。<br>而在已经有0~i-1的基础上，如何得到i呢？（这就是本题的关键，即所谓的动态转移方程）：</p>
<ol>
<li>i本来就存在，这种情况最简单，此时dp[i]与dp[i-1]相等。</li>
<li>i不存在，需要借助0<del>i-1中的数生成（注意，用来生成i的数至少出现过2次，否则0</del>i-1每一个数至少出现一次的条件被打破）。</li>
</ol>
<p>为了节省时间，我们首先需要得到每一个数字出现次数的数组times[]，从times[1]开始分析，遇见大于2的数，需要将其入栈，同时记录下其出现次数（可以用pair记录，为了方便之后生成不存在的数，届时只需取出栈顶数，令其出现次数减一即可。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">1</span> ;</span><br><span class="line"><span class="type">int</span> all[N] ;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; PII ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> t;</span><br><span class="line"> cin &gt;&gt;t ;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="type">int</span>  n ;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; p ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++ ) cin&gt;&gt;all[i] , p[all[i]] ++ ;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span>  sum = <span class="number">0</span> , ch = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">if</span>(!p[<span class="number">0</span>]) &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;0 &quot;</span> ;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++ ) &#123;</span><br><span class="line">				cout&lt;&lt;<span class="number">-1</span> &lt;&lt;<span class="string">&quot; &quot;</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">continue</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ok = <span class="number">1</span> ;</span><br><span class="line">		cout&lt;&lt;p[<span class="number">0</span>] &lt;&lt;<span class="string">&quot; &quot;</span> ;</span><br><span class="line">		p[<span class="number">0</span>] -- ;</span><br><span class="line">		priority_queue&lt;PII&gt; q;</span><br><span class="line">		<span class="keyword">if</span>(p[<span class="number">0</span>] != <span class="number">0</span>) q.<span class="built_in">push</span>(&#123;<span class="number">0</span> , p[<span class="number">0</span>]&#125;) ;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n;i ++ ) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ok == <span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;-1 &quot;</span> ;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p[i] == <span class="number">0</span> ) &#123;</span><br><span class="line">				cout&lt;&lt; ch &lt;&lt;<span class="string">&quot; &quot;</span> ;</span><br><span class="line">				<span class="keyword">if</span>(q.<span class="built_in">size</span>() != <span class="number">0</span> )&#123;</span><br><span class="line">					<span class="keyword">auto</span> t = q.<span class="built_in">top</span>() ;</span><br><span class="line">					q.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="type">long</span> <span class="type">long</span> x = t.first , y =t.second;</span><br><span class="line">					ch += i - x ;</span><br><span class="line">					y -- ;</span><br><span class="line">					<span class="keyword">if</span>(y != <span class="number">0</span> ) &#123;</span><br><span class="line">						q.<span class="built_in">push</span>(&#123;x , y &#125;) ;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					ok = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cout&lt;&lt;ch + p[i] &lt;&lt;<span class="string">&quot; &quot;</span> ;</span><br><span class="line">				p[i] -- ;</span><br><span class="line">				<span class="keyword">if</span>(p[i])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(&#123;i , p[i]&#125;) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2022/01/03/MEX-and-Increments/" data-id="cl17apw1r000ricud5xh963z4" data-title="MEX and Increments" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CPU的结构和功能" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/12/25/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/" class="article-date">
  <time class="dt-published" datetime="2021-12-25T10:55:30.000Z" itemprop="datePublished">2021-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2021/12/25/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/">CPU的结构和功能</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ul>
<h3 id="CPU的结构框图"><a href="#CPU的结构框图" class="headerlink" title="CPU的结构框图"></a>CPU的结构框图</h3><ul>
<li>运算器（ALU）</li>
<li>控制器（CU）</li>
<li>存放操作数的寄存器</li>
<li>中断系统</li>
</ul>
<h3 id="控制器CU的功能"><a href="#控制器CU的功能" class="headerlink" title="控制器CU的功能"></a>控制器CU的功能</h3><ul>
<li>取指令</li>
<li>分析指令</li>
<li>执行指令</li>
</ul>
<h3 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h3><ol>
<li>用户可见寄存器<br>通常CPU执行机器语言访问的寄存器为用户可见寄存器。按特征还可分为：<ul>
<li>通用寄存器<br>许多指定功能，如某种寻址方式所需的专用寄存器</li>
<li>数据寄存器<br>存放各种数据类型的操作数</li>
<li>地址寄存器<br>存放地址</li>
<li>条件码寄存器<br>存放条件码</li>
</ul>
</li>
</ol>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>区分三个概念：</p>
<ul>
<li>指令周期<ul>
<li>CPU从内存中读取一个指令字的最短时间</li>
<li>一条指令的取出阶段被定义为一个CPU周期时间</li>
<li>也称“机器周期”</li>
<li>一个完整的指令周期，包括取址、间址、执行和中断四个子周期。</li>
</ul>
</li>
<li>时钟周期<ul>
<li>是CPU处理操作的最基本单位</li>
<li>一个CPU周期由若干个时钟周期构成的</li>
</ul>
</li>
<li>指令周期<ul>
<li>CPU取出并执行一条指令所需的全部时间</li>
<li>包括取指令周期和执行指令周期。</li>
</ul>
</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>取指令—分析指令—执行指令</p>
</blockquote>
<h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><ol>
<li>结构相关<br>不同指令将指令与数据保存在同一个寄存器中。</li>
<li>数据相关</li>
</ol>
<h3 id="尝试的解决技术"><a href="#尝试的解决技术" class="headerlink" title="尝试的解决技术"></a>尝试的解决技术</h3><ol>
<li>超级流水线巩固</li>
<li>超长指令字技术</li>
</ol>
<blockquote>
<p>理想情况下，n级流水的速度是不采用n级流水技术的n倍。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/12/25/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/" data-id="cl17apw150000icudg9vo87e1" data-title="CPU的结构和功能" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-输入-输出接口" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/12/24/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time class="dt-published" datetime="2021-12-23T23:22:13.000Z" itemprop="datePublished">2021-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2021/12/24/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/">输入/输出接口</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h2><blockquote>
<p>接口<br>接口是两个系统获两个部件之间的衔接部分，包括硬件接口和软件接口<br>I&#x2F;O接口是连接主机与I&#x2F;O设备之间的中间电路或部件，由硬件电路、相应的控制软件构成。<br>接口的功能：</p>
<ul>
<li><p>地址识别和设备选择</p>
</li>
<li><p>接收、保存CPU的I&#x2F;O控制命令</p>
</li>
<li><p>反映外设的工作状态</p>
</li>
<li><p>信号转换<br>端口<br>端口是I&#x2F;O电路中可通过编程寻址并进行读&#x2F;写的寄存器<br>接口中包含端口</p>
</li>
<li><p>数据端口</p>
</li>
<li><p>控制端口</p>
</li>
<li><p>状态端口<br>不同场合下“端口”具有不同的含义：</p>
</li>
<li><p>I&#x2F;O接口中的端口，实际上是指寄存器</p>
</li>
<li><p>上网端口</p>
</li>
<li><p>网络应用程序的标示</p>
</li>
</ul>
</blockquote>
<h2 id="I-x2F-O接口的组成与工作原理"><a href="#I-x2F-O接口的组成与工作原理" class="headerlink" title="I&#x2F;O接口的组成与工作原理"></a>I&#x2F;O接口的组成与工作原理</h2><p>I&#x2F;O接口由数据缓冲寄存器、状态寄存器、命令寄存器、端口寄存器、控制逻辑和中断逻辑组成。<br>而I&#x2F;O接口所进行的工作，都是通过接口中用户可见的寄存器————端口的“读写”来实现的。</p>
<h3 id="I-x2F-O接口的组成"><a href="#I-x2F-O接口的组成" class="headerlink" title="I&#x2F;O接口的组成"></a>I&#x2F;O接口的组成</h3><p>I&#x2F;O接口由数据缓冲寄存器DBR、设备选择电路、设备状态标记、命令寄存器和命令译码器、控制逻辑电路五部分组成。</p>
<h3 id="I-x2F-O设备的编址方法"><a href="#I-x2F-O设备的编址方法" class="headerlink" title="I&#x2F;O设备的编址方法"></a>I&#x2F;O设备的编址方法</h3><ul>
<li>统一编址<br>I&#x2F;O设备地址与内存统一进行编址，即在存储器中单独划定一片空间，存放I&#x2F;O设备地址。</li>
<li>独立编址（不统一编址）<br>I&#x2F;O地址与内存有各自独立的地址空间，互不干扰。需要设置专门的I&#x2F;O指令。</li>
</ul>
<h3 id="I-x2F-O设备与主机信息传送的控制方式"><a href="#I-x2F-O设备与主机信息传送的控制方式" class="headerlink" title="I&#x2F;O设备与主机信息传送的控制方式"></a>I&#x2F;O设备与主机信息传送的控制方式</h3><ul>
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>DMA方式</li>
<li>通道方式</li>
<li>外围处理机</li>
</ul>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>由CPU通过程序不断查询I&#x2F;O设备是否做好准备，从而控制I&#x2F;O设备与主机交换信息。</p>
<p>特点：</p>
<ul>
<li>由CPU主动查询外设</li>
<li>CPU和I&#x2F;O串行工作</li>
<li>CPU效率低下</li>
</ul>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul>
<li>中断发生是随机的。</li>
<li>程序是否被中断，不影响其运行结果。</li>
<li>任何时刻，CPU只能为一个中断源的请求提供服务。</li>
</ul>
<h5 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h5><ol>
<li>中断请求</li>
<li>中断判优</li>
<li>中断响应<br>在CPU的EINT为“1”时，CPU在每条指令执行的末尾，扫描INTR引脚，若有中断请求，则“中断状态”触发器INT置为1，进入中断周期，执行“中断隐指令”。<blockquote>
<p>中断隐指令功能：<br>将程序断点、标志位寄存器压入堆栈<br>关中断<br>将中断处理程序的首地址送入PC</p>
</blockquote>
</li>
<li>中断服务<br>由预先编制的中断服务程序完成。<br>中断服务程序，说到底就是CPU去响应I&#x2F;O外设的申请了，为中断源服务去了。<br>中断服务程序的处理流程是：<ul>
<li>保护现场<br>保护程序断点和CPU内部寄存器的内容</li>
<li>中断服务（设备服务，是中断服务程序的主体部分）</li>
<li>恢复现场<br>恢复程序断点和CPU内部寄存器的内容</li>
<li>（中断返回）</li>
</ul>
</li>
<li>中断返回</li>
</ol>
<h5 id="形成中断入口地址的方法"><a href="#形成中断入口地址的方法" class="headerlink" title="形成中断入口地址的方法"></a>形成中断入口地址的方法</h5><ul>
<li>软件查询法<br>采用一个中断管理程序，按照优先级从高到低，依次查询每一个中断源是否有中断请求。</li>
<li>硬件向量法<br>有硬件生成一个特定的地址————向量地址，然后将向量地址通过数据总线送给CPU，CPU再依据向量地址转去执行中断服务程序。</li>
</ul>
<h5 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h5><p>处理中断过程中，可能有新的、优先级更高的中断请求到来。若CPU转去处理新的中断请求，称为多重中断、中断嵌套，否则称为单重中断。</p>
<h5 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h5><p>CPU根据中断屏蔽字决定屏蔽掉某些级别中断的请求信号，使其不能进入排队器排队，从而间接改变中断响应顺序。</p>
<p>注意，优先级严格来说，包含响应优先级和处理优先级，而我们设置的中断屏蔽字，改变的是中断处理优先级。</p>
<h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>DMA，即 Direct Memory Access，直接内存访问，指CPU暂时让出总线的控制权，由专用接口芯片DMAC————DMA控制器，全权控制存储器与I&#x2F;O之间直接进行高速的数据传送。<br>在DMA的数据传输过程中，CPU不干预，从而提高了CPU的效率。</p>
<h3 id="DMAC的组成"><a href="#DMAC的组成" class="headerlink" title="DMAC的组成"></a>DMAC的组成</h3><p>DMA控制器由如下部件组成：</p>
<ul>
<li>主存地址寄存器(AR)</li>
<li>字计数器(WC)</li>
<li>数据缓冲寄存器(BR)</li>
<li>设备地址寄存器(DAR)</li>
<li>中断逻辑</li>
<li>控制&#x2F;状态逻辑</li>
</ul>
<h3 id="DMA的工作过程"><a href="#DMA的工作过程" class="headerlink" title="DMA的工作过程"></a>DMA的工作过程</h3><ol>
<li>预处理<br>即CPU选择DMAC和I&#x2F;O接口，将一下信息写入对应的寄存器：<ul>
<li>外设地址————DAR</li>
<li>数据块在主存中的首地址————AR</li>
<li>数据个数————WC</li>
</ul>
</li>
<li>数据传输<br>以数据块为单位，传送数据。</li>
<li>后处理<br>数据传输结束后，DMA发起中断请求，得到响应，CPU将停止原程序的执行，转去执行中断服务程序，做一些DMA的结束工作。</li>
</ol>
<h3 id="DMAC的数据传输过程"><a href="#DMAC的数据传输过程" class="headerlink" title="DMAC的数据传输过程"></a>DMAC的数据传输过程</h3><p>DMA的数据传送模式包括：</p>
<ul>
<li>单字传送</li>
<li>成组传送</li>
<li>请求传送</li>
</ul>
<h3 id="CPU与DMAC分享主存-x2F-系统总线的方式"><a href="#CPU与DMAC分享主存-x2F-系统总线的方式" class="headerlink" title="CPU与DMAC分享主存&#x2F;系统总线的方式"></a>CPU与DMAC分享主存&#x2F;系统总线的方式</h3><p>DMAC占用总线的方式，通常有三种：</p>
<ul>
<li>停止CPU使用总线<br>控制方式简单，但是CPU的工作会受到明显的延误。</li>
<li>周期挪用<br>DMAC在CPU不使用总线时，“窃取”若干个总线周期，来传送一个数据字，几乎不影响CPU工作，应用最为广泛。</li>
<li>交替使用<br>将CPU的工作周期分为两个子周期，由DMAC和CPU分别使用总线。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/12/24/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/" data-id="cl17apw2w003iicudfgd8dt5a" data-title="输入/输出接口" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-指令系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/12/17/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-12-17T15:59:54.000Z" itemprop="datePublished">2021-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2021/12/17/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">指令系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><h3 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h3><p>指令由两个部分组成：</p>
<ul>
<li>操作码字段</li>
<li>地址码字段</li>
</ul>
<h4 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h4><p>前者反映机器做什么操作。其长度可固定，也可变化。</p>
<ul>
<li>长度固定：大中型计算机</li>
<li>长度不固定：微型机</li>
</ul>
<blockquote>
<p>扩展操作码技术<br>操作码的位数随地址数的减少而增加。</p>
</blockquote>
<h4 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h4><p>地址码用来指出操作数的地址，包括</p>
<ul>
<li>源操作数的地址</li>
<li>结果目的操作数的地址</li>
<li>下一条指令的地址</li>
</ul>
<p>按照操作数地址的数目可以分为：</p>
<ul>
<li>四地址指令</li>
<li>三地址指令</li>
<li>二地址指令</li>
<li>一地址指令</li>
<li>零地址指令</li>
</ul>
<p>下面分别介绍不同类型的地址指令：</p>
<h5 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h5><table>
<thead>
<tr>
<th>OP</th>
<th>A1</th>
<th>A2</th>
<th>A3</th>
<th>A4</th>
</tr>
</thead>
<tbody><tr>
<td>OP是操作码，A1为第一操作数地址，A2为第二操作数地址，A3为结果数地址，A4为下一条指令地址。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>需要访问存储器4次：取操作码，取操作数两次，存放结果</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h5><p>由于PC可以记录下一条指令的地址，故在四地址指令基础上可以省略A4，得到三地址指令。<br>仍然需要访问存储器4次。</p>
<h5 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h5><p>运算的结果不存入存储器，而是存入CPU中的ACC，那么就可以节省一个地址字段A3。</p>
<h5 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h5><p>一个操作数也存放在ACC中，那么整个地址码只有一个字段，表示另一个操作数所在内存地址。</p>
<h5 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h5><p>有些操作不需要操作数，如停机、中断返回、空操作等。</p>
<h3 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h3><blockquote>
<p>机器字长：计算机一次能够处理的最长的二进制位数<br>存储字长：一个存储单元可存储的二进制代码的位数<br>指令字长：指令中包含的二进制代码的位数，等于操作码长度加上地址码长度</p>
</blockquote>
<h2 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h2><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>包括地址、数字、字符、逻辑数等。</p>
<h3 id="存储器中数据的存放"><a href="#存储器中数据的存放" class="headerlink" title="存储器中数据的存放"></a>存储器中数据的存放</h3><p>边界对准。</p>
<h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p>不同的机器操作类型不同，但是有以下几类通用操作。</p>
<ul>
<li>数据传送</li>
<li>算术逻辑操作</li>
<li>移位操作</li>
<li>转移<ul>
<li>无条件转移</li>
<li>条件转移</li>
<li>调用和返回</li>
<li>陷阱指令</li>
</ul>
</li>
<li>输入输出指令</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>目的：用以确定本条指令的操作数地址和下一条欲执行指令的指令地址。<br>可分为：</p>
<ul>
<li>指令寻址</li>
<li>数据寻址</li>
</ul>
<h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>分为</p>
<ul>
<li>顺序寻址<br>依靠程序计数器PC形成下一条指令的地址，顺序寻址</li>
<li>跳跃寻址<br>通过转移类指令实现，如JMP 7</li>
</ul>
<h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><p>通常，指令中的地址码不给出数据的有效地址（记作EA），而是给出一个形式地址（A）。</p>
<ol>
<li>立即寻址<br>形式地址A就是操作数，称为立即数；<br>但是形式地址A的位数限制了立即数的范围。</li>
<li>直接寻址<br>有效地址由形式地址直接给出；<br>但是，A的位数限制了指令操作数的寻址范围，且操作数的地址不易修改。</li>
<li>隐含寻址<br>操作数地址隐含在操作码中。</li>
<li>间接寻址<br>数据的有效地址由形式地址间接提供；<br>这样一来，可以扩大寻址范围，也便于编制程序。</li>
<li>寄存器直接寻址<br>有效地址即为寄存器编号。</li>
<li>寄存器间接寻址<br>有效地址在寄存器中，而操作数在存储器中。也就是说，与寄存器直接寻址相比，间接寻址还需要访问主存。</li>
<li>基址寻址<br>OP 寻址特征 基址寄存器 操作数地址<br>基址寄存器中的内容由操作系统确定，<br>在程序执行过程中，基址寄存器中的内容不变，而形式地址改变。<blockquote>
<p>基址寄存器有隐式和显式两种。<br>隐式无需用户指出，显式相当于在一组通用寄存器中，由用户明确指出哪一个作为基址寄存器。</p>
</blockquote>
</li>
<li>变址寻址<br>特点：EA &#x3D; (IX) + A<br>其中，IX为变址寄存器，其内容由用户给定<br>在程序执行过程中，IX内容可变，形式地址A不变</li>
<li>相对寻址<br>公式：EA &#x3D; (PC) + A<br>A是相对于当前指令的位移量（可正可负，补码形式）</li>
</ol>
<h2 id="RISC与CISC"><a href="#RISC与CISC" class="headerlink" title="RISC与CISC"></a>RISC与CISC</h2><p>RISC，采用组合逻辑控制器<br>CISC，采用微程序控制器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/12/17/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" data-id="cl17apw2d0023icudam43309a" data-title="指令系统" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-存储器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/12/17/%E5%AD%98%E5%82%A8%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-12-17T13:05:02.000Z" itemprop="datePublished">2021-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2021/12/17/%E5%AD%98%E5%82%A8%E5%99%A8/">存储器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><h3 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h3><ul>
<li>半导体存储器，如TTL、MOS，是易失性</li>
<li>磁表面存储器，如磁盘、磁带，非易失性</li>
<li>磁芯存储器，非易失性</li>
<li>光盘存储器，非易失性</li>
</ul>
<h3 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h3><ul>
<li>存取时间与物理地址无关<ul>
<li>随机存储器</li>
<li>只读存储器</li>
</ul>
</li>
<li>存取时间与物理地址有关<ul>
<li>顺序存取存储器</li>
<li>直接存取存储器</li>
</ul>
</li>
</ul>
<h3 id="按在计算机中的作用分类"><a href="#按在计算机中的作用分类" class="headerlink" title="按在计算机中的作用分类"></a>按在计算机中的作用分类</h3><ul>
<li>主存储器</li>
<li>Flash Memory（闪存）</li>
<li>高速缓冲存储器（Cache）</li>
<li>辅助存储器，如磁盘、磁带、光盘</li>
</ul>
<h2 id="存储器的存储结构"><a href="#存储器的存储结构" class="headerlink" title="存储器的存储结构"></a>存储器的存储结构</h2><p>三个主要特性：</p>
<ul>
<li>速度</li>
<li>容量</li>
<li>位价（价格&#x2F;位）</li>
</ul>
<p>金字塔形说明图</p>
<h3 id="两个层次结构"><a href="#两个层次结构" class="headerlink" title="两个层次结构"></a>两个层次结构</h3><ul>
<li>缓存-主存层次：解决CPU和主存速度不匹配的问题</li>
<li>主存-辅存层次：解决存储系统的容量问题</li>
</ul>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存概述"><a href="#主存概述" class="headerlink" title="主存概述"></a>主存概述</h3><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><ol>
<li>存储容量：主存中存放二进制代码的总位数</li>
<li>存储速度<ol>
<li>存取时间：存储器的访问时间</li>
<li>存取周期：存储器进行一次完整的读写操作所需的全部时间，即连续两次独立的存储器操作所需的最小间隔时间</li>
</ol>
</li>
<li>存储器带宽：单位时间内存储器存取的信息量</li>
</ol>
<blockquote>
<p>存取时间不等于存储周期，通常存储周期大于存储时间。这是因为对任何一种存储器，在读写操作之后，总要有一段时间恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，因为存储器中的信息读出后需要马上进行再生。</p>
</blockquote>
<h3 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h3><h4 id="半导体存储芯片的译码驱动"><a href="#半导体存储芯片的译码驱动" class="headerlink" title="半导体存储芯片的译码驱动"></a>半导体存储芯片的译码驱动</h4><p>驱动方式有两种：</p>
<ul>
<li>线选法</li>
<li>重合法</li>
</ul>
<h3 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h3><p>分为静态RAM和动态RAM。</p>
<h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><p>由于动态RAM用到了电容，电容会漏电，所以动态RAM需要“刷新”。</p>
<h4 id="动态RAM与静态RAM的比较"><a href="#动态RAM与静态RAM的比较" class="headerlink" title="动态RAM与静态RAM的比较"></a>动态RAM与静态RAM的比较</h4><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><ol>
<li>掩模ROM（MROM）</li>
<li>PROM：一次性编程的只读存储器</li>
<li>EPROM：可擦除可编程只读存储器<ol>
<li>紫外线照射擦除</li>
<li>电气方法擦除（电可擦写）</li>
</ol>
</li>
<li>EEPROM：电可擦写、局部擦写、全部擦写</li>
<li>闪速存储器</li>
</ol>
<h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><h4 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h4><p>包括三种扩展：</p>
<ul>
<li>位扩展</li>
<li>字扩展</li>
<li>字、位扩展</li>
</ul>
<h5 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h5><p>即增加存储字长。<br>以两块芯片为例，注意它们的数据引脚连接数据线，片选信号连接在一起（保证位扩展的两块存储芯片一起工作）。</p>
<h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p>即增加存储字的数量。<br>注意扩展的是存储字的数量，存储字长不变，也就是说，被扩展的两个存储芯片不可以一起工作，而是通过片选信号每次选中一块，从而使得两块芯片都可以工作。</p>
<h5 id="字、位扩展"><a href="#字、位扩展" class="headerlink" title="字、位扩展"></a>字、位扩展</h5><p>存储字长和存储字的数量同时扩展。</p>
<h4 id="连接做法"><a href="#连接做法" class="headerlink" title="连接做法"></a>连接做法</h4><p>存储器与CPU的连接，需要注意：</p>
<ul>
<li>地址线<br>CPU地址线往往比存储芯片地址线多，通常将CPU地址线的低位与存储芯片的地址线相连。</li>
<li>数据线<br>经位扩展之后，CPU和存储芯片数据线数量相等，直接相连即可。</li>
<li>读写命令线<br>按照要求相连即可。</li>
<li>片选线的连接（重要）<br>是CPU与存储芯片正确工作的关键。通常由CPU地址线高位来形成片选信号。</li>
<li>合理选择存储芯片</li>
</ul>
<h3 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h3><h3 id="提高主存储器访问带宽"><a href="#提高主存储器访问带宽" class="headerlink" title="提高主存储器访问带宽"></a>提高主存储器访问带宽</h3><p>解决方法：</p>
<ul>
<li>采用高速器件</li>
<li>采用层次结构 Cache-主存</li>
<li>调整主存结构<ul>
<li>引入并行处理技术，如并行处理器，多端口RAM、多模块处理器等。</li>
</ul>
</li>
</ul>
<h4 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h4><p>具有两个独立的端口，分别具有各自的地址总线、数据总线和控制总线。</p>
<h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><ol>
<li>单体多字系统<br>由于程序访问存在着局部性，所以对相邻存储信息的使用往往是连续的。多个存储器共用一套地址逻辑，一个访存地址就可以把存储于多个存储器模块中相同地址单元的多个字一并读出。</li>
<li>多体并行系统<ol>
<li>高位交叉存储<br>体号 体内地址<br>即地位地址表示体内地址，高位地址表示体号。<br>特点：<ul>
<li>同一个存储体的地址空间连续</li>
<li>不利于并行处理</li>
<li>容易发生访存冲突</li>
<li>有着可靠性高的优点<br> 本质上，由于局部性原理，相邻存储信息的使用往往连续，按照高位交叉存储方式，相邻存储信息一般保存在同一个存储器中了。</li>
</ul>
</li>
<li>低位交叉存储<br>体内地址 体号<br>它的特点与高位交叉存储的完全相反。<br> 本质上，由于局部性原理，相邻存储信息的使用往往连续，按照低位交叉存储方式，相邻存储信息一般保存在不同的存储器中（体号连续）了。</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/12/17/%E5%AD%98%E5%82%A8%E5%99%A8/" data-id="cl17apw2c0020icud5mok1k0x" data-title="存储器" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-GRASP原则" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/12/17/GRASP%E5%8E%9F%E5%88%99/" class="article-date">
  <time class="dt-published" datetime="2021-12-17T00:34:57.000Z" itemprop="datePublished">2021-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF/">面向对象建模技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2021/12/17/GRASP%E5%8E%9F%E5%88%99/">GRASP模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>GRASP模式，即“通用职责分配软件模式”，描述了对象设计和职责分配的基本原则，是面向对象系统的基础。<br>通俗地说，就是在一个面向对象的系统中，该添加什么方法（职责），给谁添加方法（职责），是值得我们深思的。<br>而GRASP模式，就给我们提供了指导。</p>
<p>GRASP模式，分为九种：</p>
<ul>
<li>信息专家模式</li>
<li>创造者模式</li>
<li>低耦合模式</li>
<li>高内聚模式</li>
<li>控制器模式</li>
<li>多态模式（层次类）</li>
<li>纯虚构模式</li>
<li>间接模式（另设中介类）</li>
<li>受保护模式</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/12/17/GRASP%E5%8E%9F%E5%88%99/" data-id="cl17apw1h000aicud28ucb546" data-title="GRASP模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-存储系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/mid-lake-pavilion.github.io/2021/12/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-12-12T08:45:58.000Z" itemprop="datePublished">2021-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/mid-lake-pavilion.github.io/2021/12/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">存储系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>Cache的出现，可以一定程度上解决以下三个方面的问题：</p>
<ul>
<li>解决DRAM主存与CPU速度之间的不匹配</li>
<li>解决CPU与I&#x2F;O的访存冲突</li>
<li>避免CPU“空等”现象</li>
</ul>
<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>局部性原理（程序访问的局部性原理）</p>
<h3 id="Cache思想"><a href="#Cache思想" class="headerlink" title="Cache思想"></a>Cache思想</h3><p>Cache体现的是一种思想：“缓存”思想，即将经常被用到的东西，放到更加容易方便获取的地方。</p>
<h3 id="Cache的使用"><a href="#Cache的使用" class="headerlink" title="Cache的使用"></a>Cache的使用</h3><ul>
<li>CPU内部集成了两级Cache，即L1CACHE，L2CACHE</li>
<li>主板上有Cache</li>
<li>硬盘、打印机、CD-ROM（只读光盘）等外围设备都加上了Cache；</li>
<li>访问网站时都会在本地保存网站的cookie；</li>
</ul>
<h3 id="“块”"><a href="#“块”" class="headerlink" title="“块”"></a>“块”</h3><p>数据块————把若干存储单元称为一个数据块；<br>此外，内存与Cache之间是以数据块为单位进行交换的。</p>
<h3 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h3><h4 id="主存和缓存的编址"><a href="#主存和缓存的编址" class="headerlink" title="主存和缓存的编址"></a>主存和缓存的编址</h4><p>主存储器和缓存地址都分成了两段，</p>
<ul>
<li>主存：高m位表示主存块地址，低b位表示块内地址</li>
<li>缓存：高c位表示缓存的块号，低b位表示块内地址</li>
</ul>
<h4 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h4><p>缓存的高c位表示存放的是哪一个主存块，相当于主存块的块号，CPU在访问Cache时，用主存地址的m位与标记位比较，确定是否命中。</p>
<ul>
<li>命中，则主存块已经调入缓存，主存块与缓存块已经建立了对应关系。</li>
<li>未命中，则主存块未调入缓存，主存块与缓存块未建立对应关系。</li>
</ul>
<h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><p>命中率是衡量Cache效率的主要指标。<br>$$ 命中率 &#x3D; \frac{CPU访问Cache的次数}{CPU访问内存和Cache的总次数} $$</p>
<p>可见，主存、缓存都用b位表示块内字数，即 $ 2^b $ 用以表示块的大小，称为块长。</p>
<h4 id="主存-Cache地址映像"><a href="#主存-Cache地址映像" class="headerlink" title="主存-Cache地址映像"></a>主存-Cache地址映像</h4><p>即将CPU送来的主存地址变换成Cache地址。依赖于主存Cache地址映像变换机构。<br>映射方式包括：</p>
<ul>
<li>直接映射</li>
<li>全相联映射</li>
<li>组相联映射</li>
<li>段相联映射</li>
</ul>
<h5 id="直接映射方式"><a href="#直接映射方式" class="headerlink" title="直接映射方式"></a>直接映射方式</h5><p>记Cache块号为i，主存块号为j，Cache总块数量为C，则映射为：<br>$$ i &#x3D; j mod C $$</p>
<p>可以看出，每一个Cache块i可以对应多个主存块；<br>而每一个主存块j只能和一个Cache缓存块i对应。</p>
<p>但是，由于每一个Cache缓存块可以和 $ 2^{m-c}个主存块对应 $，故主存地址高位有t&#x3D;m-c位为主存字块标记，Cache也有t位记录当前对应的是哪一个主存（块号）。</p>
<h5 id="全相联映射方式"><a href="#全相联映射方式" class="headerlink" title="全相联映射方式"></a>全相联映射方式</h5><p>即主存中的每一个字块映射到Cache中的任何一块位置上。<br>由于每一个Cache块对应全部的主存块，因此主存字块标记位有m&#x3D;t+c位，Cache也有m位。</p>
<h5 id="组相联映射方式"><a href="#组相联映射方式" class="headerlink" title="组相联映射方式"></a>组相联映射方式</h5><p>即Cache分为Q组，每组R块，则主存块j与Cache组号i之间的映射为：<br>$$ i &#x3D; j mod Q $$<br>可以看出，主存块与Cache之间是直接映射，主存块同Cache特定组内的块是全相联映射。</p>
<h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h3><h4 id="何为替换"><a href="#何为替换" class="headerlink" title="何为替换"></a>何为替换</h4><p>当一个新的主存块需要拷贝到Cache中，而允许存放该新块的位置被其他的主存块占用时，就需要替换。<br>由硬件完成。</p>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><ol>
<li>先进先出算法<br>即将最先调入Cache的字块替换出去。</li>
<li>近期最少使用算法<br>即将近期内最少使用的字块替换出去。</li>
<li>随机法</li>
</ol>
<h3 id="写操作策略"><a href="#写操作策略" class="headerlink" title="写操作策略"></a>写操作策略</h3><blockquote>
<p>Cache应该与主存内容保持一致，而CPU对Cache的写入会改变Cache中的内容，因此如何保持Cache与内存内容的一致性，就需要采取策略。</p>
</blockquote>
<ol>
<li>写回法<ul>
<li>当CPU与Cache命中时，只修改Cache中的内容，而不立即写入主存，只有当该块被替换出时，才写回主存。</li>
<li>优点：减少了CPU访问主存的次数。</li>
<li>缺点：写内存与写Cache是异步进行的，故存在内存与Cache不一致的隐患。</li>
<li>注意：为了区别Cache中的块是否经过了修改，另设标志位，“清”表示未修改过，“浊”表示已修改过。</li>
</ul>
</li>
<li>全写法<br>写Cache命中时，数据既写入Cache，也写入主存。<br>未命中时，数据只直接写入内存。</li>
<li>只写主存法<ul>
<li>当写Cache命中时，信息只写入主存，同时将相应的Cache块置为失效，也就是说，下一次需要时，再重新调入。</li>
<li>这种写法效率低下。</li>
</ul>
</li>
</ol>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li>当前计算机系统中，三级结构的存储器系统：<ul>
<li>高速缓冲存储器</li>
<li>主存储器</li>
<li>虚拟存储器</li>
</ul>
</li>
</ul>
<p>三级不同的存储器存放的信息必须满足如下两个原则：</p>
<ul>
<li>一致性原则：同一个信息在几个级别的存储器中必须保持相同的值。</li>
<li>包含性原则：处在内层的存储器中的信息一定被包含在外层的各个存储器中。</li>
</ul>
<h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>被传输N位，加入一位校验位，使得整个N+1位信息中“1”的个数为偶数（或者奇数），称为偶校验（奇校验）。</p>
<h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码是一种可以纠正一位差错的编码。</p>
<blockquote>
<p>纠错理论：L - 1 &#x3D; D + C,<br>其中，L是编码的最小距离，D是检测错误位数，C是纠正错误的位数<br>也就是说，要想编制具有更多位纠错能力的编码，则要求L更大。</p>
</blockquote>
<p>汉明码的组成</p>
<ul>
<li>海明码的位数：海明码需增添k位检测位</li>
<li>海明码的位置<br>每一个增添的检测位，负责检测一个小组，通常一个小组包含位数较多。<br>组：1，3，5，7<br>组：2，3，6，7<br>组：4，5，6，7</li>
<li>海明码的取值</li>
</ul>
<p>汉明码的纠错</p>
<p>实际上，是对传送后的汉明码形成新的检测位P，根据P的状态，可以直接指出错误的位置。</p>
<h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><h4 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h4><p>二进制数的运算</p>
<h4 id="CRC码的编码方法"><a href="#CRC码的编码方法" class="headerlink" title="CRC码的编码方法"></a>CRC码的编码方法</h4><p>k位校验码，位于原信息位的后面；<br>拿到题目给出的多项式G(x)，用多项式去除，拿到结果的余数，即为校验位。</p>
<h4 id="CRC码的检错与纠错"><a href="#CRC码的检错与纠错" class="headerlink" title="CRC码的检错与纠错"></a>CRC码的检错与纠错</h4><p>CRC码某一位出错，除以G(x)的结果必不为零。不同的出错位，其余数也不尽相同。<br>将不为零的余数补0继续模2除，得到下一信息位的出错余数；出错信息位对应的余数构成一个循环————“循环码”。</p>
<h2 id="字符的表示"><a href="#字符的表示" class="headerlink" title="字符的表示"></a>字符的表示</h2><ul>
<li>字符</li>
<li>EBCDIC码</li>
<li>ASCII码</li>
<li>汉字编码</li>
<li>Unicode码</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luqingbys.github.io/mid-lake-pavilion.github.io/2021/12/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" data-id="cl17apw2d0022icud0iq695ya" data-title="存储系统" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/mid-lake-pavilion.github.io/page/4/">&laquo; Prev</a><a class="page-number" href="/mid-lake-pavilion.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/mid-lake-pavilion.github.io/page/3/">3</a><a class="page-number" href="/mid-lake-pavilion.github.io/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/mid-lake-pavilion.github.io/page/6/">6</a><a class="page-number" href="/mid-lake-pavilion.github.io/page/7/">7</a><a class="page-number" href="/mid-lake-pavilion.github.io/page/8/">8</a><a class="extend next" rel="next" href="/mid-lake-pavilion.github.io/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/CF/">CF</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Java程序设计</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/Web%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">Web前端基础</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/">前端之路</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E5%A4%9A%E4%B8%80%E7%82%B9%E5%86%A5%E6%83%B3/">多一点冥想</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/">数字逻辑设计</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E8%8A%B1%E9%97%B4%E4%B8%80%E5%A3%B6%E9%85%92/">花间一壶酒</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/mid-lake-pavilion.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF/">面向对象建模技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" rel="tag">大学课程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/mid-lake-pavilion.github.io/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" style="font-size: 20px;">大学课程</a> <a href="/mid-lake-pavilion.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mid-lake-pavilion.github.io/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/hello/">hello</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/26/%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">概念结构设计</a>
          </li>
        
          <li>
            <a href="/mid-lake-pavilion.github.io/2022/03/24/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript的正则表达式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/mid-lake-pavilion.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/mid-lake-pavilion.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/mid-lake-pavilion.github.io/js/jquery-3.4.1.min.js"></script>



  
<script src="/mid-lake-pavilion.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/mid-lake-pavilion.github.io/js/script.js"></script>





  </div>
</body>
</html>